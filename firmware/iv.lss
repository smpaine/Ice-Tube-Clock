
iv.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000136  00800100  000037a2  00003836  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000037a2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000b1  00800236  00800236  0000396c  2**0
                  ALLOC
  3 .debug_aranges 000000a0  00000000  00000000  0000396c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000072e  00000000  00000000  00003a0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000030cb  00000000  00000000  0000413a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000942  00000000  00000000  00007205  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003aa7  00000000  00000000  00007b47  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000004e0  00000000  00000000  0000b5f0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000007bd  00000000  00000000  0000bad0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000018c6  00000000  00000000  0000c28d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000002a0  00000000  00000000  0000db53  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 ce 00 	jmp	0x19c	; 0x19c <__ctors_end>
       4:	0c 94 e6 0f 	jmp	0x1fcc	; 0x1fcc <__vector_1>
       8:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
       c:	0c 94 16 0e 	jmp	0x1c2c	; 0x1c2c <__vector_3>
      10:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      14:	0c 94 6f 0e 	jmp	0x1cde	; 0x1cde <__vector_5>
      18:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      1c:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      20:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      24:	0c 94 2e 0c 	jmp	0x185c	; 0x185c <__vector_9>
      28:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      2c:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      30:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      34:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      38:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      3c:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      40:	0c 94 da 09 	jmp	0x13b4	; 0x13b4 <__vector_16>
      44:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      48:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      4c:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      50:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      54:	0c 94 48 03 	jmp	0x690	; 0x690 <__vector_21>
      58:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      5c:	0c 94 65 0d 	jmp	0x1aca	; 0x1aca <__vector_23>
      60:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      64:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>

00000068 <alphatable>:
      68:	fa 3e 1a 7a de 8e f6 2e 60 78 ae 1c aa 2a 3a ce     .>.z....`x...*:.
      78:	f3 0a b6 1e 38 38 b8 6e 76 da                       ....88.nv.

00000082 <alphatable_p>:
      82:	68 00                                               h.

00000084 <numbertable>:
      84:	fc 60 da f2 66 b6 be e0 fe f6                       .`..f.....

0000008e <numbertable_p>:
      8e:	84 00                                               ..

00000090 <twi_fmt>:
      90:	74 77 69 20 25 30 32 78 3a 25 30 32 78 0d 0a 00     twi %02x:%02x...

000000a0 <digittable>:
      a0:	03 07 08 09 06 0a 05 0c 04                          .........

000000a9 <digittable_p>:
      a9:	a0 00                                               ..

000000ab <segmenttable>:
      ab:	0b 10 12 0f 0d 0e 11 13                             ........

000000b3 <segmenttable_p>:
      b3:	ab 00                                               ..

000000b5 <dow_tbl>:
      b5:	00 03 02 05 00 03 05 01 04 06 02 04                 ............

000000c1 <mon_tbl>:
      c1:	1f 1c 1f 1e 1f 1e 1f 1f 1e 1f 1e 1f                 ............

000000cd <mon_tbl_p>:
      cd:	c1 00                                               ..

000000cf <__c.3534>:
      cf:	61 6c 61 72 6d 20 6f 6e 21 00                       alarm on!.

000000d9 <__c.2897>:
      d9:	61 6c 61 72 6d 20 6f 66 66 00                       alarm off.

000000e3 <__c.2819>:
      e3:	43 68 72 6f 6e 6f 44 6f 74 20 63 68 65 63 6b 20     ChronoDot check 
      f3:	66 61 69 6c 65 64 21 00                             failed!.

000000fb <__c.2575>:
      fb:	53 65 74 20 64 61 79 00                             Set day.

00000103 <__c.2500>:
     103:	43 68 72 6f 6e 6f 44 6f 74 20 73 65 74 21 00        ChronoDot set!.

00000112 <__c.2349>:
     112:	64 6f 6e 65 00                                      done.

00000117 <__c.2347>:
     117:	61 6c 61 72 6d 20 69 6e 69 74 00                    alarm init.

00000122 <__c.2345>:
     122:	63 6c 6f 63 6b 20 69 6e 69 74 00                    clock init.

0000012d <__c.2343>:
     12d:	73 70 65 61 6b 65 72 20 69 6e 69 74 00              speaker init.

0000013a <__c.2341>:
     13a:	62 6f 6f 73 74 20 69 6e 69 74 00                    boost init.

00000145 <__c.2339>:
     145:	76 66 64 20 69 6e 69 74 00                          vfd init.

0000014e <__c.2337>:
     14e:	74 75 72 6e 69 6e 67 20 6f 6e 20 61 6c 61 72 6d     turning on alarm
     15e:	73 77 00                                            sw.

00000161 <__c.2335>:
     161:	74 75 72 6e 69 6e 67 20 6f 6e 20 62 75 74 74 6f     turning on butto
     171:	6e 73 00                                            ns.

00000174 <__c.2333>:
     174:	21 00                                               !.

00000176 <__c.2301>:
     176:	77 61 6b 65 74 69 6d 65 00                          waketime.

0000017f <__c.2219>:
     17f:	57 41 4b 45 52 45 53 45 54 00                       WAKERESET.

00000189 <__c.2217>:
     189:	7a 00                                               z.

0000018b <__c.2140>:
     18b:	62 32 00                                            b2.

0000018e <__c.2088>:
     18e:	62 33 00                                            b3.

00000191 <__c.2086>:
     191:	62 31 00                                            b1.

00000194 <__c.2037>:
     194:	73 6e 6f 6f 7a 65 00 00                             snooze..

0000019c <__ctors_end>:
     19c:	11 24       	eor	r1, r1
     19e:	1f be       	out	0x3f, r1	; 63
     1a0:	cf ef       	ldi	r28, 0xFF	; 255
     1a2:	d4 e0       	ldi	r29, 0x04	; 4
     1a4:	de bf       	out	0x3e, r29	; 62
     1a6:	cd bf       	out	0x3d, r28	; 61

000001a8 <__do_copy_data>:
     1a8:	12 e0       	ldi	r17, 0x02	; 2
     1aa:	a0 e0       	ldi	r26, 0x00	; 0
     1ac:	b1 e0       	ldi	r27, 0x01	; 1
     1ae:	e2 ea       	ldi	r30, 0xA2	; 162
     1b0:	f7 e3       	ldi	r31, 0x37	; 55
     1b2:	02 c0       	rjmp	.+4      	; 0x1b8 <.do_copy_data_start>

000001b4 <.do_copy_data_loop>:
     1b4:	05 90       	lpm	r0, Z+
     1b6:	0d 92       	st	X+, r0

000001b8 <.do_copy_data_start>:
     1b8:	a6 33       	cpi	r26, 0x36	; 54
     1ba:	b1 07       	cpc	r27, r17
     1bc:	d9 f7       	brne	.-10     	; 0x1b4 <.do_copy_data_loop>

000001be <__do_clear_bss>:
     1be:	12 e0       	ldi	r17, 0x02	; 2
     1c0:	a6 e3       	ldi	r26, 0x36	; 54
     1c2:	b2 e0       	ldi	r27, 0x02	; 2
     1c4:	01 c0       	rjmp	.+2      	; 0x1c8 <.do_clear_bss_start>

000001c6 <.do_clear_bss_loop>:
     1c6:	1d 92       	st	X+, r1

000001c8 <.do_clear_bss_start>:
     1c8:	a7 3e       	cpi	r26, 0xE7	; 231
     1ca:	b1 07       	cpc	r27, r17
     1cc:	e1 f7       	brne	.-8      	; 0x1c6 <.do_clear_bss_loop>
     1ce:	0e 94 6f 15 	call	0x2ade	; 0x2ade <main>
     1d2:	0c 94 cf 1b 	jmp	0x379e	; 0x379e <_exit>

000001d6 <__bad_interrupt>:
     1d6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001da <twiInit>:
}

void twiInit (void)
{
	/* SCL freq = CPU clock/(16+2*TWBR*4^TWPS) */
	TWSR = 0x00;		/* prescale CPU/1 (Note: for status comparisons to work, must be =0) */
     1da:	10 92 b9 00 	sts	0x00B9, r1
	
	/* Min TWBR is 10 */
	//TWBR = 0xff;		/* 15.2khz for debugging */
	TWBR = 32;			/* 100khz */
     1de:	80 e2       	ldi	r24, 0x20	; 32
     1e0:	80 93 b8 00 	sts	0x00B8, r24
}
     1e4:	08 95       	ret

000001e6 <delayms>:
uint16_t snoozetimer = 0;

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
     1e6:	9c 01       	movw	r18, r24
	sei();
     1e8:	78 94       	sei

	milliseconds = 0;
     1ea:	10 92 46 02 	sts	0x0246, r1
     1ee:	10 92 45 02 	sts	0x0245, r1
	while (milliseconds < ms);
     1f2:	80 91 45 02 	lds	r24, 0x0245
     1f6:	90 91 46 02 	lds	r25, 0x0246
     1fa:	82 17       	cp	r24, r18
     1fc:	93 07       	cpc	r25, r19
     1fe:	c8 f3       	brcs	.-14     	; 0x1f2 <delayms+0xc>
}
     200:	08 95       	ret

00000202 <kickthedog>:
	displaymode = SHOW_TIME;
}

// we reset the watchdog timer 
void kickthedog(void) {
	wdt_reset();
     202:	a8 95       	wdr
}
     204:	08 95       	ret

00000206 <gotosleep>:
	// battery
	//if (sleepmode) //already asleep?
	//  return;
	//DEBUGP("sleeptime");

	sleepmode = 1;
     206:	81 e0       	ldi	r24, 0x01	; 1
     208:	80 93 39 02 	sts	0x0239, r24
	VFDSWITCH_PORT |= _BV(VFDSWITCH); // turn off display
     20c:	5b 9a       	sbi	0x0b, 3	; 11
	SPCR  &= ~_BV(SPE); // turn off spi
     20e:	8c b5       	in	r24, 0x2c	; 44
     210:	8f 7b       	andi	r24, 0xBF	; 191
     212:	8c bd       	out	0x2c, r24	; 44
	VFDCLK_PORT &= ~_BV(VFDCLK) & ~_BV(VFDDATA); // no power to vfdchip
     214:	85 b1       	in	r24, 0x05	; 5
     216:	87 7d       	andi	r24, 0xD7	; 215
     218:	85 b9       	out	0x05, r24	; 5
	BOOST_PORT &= ~_BV(BOOST); // pull boost fet low
     21a:	5e 98       	cbi	0x0b, 6	; 11
	TCCR0B = 0; // no boost
     21c:	15 bc       	out	0x25, r1	; 37
	volume = 0; // low power buzzer
     21e:	10 92 d3 02 	sts	0x02D3, r1
	PCICR = 0;  // ignore buttons
     222:	10 92 68 00 	sts	0x0068, r1
#ifdef FEATURE_AUTODIM
	DIMMER_POWER_PORT &= ~_BV(DIMMER_POWER_PIN); // no power to photoresistor
     226:	45 98       	cbi	0x08, 5	; 8
	// sleep time!
	//beep(3520, 1);
	//beep(1760, 1);
	//beep(880, 1);
	// turn beeper off
	PORTB &= ~_BV(SPK1) & ~_BV(SPK2); 
     228:	85 b1       	in	r24, 0x05	; 5
     22a:	89 7f       	andi	r24, 0xF9	; 249
     22c:	85 b9       	out	0x05, r24	; 5

	// turn off pullups
	PORTD &= ~_BV(BUTTON1) & ~_BV(BUTTON3);
     22e:	8b b1       	in	r24, 0x0b	; 11
     230:	8f 7c       	andi	r24, 0xCF	; 207
     232:	8b b9       	out	0x0b, r24	; 11
	PORTB &= ~_BV(BUTTON2);
     234:	28 98       	cbi	0x05, 0	; 5
	DDRD &= ~_BV(BUTTON1) & ~_BV(BUTTON3);
     236:	8a b1       	in	r24, 0x0a	; 10
     238:	8f 7c       	andi	r24, 0xCF	; 207
     23a:	8a b9       	out	0x0a, r24	; 10
	DDRB &= ~_BV(BUTTON2);
     23c:	20 98       	cbi	0x04, 0	; 4
	ALARM_PORT &= ~_BV(ALARM);
     23e:	5a 98       	cbi	0x0b, 2	; 11
	ALARM_DDR &= ~_BV(ALARM);
     240:	52 98       	cbi	0x0a, 2	; 10


	// reduce the clock speed
	CLKPR = _BV(CLKPCE);
     242:	e1 e6       	ldi	r30, 0x61	; 97
     244:	f0 e0       	ldi	r31, 0x00	; 0
     246:	90 e8       	ldi	r25, 0x80	; 128
     248:	90 83       	st	Z, r25
	CLKPR = _BV(CLKPS3);
     24a:	88 e0       	ldi	r24, 0x08	; 8
     24c:	80 83       	st	Z, r24

	//  PPR |= _BV(PRUSART0) | _BV(PRADC) | _BV(PRSPI) | _BV(PRTIM1) | _BV(PRTIM0) | _BV(PRTWI);
	PORTC |= _BV(4);  // sleep signal
     24e:	44 9a       	sbi	0x08, 4	; 8
	SMCR |= _BV(SM1) | _BV(SM0) | _BV(SE); // sleep mode
     250:	83 b7       	in	r24, 0x33	; 51
     252:	87 60       	ori	r24, 0x07	; 7
     254:	83 bf       	out	0x33, r24	; 51
	asm("sleep"); 
     256:	88 95       	sleep
	CLKPR = _BV(CLKPCE);
     258:	90 83       	st	Z, r25
	CLKPR = 0;
     25a:	10 82       	st	Z, r1
	PORTC &= ~_BV(4);
     25c:	44 98       	cbi	0x08, 4	; 8
}
     25e:	08 95       	ret

00000260 <initbuttons>:
	kickthedog();
}


void initbuttons(void) {
	DDRB =  _BV(VFDCLK) | _BV(VFDDATA) | _BV(SPK1) | _BV(SPK2);
     260:	8e e2       	ldi	r24, 0x2E	; 46
     262:	84 b9       	out	0x04, r24	; 4
	DDRD = _BV(BOOST) | _BV(VFDSWITCH);
     264:	88 e4       	ldi	r24, 0x48	; 72
     266:	8a b9       	out	0x0a, r24	; 10
	DDRC = _BV(VFDLOAD) | _BV(VFDBLANK);
     268:	89 e0       	ldi	r24, 0x09	; 9
     26a:	87 b9       	out	0x07, r24	; 7
	PORTD = _BV(BUTTON1) | _BV(BUTTON3) | _BV(ALARM);
     26c:	84 e3       	ldi	r24, 0x34	; 52
     26e:	8b b9       	out	0x0b, r24	; 11
	PORTB = _BV(BUTTON2);
     270:	91 e0       	ldi	r25, 0x01	; 1
     272:	95 b9       	out	0x05, r25	; 5

	PCICR = _BV(PCIE0) | _BV(PCIE2);
     274:	85 e0       	ldi	r24, 0x05	; 5
     276:	80 93 68 00 	sts	0x0068, r24
	PCMSK0 = _BV(PCINT0);
     27a:	90 93 6b 00 	sts	0x006B, r25
	PCMSK2 = _BV(PCINT21) | _BV(PCINT20);    
     27e:	80 e3       	ldi	r24, 0x30	; 48
     280:	80 93 6d 00 	sts	0x006D, r24
}
     284:	08 95       	ret

00000286 <b2bcd>:
				delayms(75);
		}
	}
}

uint8_t b2bcd (uint8_t b) {
     286:	48 2f       	mov	r20, r24
     288:	6a e0       	ldi	r22, 0x0A	; 10
     28a:	0e 94 1b 1b 	call	0x3636	; 0x3636 <__udivmodqi4>
     28e:	28 2f       	mov	r18, r24
     290:	30 e0       	ldi	r19, 0x00	; 0
     292:	84 e0       	ldi	r24, 0x04	; 4
     294:	22 0f       	add	r18, r18
     296:	33 1f       	adc	r19, r19
     298:	8a 95       	dec	r24
     29a:	e1 f7       	brne	.-8      	; 0x294 <b2bcd+0xe>
     29c:	84 2f       	mov	r24, r20
     29e:	0e 94 1b 1b 	call	0x3636	; 0x3636 <__udivmodqi4>
	return ((b / 10) << 4) | (b % 10);
}
     2a2:	89 2f       	mov	r24, r25
     2a4:	82 2b       	or	r24, r18
     2a6:	08 95       	ret

000002a8 <bcd2b>:

uint8_t bcd2b (uint8_t bcd) {
     2a8:	28 2f       	mov	r18, r24
     2aa:	22 95       	swap	r18
     2ac:	2f 70       	andi	r18, 0x0F	; 15
     2ae:	9a e0       	ldi	r25, 0x0A	; 10
     2b0:	29 9f       	mul	r18, r25
     2b2:	90 01       	movw	r18, r0
     2b4:	11 24       	eor	r1, r1
     2b6:	8f 70       	andi	r24, 0x0F	; 15
	return (bcd & 0x0f) + (bcd >> 4) * 10;
}
     2b8:	82 0f       	add	r24, r18
     2ba:	08 95       	ret

000002bc <display_brightness>:
			}
		}
	}
}

void display_brightness(int brightness) {
     2bc:	9c 01       	movw	r18, r24
#ifdef FEATURE_AUTODIM
	if (brightness == 0) {
     2be:	00 97       	sbiw	r24, 0x00	; 0
     2c0:	a9 f4       	brne	.+42     	; 0x2ec <display_brightness+0x30>
		// auto-dim
		display[7] =  pgm_read_byte(alphatable_p + 'a' - 'a') | 0x1;
     2c2:	e8 e6       	ldi	r30, 0x68	; 104
     2c4:	f0 e0       	ldi	r31, 0x00	; 0
     2c6:	84 91       	lpm	r24, Z+
     2c8:	81 60       	ori	r24, 0x01	; 1
     2ca:	80 93 dc 02 	sts	0x02DC, r24
		display[8] =  pgm_read_byte(alphatable_p + 'u' - 'a') | 0x1;
     2ce:	74 96       	adiw	r30, 0x14	; 20
     2d0:	e4 91       	lpm	r30, Z+
     2d2:	e1 60       	ori	r30, 0x01	; 1
     2d4:	e0 93 dd 02 	sts	0x02DD, r30
	ADCSRA |= _BV(ADIE);  // Enable ADC interrupt
}

// Start ADC conversion for dimmer
void dimmer_update(void) {
	if (brightness_level == 0) 
     2d8:	80 91 e1 02 	lds	r24, 0x02E1
     2dc:	88 23       	and	r24, r24
     2de:	41 f5       	brne	.+80     	; 0x330 <display_brightness+0x74>
		ADCSRA |= _BV(ADSC);
     2e0:	80 91 7a 00 	lds	r24, 0x007A
     2e4:	80 64       	ori	r24, 0x40	; 64
     2e6:	80 93 7a 00 	sts	0x007A, r24
     2ea:	08 95       	ret
		display[8] =  pgm_read_byte(alphatable_p + 'u' - 'a') | 0x1;
		dimmer_update();
		return;
	}
#endif
	display[7] = pgm_read_byte(numbertable_p + (brightness / 10)) | 0x1;
     2ec:	6a e0       	ldi	r22, 0x0A	; 10
     2ee:	70 e0       	ldi	r23, 0x00	; 0
     2f0:	0e 94 48 1b 	call	0x3690	; 0x3690 <__divmodhi4>
     2f4:	fb 01       	movw	r30, r22
     2f6:	ec 57       	subi	r30, 0x7C	; 124
     2f8:	ff 4f       	sbci	r31, 0xFF	; 255
     2fa:	e4 91       	lpm	r30, Z+
     2fc:	e1 60       	ori	r30, 0x01	; 1
     2fe:	e0 93 dc 02 	sts	0x02DC, r30
	display[8] = pgm_read_byte(numbertable_p + (brightness % 10)) | 0x1;
     302:	c9 01       	movw	r24, r18
     304:	6a e0       	ldi	r22, 0x0A	; 10
     306:	70 e0       	ldi	r23, 0x00	; 0
     308:	0e 94 48 1b 	call	0x3690	; 0x3690 <__divmodhi4>
     30c:	fc 01       	movw	r30, r24
     30e:	ec 57       	subi	r30, 0x7C	; 124
     310:	ff 4f       	sbci	r31, 0xFF	; 255
     312:	e4 91       	lpm	r30, Z+
     314:	e1 60       	ori	r30, 0x01	; 1
     316:	e0 93 dd 02 	sts	0x02DD, r30
	set_vfd_brightness(brightness);
     31a:	92 2f       	mov	r25, r18
}

void set_vfd_brightness(uint8_t brightness) {
	// Set PWM value, don't set it so high that
	// we could damage the MAX chip or display
	if (brightness > BRIGHTNESS_MAX)
     31c:	2b 35       	cpi	r18, 0x5B	; 91
     31e:	10 f0       	brcs	.+4      	; 0x324 <display_brightness+0x68>
     320:	9a e5       	ldi	r25, 0x5A	; 90
     322:	03 c0       	rjmp	.+6      	; 0x32a <display_brightness+0x6e>
		brightness = BRIGHTNESS_MAX;

	// Or so low its not visible
	if (brightness < BRIGHTNESS_MIN)
     324:	2e 31       	cpi	r18, 0x1E	; 30
     326:	08 f4       	brcc	.+2      	; 0x32a <display_brightness+0x6e>
     328:	9e e1       	ldi	r25, 0x1E	; 30
	//// Round up to the next brightness increment
	//if (brightness % BRIGHTNESS_INCREMENT != 0) {
	//  brightness += BRIGHTNESS_INCREMENT - (brightness % BRIGHTNESS_INCREMENT);
	//}

	if (OCR0A == brightness)
     32a:	87 b5       	in	r24, 0x27	; 39
     32c:	89 13       	cpse	r24, r25
		return;

	OCR0A = brightness;
     32e:	97 bd       	out	0x27, r25	; 39
     330:	08 95       	ret

00000332 <rtc_init>:
}

// Turn on the RTC by selecting the external 32khz crystal
void rtc_init (void) {
	// 32.768 / 128 = 256 which is exactly an 8-bit timer overflow
	ASSR |= _BV(EXCLK);		// External clock (comment out if using xtal)
     332:	e6 eb       	ldi	r30, 0xB6	; 182
     334:	f0 e0       	ldi	r31, 0x00	; 0
     336:	80 81       	ld	r24, Z
     338:	80 64       	ori	r24, 0x40	; 64
     33a:	80 83       	st	Z, r24
	ASSR |= _BV(AS2); // use crystal
     33c:	80 81       	ld	r24, Z
     33e:	80 62       	ori	r24, 0x20	; 32
     340:	80 83       	st	Z, r24
	TCCR2A = 0;
     342:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = _BV(CS22) | _BV(CS20); // div by 128
     346:	85 e0       	ldi	r24, 0x05	; 5
     348:	80 93 b1 00 	sts	0x00B1, r24
	// We will overflow once a second, and call an interrupt

	CLKPR = _BV(CLKPCE);	// CPU clock division factor to 1
     34c:	e1 e6       	ldi	r30, 0x61	; 97
     34e:	f0 e0       	ldi	r31, 0x00	; 0
     350:	80 e8       	ldi	r24, 0x80	; 128
     352:	80 83       	st	Z, r24
	CLKPR = 0;
     354:	10 82       	st	Z, r1

	// enable interrupt on overflow
	TIMSK2 = _BV(TOIE2);
     356:	81 e0       	ldi	r24, 0x01	; 1
     358:	80 93 70 00 	sts	0x0070, r24
}
     35c:	08 95       	ret

0000035e <alarm_init>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     35e:	f9 99       	sbic	0x1f, 1	; 31
     360:	fe cf       	rjmp	.-4      	; 0x35e <alarm_init>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
     362:	88 e0       	ldi	r24, 0x08	; 8
     364:	90 e0       	ldi	r25, 0x00	; 0
     366:	92 bd       	out	0x22, r25	; 34
     368:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     36a:	f8 9a       	sbi	0x1f, 0	; 31
     36c:	80 b5       	in	r24, 0x20	; 32

// Set up the stored alarm time and date
void alarm_init (void) {
	alarm_m = eeprom_read_byte((uint8_t *)EE_ALARM_MIN) % 60;
     36e:	6c e3       	ldi	r22, 0x3C	; 60
     370:	0e 94 1b 1b 	call	0x3636	; 0x3636 <__udivmodqi4>
     374:	90 93 d2 02 	sts	0x02D2, r25
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     378:	f9 99       	sbic	0x1f, 1	; 31
     37a:	fe cf       	rjmp	.-4      	; 0x378 <alarm_init+0x1a>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
     37c:	87 e0       	ldi	r24, 0x07	; 7
     37e:	90 e0       	ldi	r25, 0x00	; 0
     380:	92 bd       	out	0x22, r25	; 34
     382:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     384:	f8 9a       	sbi	0x1f, 0	; 31
     386:	80 b5       	in	r24, 0x20	; 32
	alarm_h = eeprom_read_byte((uint8_t *)EE_ALARM_HOUR) % 24;
     388:	68 e1       	ldi	r22, 0x18	; 24
     38a:	0e 94 1b 1b 	call	0x3636	; 0x3636 <__udivmodqi4>
     38e:	90 93 e0 02 	sts	0x02E0, r25
}
     392:	08 95       	ret

00000394 <dow>:

char dow_tbl[] PROGMEM = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};

// Calculate day of the week by Sakamoto's method, 0=Sunday
uint8_t dow (uint8_t y, uint8_t m, uint8_t d)
{
     394:	1f 93       	push	r17
     396:	cf 93       	push	r28
     398:	df 93       	push	r29
	uint16_t yy;		

	yy = y + 2000 - (m < 3);
     39a:	90 e0       	ldi	r25, 0x00	; 0
     39c:	80 53       	subi	r24, 0x30	; 48
     39e:	98 4f       	sbci	r25, 0xF8	; 248
     3a0:	20 e0       	ldi	r18, 0x00	; 0
     3a2:	30 e0       	ldi	r19, 0x00	; 0
     3a4:	63 30       	cpi	r22, 0x03	; 3
     3a6:	10 f4       	brcc	.+4      	; 0x3ac <dow+0x18>
     3a8:	21 e0       	ldi	r18, 0x01	; 1
     3aa:	30 e0       	ldi	r19, 0x00	; 0
     3ac:	ec 01       	movw	r28, r24
     3ae:	c2 1b       	sub	r28, r18
     3b0:	d3 0b       	sbc	r29, r19
	return (yy + yy/4 - yy/100 + yy/400 + pgm_read_byte(dow_tbl + m-1) + d) % 7;
     3b2:	86 2f       	mov	r24, r22
     3b4:	90 e0       	ldi	r25, 0x00	; 0
     3b6:	8c 54       	subi	r24, 0x4C	; 76
     3b8:	9f 4f       	sbci	r25, 0xFF	; 255
     3ba:	fc 01       	movw	r30, r24
     3bc:	14 91       	lpm	r17, Z+
     3be:	9e 01       	movw	r18, r28
     3c0:	24 0f       	add	r18, r20
     3c2:	31 1d       	adc	r19, r1
     3c4:	ce 01       	movw	r24, r28
     3c6:	96 95       	lsr	r25
     3c8:	87 95       	ror	r24
     3ca:	96 95       	lsr	r25
     3cc:	87 95       	ror	r24
     3ce:	28 0f       	add	r18, r24
     3d0:	39 1f       	adc	r19, r25
     3d2:	ce 01       	movw	r24, r28
     3d4:	60 e9       	ldi	r22, 0x90	; 144
     3d6:	71 e0       	ldi	r23, 0x01	; 1
     3d8:	0e 94 34 1b 	call	0x3668	; 0x3668 <__udivmodhi4>
     3dc:	26 0f       	add	r18, r22
     3de:	37 1f       	adc	r19, r23
     3e0:	ce 01       	movw	r24, r28
     3e2:	64 e6       	ldi	r22, 0x64	; 100
     3e4:	70 e0       	ldi	r23, 0x00	; 0
     3e6:	0e 94 34 1b 	call	0x3668	; 0x3668 <__udivmodhi4>
     3ea:	26 1b       	sub	r18, r22
     3ec:	37 0b       	sbc	r19, r23
     3ee:	c9 01       	movw	r24, r18
     3f0:	81 0f       	add	r24, r17
     3f2:	91 1d       	adc	r25, r1
     3f4:	67 e0       	ldi	r22, 0x07	; 7
     3f6:	70 e0       	ldi	r23, 0x00	; 0
     3f8:	0e 94 34 1b 	call	0x3668	; 0x3668 <__udivmodhi4>
}
     3fc:	df 91       	pop	r29
     3fe:	cf 91       	pop	r28
     400:	1f 91       	pop	r17
     402:	08 95       	ret

00000404 <leapyear>:

// This will calculate leap years, give it the year
// and it will return 1 (true) or 0 (false)
uint8_t leapyear(uint16_t y) 
{
     404:	fc 01       	movw	r30, r24
	return ( (!(y % 4) && (y % 100)) || !(y % 400));
     406:	83 70       	andi	r24, 0x03	; 3
     408:	90 70       	andi	r25, 0x00	; 0
     40a:	89 2b       	or	r24, r25
     40c:	39 f4       	brne	.+14     	; 0x41c <leapyear+0x18>
     40e:	cf 01       	movw	r24, r30
     410:	64 e6       	ldi	r22, 0x64	; 100
     412:	70 e0       	ldi	r23, 0x00	; 0
     414:	0e 94 34 1b 	call	0x3668	; 0x3668 <__udivmodhi4>
     418:	89 2b       	or	r24, r25
     41a:	49 f4       	brne	.+18     	; 0x42e <leapyear+0x2a>
     41c:	20 e0       	ldi	r18, 0x00	; 0
     41e:	30 e0       	ldi	r19, 0x00	; 0
     420:	cf 01       	movw	r24, r30
     422:	60 e9       	ldi	r22, 0x90	; 144
     424:	71 e0       	ldi	r23, 0x01	; 1
     426:	0e 94 34 1b 	call	0x3668	; 0x3668 <__udivmodhi4>
     42a:	89 2b       	or	r24, r25
     42c:	11 f4       	brne	.+4      	; 0x432 <leapyear+0x2e>
     42e:	21 e0       	ldi	r18, 0x01	; 1
     430:	30 e0       	ldi	r19, 0x00	; 0
}
     432:	82 2f       	mov	r24, r18
     434:	08 95       	ret

00000436 <monthlen>:

const char mon_tbl[] PROGMEM = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
PGM_P mon_tbl_p PROGMEM = mon_tbl;

uint8_t monthlen(uint8_t y, uint8_t m)
{
     436:	1f 93       	push	r17
     438:	16 2f       	mov	r17, r22
	uint8_t ml;
	if (m == 2 && leapyear(y+2000))
     43a:	62 30       	cpi	r22, 0x02	; 2
     43c:	49 f4       	brne	.+18     	; 0x450 <monthlen+0x1a>
     43e:	90 e0       	ldi	r25, 0x00	; 0
     440:	80 53       	subi	r24, 0x30	; 48
     442:	98 4f       	sbci	r25, 0xF8	; 248
     444:	0e 94 02 02 	call	0x404	; 0x404 <leapyear>
     448:	88 23       	and	r24, r24
     44a:	11 f0       	breq	.+4      	; 0x450 <monthlen+0x1a>
     44c:	8d e1       	ldi	r24, 0x1D	; 29
     44e:	05 c0       	rjmp	.+10     	; 0x45a <monthlen+0x24>
		ml = 29;
	else
		ml = pgm_read_byte(mon_tbl_p + (m-1));
     450:	e1 2f       	mov	r30, r17
     452:	f0 e0       	ldi	r31, 0x00	; 0
     454:	e0 54       	subi	r30, 0x40	; 64
     456:	ff 4f       	sbci	r31, 0xFF	; 255
     458:	84 91       	lpm	r24, Z+
	return ml;
}
     45a:	1f 91       	pop	r17
     45c:	08 95       	ret

0000045e <dst>:
#define November 11

// Returns 1 if specified point in time is subject to
// daylight savings' time, 0 otherwise.
uint8_t dst (uint8_t y, uint8_t m, uint8_t d, uint8_t h)
{
     45e:	0f 93       	push	r16
     460:	1f 93       	push	r17
     462:	38 2f       	mov	r19, r24
     464:	14 2f       	mov	r17, r20
     466:	02 2f       	mov	r16, r18
	uint8_t day;
	
	if (!flag(f_dst_enable)) return 0;
     468:	80 91 e6 02 	lds	r24, 0x02E6
     46c:	82 ff       	sbrs	r24, 2
     46e:	41 c0       	rjmp	.+130    	; 0x4f2 <dst+0x94>
	
	if (region == REGION_US) {
     470:	80 91 38 02 	lds	r24, 0x0238
     474:	96 2f       	mov	r25, r22
     476:	94 50       	subi	r25, 0x04	; 4
     478:	88 23       	and	r24, r24
     47a:	91 f4       	brne	.+36     	; 0x4a0 <dst+0x42>
		if (March < m && m < November)
     47c:	97 30       	cpi	r25, 0x07	; 7
     47e:	d8 f1       	brcs	.+118    	; 0x4f6 <dst+0x98>
			return 1;
		else if (m == March) {
     480:	63 30       	cpi	r22, 0x03	; 3
     482:	31 f4       	brne	.+12     	; 0x490 <dst+0x32>
			day = 14 - dow (y, March, 14);	// 2nd Sunday
     484:	83 2f       	mov	r24, r19
     486:	4e e0       	ldi	r20, 0x0E	; 14
     488:	0e 94 ca 01 	call	0x394	; 0x394 <dow>
     48c:	9e e0       	ldi	r25, 0x0E	; 14
     48e:	11 c0       	rjmp	.+34     	; 0x4b2 <dst+0x54>
			return (d > day) || ((d == day) && (h > 1));
		} else if (m == November) {
     490:	6b 30       	cpi	r22, 0x0B	; 11
     492:	79 f5       	brne	.+94     	; 0x4f2 <dst+0x94>
			day = 7 - dow (y, November, 7);	// 1st Sunday
     494:	83 2f       	mov	r24, r19
     496:	47 e0       	ldi	r20, 0x07	; 7
     498:	0e 94 ca 01 	call	0x394	; 0x394 <dow>
     49c:	97 e0       	ldi	r25, 0x07	; 7
     49e:	1a c0       	rjmp	.+52     	; 0x4d4 <dst+0x76>
			return (d < day) || ((d == day) && (h < 1));
		} else
			return 0;
	} else {
		// European transition hour may be off, depending on timezone and country
		if (March < m && m < October)
     4a0:	96 30       	cpi	r25, 0x06	; 6
     4a2:	48 f1       	brcs	.+82     	; 0x4f6 <dst+0x98>
			return 1;
		else if (m == March) {
     4a4:	63 30       	cpi	r22, 0x03	; 3
     4a6:	79 f4       	brne	.+30     	; 0x4c6 <dst+0x68>
			day = 31 - dow (y, March, 31);	// last Sunday
     4a8:	83 2f       	mov	r24, r19
     4aa:	4f e1       	ldi	r20, 0x1F	; 31
     4ac:	0e 94 ca 01 	call	0x394	; 0x394 <dow>
     4b0:	9f e1       	ldi	r25, 0x1F	; 31
     4b2:	98 1b       	sub	r25, r24
			return (d > day) || ((d == day) && (h > 1));
     4b4:	91 17       	cp	r25, r17
     4b6:	d0 f0       	brcs	.+52     	; 0x4ec <dst+0x8e>
     4b8:	19 17       	cp	r17, r25
     4ba:	89 f4       	brne	.+34     	; 0x4de <dst+0x80>
     4bc:	80 e0       	ldi	r24, 0x00	; 0
     4be:	90 e0       	ldi	r25, 0x00	; 0
     4c0:	02 30       	cpi	r16, 0x02	; 2
     4c2:	d0 f0       	brcs	.+52     	; 0x4f8 <dst+0x9a>
     4c4:	13 c0       	rjmp	.+38     	; 0x4ec <dst+0x8e>
		} else if (m == October) {
     4c6:	6a 30       	cpi	r22, 0x0A	; 10
     4c8:	a1 f4       	brne	.+40     	; 0x4f2 <dst+0x94>
			day = 31 - dow (y, October, 31);	// last Sunday
     4ca:	83 2f       	mov	r24, r19
     4cc:	4f e1       	ldi	r20, 0x1F	; 31
     4ce:	0e 94 ca 01 	call	0x394	; 0x394 <dow>
     4d2:	9f e1       	ldi	r25, 0x1F	; 31
     4d4:	98 1b       	sub	r25, r24
			return (d < day) || ((d == day) && (h < 1));
     4d6:	19 17       	cp	r17, r25
     4d8:	48 f0       	brcs	.+18     	; 0x4ec <dst+0x8e>
     4da:	19 17       	cp	r17, r25
     4dc:	19 f0       	breq	.+6      	; 0x4e4 <dst+0x86>
     4de:	80 e0       	ldi	r24, 0x00	; 0
     4e0:	90 e0       	ldi	r25, 0x00	; 0
     4e2:	0a c0       	rjmp	.+20     	; 0x4f8 <dst+0x9a>
     4e4:	80 e0       	ldi	r24, 0x00	; 0
     4e6:	90 e0       	ldi	r25, 0x00	; 0
     4e8:	00 23       	and	r16, r16
     4ea:	31 f4       	brne	.+12     	; 0x4f8 <dst+0x9a>
     4ec:	81 e0       	ldi	r24, 0x01	; 1
     4ee:	90 e0       	ldi	r25, 0x00	; 0
     4f0:	03 c0       	rjmp	.+6      	; 0x4f8 <dst+0x9a>
     4f2:	80 e0       	ldi	r24, 0x00	; 0
     4f4:	01 c0       	rjmp	.+2      	; 0x4f8 <dst+0x9a>
     4f6:	81 e0       	ldi	r24, 0x01	; 1
		} else
			return 0;		
	}
}
     4f8:	1f 91       	pop	r17
     4fa:	0f 91       	pop	r16
     4fc:	08 95       	ret

000004fe <speaker_init>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     4fe:	f9 99       	sbic	0x1f, 1	; 31
     500:	fe cf       	rjmp	.-4      	; 0x4fe <speaker_init>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
     502:	8a e0       	ldi	r24, 0x0A	; 10
     504:	90 e0       	ldi	r25, 0x00	; 0
     506:	92 bd       	out	0x22, r25	; 34
     508:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     50a:	f8 9a       	sbi	0x1f, 0	; 31
     50c:	80 b5       	in	r24, 0x20	; 32
/**************************** SPEAKER *****************************/
// Set up the speaker to prepare for beeping!
void speaker_init(void) {

	// read the preferences for high/low volume
	volume = eeprom_read_byte((uint8_t *)EE_VOLUME);
     50e:	80 93 d3 02 	sts	0x02D3, r24

	// We use the built-in fast PWM, 8 bit timer
	PORTB |= _BV(SPK1) | _BV(SPK2); 
     512:	85 b1       	in	r24, 0x05	; 5
     514:	86 60       	ori	r24, 0x06	; 6
     516:	85 b9       	out	0x05, r24	; 5

	// Turn on PWM outputs for both pins
	TCCR1A = _BV(COM1B1) | _BV(COM1B0) | _BV(WGM11);
     518:	82 e3       	ldi	r24, 0x32	; 50
     51a:	80 93 80 00 	sts	0x0080, r24
	if (volume) {
     51e:	80 91 d3 02 	lds	r24, 0x02D3
     522:	88 23       	and	r24, r24
     524:	29 f0       	breq	.+10     	; 0x530 <__stack+0x31>
		TCCR1A |= _BV(COM1A1);
     526:	80 91 80 00 	lds	r24, 0x0080
     52a:	80 68       	ori	r24, 0x80	; 128
     52c:	80 93 80 00 	sts	0x0080, r24
	} 
	TCCR1B = _BV(WGM13) | _BV(WGM12);
     530:	88 e1       	ldi	r24, 0x18	; 24
     532:	80 93 81 00 	sts	0x0081, r24

	// start at 4khz:  250 * 8 multiplier * 4000 = 8mhz
	ICR1 = 250;
     536:	8a ef       	ldi	r24, 0xFA	; 250
     538:	90 e0       	ldi	r25, 0x00	; 0
     53a:	90 93 87 00 	sts	0x0087, r25
     53e:	80 93 86 00 	sts	0x0086, r24
	OCR1B = OCR1A = ICR1 / 2;
     542:	80 91 86 00 	lds	r24, 0x0086
     546:	90 91 87 00 	lds	r25, 0x0087
     54a:	96 95       	lsr	r25
     54c:	87 95       	ror	r24
     54e:	90 93 89 00 	sts	0x0089, r25
     552:	80 93 88 00 	sts	0x0088, r24
     556:	80 91 88 00 	lds	r24, 0x0088
     55a:	90 91 89 00 	lds	r25, 0x0089
     55e:	90 93 8b 00 	sts	0x008B, r25
     562:	80 93 8a 00 	sts	0x008A, r24
}
     566:	08 95       	ret

00000568 <tick>:

// This makes the speaker tick, it doesnt use PWM
// instead it just flicks the piezo
void tick(void) {
	TCCR1A = 0;
     568:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;
     56c:	10 92 81 00 	sts	0x0081, r1

	// Send a pulse thru both pins, alternating
	SPK_PORT |= _BV(SPK1);
     570:	29 9a       	sbi	0x05, 1	; 5
	SPK_PORT &= ~_BV(SPK2);
     572:	2a 98       	cbi	0x05, 2	; 5

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
     574:	78 94       	sei

	milliseconds = 0;
     576:	10 92 46 02 	sts	0x0246, r1
     57a:	10 92 45 02 	sts	0x0245, r1
	while (milliseconds < ms);
     57e:	80 91 45 02 	lds	r24, 0x0245
     582:	90 91 46 02 	lds	r25, 0x0246
     586:	0a 97       	sbiw	r24, 0x0a	; 10
     588:	d0 f3       	brcs	.-12     	; 0x57e <tick+0x16>

	// Send a pulse thru both pins, alternating
	SPK_PORT |= _BV(SPK1);
	SPK_PORT &= ~_BV(SPK2);
	delayms(10);
	SPK_PORT |= _BV(SPK2);
     58a:	2a 9a       	sbi	0x05, 2	; 5
	SPK_PORT &= ~_BV(SPK1);
     58c:	29 98       	cbi	0x05, 1	; 5

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
     58e:	78 94       	sei

	milliseconds = 0;
     590:	10 92 46 02 	sts	0x0246, r1
     594:	10 92 45 02 	sts	0x0245, r1
	while (milliseconds < ms);
     598:	80 91 45 02 	lds	r24, 0x0245
     59c:	90 91 46 02 	lds	r25, 0x0246
     5a0:	0a 97       	sbiw	r24, 0x0a	; 10
     5a2:	d0 f3       	brcs	.-12     	; 0x598 <tick+0x30>
	delayms(10);
	SPK_PORT |= _BV(SPK2);
	SPK_PORT &= ~_BV(SPK1);
	delayms(10);
	// turn them both off
	SPK_PORT &= ~_BV(SPK1) & ~_BV(SPK2);
     5a4:	85 b1       	in	r24, 0x05	; 5
     5a6:	89 7f       	andi	r24, 0xF9	; 249
     5a8:	85 b9       	out	0x05, r24	; 5

	TCCR1A = _BV(COM1A1) | _BV(COM1B1) | _BV(COM1B0) | _BV(WGM11);
     5aa:	82 eb       	ldi	r24, 0xB2	; 178
     5ac:	80 93 80 00 	sts	0x0080, r24
	TCCR1B = _BV(WGM13) | _BV(WGM12);
     5b0:	88 e1       	ldi	r24, 0x18	; 24
     5b2:	80 93 81 00 	sts	0x0081, r24
}
     5b6:	08 95       	ret

000005b8 <beep>:

// We can play short beeps!
void beep(uint16_t freq, uint8_t times) {
     5b8:	1f 93       	push	r17
     5ba:	16 2f       	mov	r17, r22
	// set the PWM output to match the desired frequency
	ICR1 = (F_CPU/8)/freq;
     5bc:	9c 01       	movw	r18, r24
     5be:	40 e0       	ldi	r20, 0x00	; 0
     5c0:	50 e0       	ldi	r21, 0x00	; 0
     5c2:	60 e4       	ldi	r22, 0x40	; 64
     5c4:	72 e4       	ldi	r23, 0x42	; 66
     5c6:	8f e0       	ldi	r24, 0x0F	; 15
     5c8:	90 e0       	ldi	r25, 0x00	; 0
     5ca:	0e 94 7d 1b 	call	0x36fa	; 0x36fa <__divmodsi4>
     5ce:	30 93 87 00 	sts	0x0087, r19
     5d2:	20 93 86 00 	sts	0x0086, r18
	// we want 50% duty cycle square wave
	OCR1A = OCR1B = ICR1/2;
     5d6:	80 91 86 00 	lds	r24, 0x0086
     5da:	90 91 87 00 	lds	r25, 0x0087
     5de:	96 95       	lsr	r25
     5e0:	87 95       	ror	r24
     5e2:	90 93 8b 00 	sts	0x008B, r25
     5e6:	80 93 8a 00 	sts	0x008A, r24
     5ea:	80 91 8a 00 	lds	r24, 0x008A
     5ee:	90 91 8b 00 	lds	r25, 0x008B
     5f2:	90 93 89 00 	sts	0x0089, r25
     5f6:	80 93 88 00 	sts	0x0088, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     5fa:	28 ec       	ldi	r18, 0xC8	; 200
     5fc:	30 e0       	ldi	r19, 0x00	; 0
     5fe:	1c c0       	rjmp	.+56     	; 0x638 <beep+0x80>

	while (times--) {
		TCCR1B |= _BV(CS11); // turn it on!
     600:	80 91 81 00 	lds	r24, 0x0081
     604:	82 60       	ori	r24, 0x02	; 2
     606:	80 93 81 00 	sts	0x0081, r24
     60a:	80 ed       	ldi	r24, 0xD0	; 208
     60c:	97 e0       	ldi	r25, 0x07	; 7
     60e:	f9 01       	movw	r30, r18
     610:	31 97       	sbiw	r30, 0x01	; 1
     612:	f1 f7       	brne	.-4      	; 0x610 <beep+0x58>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     614:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     616:	d9 f7       	brne	.-10     	; 0x60e <beep+0x56>
		// beeps are 200ms long on
		_delay_ms(200);
		TCCR1B &= ~_BV(CS11); // turn it off!
     618:	80 91 81 00 	lds	r24, 0x0081
     61c:	8d 7f       	andi	r24, 0xFD	; 253
     61e:	80 93 81 00 	sts	0x0081, r24
		PORTB &= ~_BV(SPK1) & ~_BV(SPK2);
     622:	85 b1       	in	r24, 0x05	; 5
     624:	89 7f       	andi	r24, 0xF9	; 249
     626:	85 b9       	out	0x05, r24	; 5
     628:	80 ed       	ldi	r24, 0xD0	; 208
     62a:	97 e0       	ldi	r25, 0x07	; 7
     62c:	f9 01       	movw	r30, r18
     62e:	31 97       	sbiw	r30, 0x01	; 1
     630:	f1 f7       	brne	.-4      	; 0x62e <beep+0x76>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     632:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     634:	d9 f7       	brne	.-10     	; 0x62c <beep+0x74>
     636:	11 50       	subi	r17, 0x01	; 1
	// set the PWM output to match the desired frequency
	ICR1 = (F_CPU/8)/freq;
	// we want 50% duty cycle square wave
	OCR1A = OCR1B = ICR1/2;

	while (times--) {
     638:	11 23       	and	r17, r17
     63a:	11 f7       	brne	.-60     	; 0x600 <beep+0x48>
		PORTB &= ~_BV(SPK1) & ~_BV(SPK2);
		// beeps are 200ms long off
		_delay_ms(200);
	}
	// turn speaker off
	PORTB &= ~_BV(SPK1) & ~_BV(SPK2);
     63c:	85 b1       	in	r24, 0x05	; 5
     63e:	89 7f       	andi	r24, 0xF9	; 249
     640:	85 b9       	out	0x05, r24	; 5
}
     642:	1f 91       	pop	r17
     644:	08 95       	ret

00000646 <dimmer_init>:

#ifdef FEATURE_AUTODIM
/**************************** DIMMER ****************************/
void dimmer_init(void) {
	// Power for the photoresistor
	DIMMER_POWER_DDR |= _BV(DIMMER_POWER_PIN); 
     646:	3d 9a       	sbi	0x07, 5	; 7
	DIMMER_POWER_PORT |= _BV(DIMMER_POWER_PIN);
     648:	45 9a       	sbi	0x08, 5	; 8

	ADCSRA |= _BV(ADPS2)| _BV(ADPS1); // Set ADC prescalar to 64 - 125KHz sample rate @ 8MHz F_CPU
     64a:	aa e7       	ldi	r26, 0x7A	; 122
     64c:	b0 e0       	ldi	r27, 0x00	; 0
     64e:	8c 91       	ld	r24, X
     650:	86 60       	ori	r24, 0x06	; 6
     652:	8c 93       	st	X, r24
	ADMUX |= _BV(REFS0);  // Set ADC reference to AVCC
     654:	ec e7       	ldi	r30, 0x7C	; 124
     656:	f0 e0       	ldi	r31, 0x00	; 0
     658:	80 81       	ld	r24, Z
     65a:	80 64       	ori	r24, 0x40	; 64
     65c:	80 83       	st	Z, r24
	ADMUX |= _BV(DIMMER_SENSE_PIN);   // Set ADC input as ADC4 (PC4)
     65e:	80 81       	ld	r24, Z
     660:	84 60       	ori	r24, 0x04	; 4
     662:	80 83       	st	Z, r24
	DIDR0 |= _BV(DIMMER_SENSE_PIND); // Disable the digital imput buffer on the sense pin to save power.
     664:	ee e7       	ldi	r30, 0x7E	; 126
     666:	f0 e0       	ldi	r31, 0x00	; 0
     668:	80 81       	ld	r24, Z
     66a:	80 61       	ori	r24, 0x10	; 16
     66c:	80 83       	st	Z, r24
	ADCSRA |= _BV(ADEN);  // Enable ADC
     66e:	8c 91       	ld	r24, X
     670:	80 68       	ori	r24, 0x80	; 128
     672:	8c 93       	st	X, r24
	ADCSRA |= _BV(ADIE);  // Enable ADC interrupt
     674:	8c 91       	ld	r24, X
     676:	88 60       	ori	r24, 0x08	; 8
     678:	8c 93       	st	X, r24
}
     67a:	08 95       	ret

0000067c <dimmer_update>:

// Start ADC conversion for dimmer
void dimmer_update(void) {
	if (brightness_level == 0) 
     67c:	80 91 e1 02 	lds	r24, 0x02E1
     680:	88 23       	and	r24, r24
     682:	29 f4       	brne	.+10     	; 0x68e <dimmer_update+0x12>
		ADCSRA |= _BV(ADSC);
     684:	80 91 7a 00 	lds	r24, 0x007A
     688:	80 64       	ori	r24, 0x40	; 64
     68a:	80 93 7a 00 	sts	0x007A, r24
     68e:	08 95       	ret

00000690 <__vector_21>:
}

// Update brightness once ADC measurement completes
SIGNAL(SIG_ADC) {
     690:	1f 92       	push	r1
     692:	0f 92       	push	r0
     694:	0f b6       	in	r0, 0x3f	; 63
     696:	0f 92       	push	r0
     698:	11 24       	eor	r1, r1
     69a:	2f 93       	push	r18
     69c:	3f 93       	push	r19
     69e:	4f 93       	push	r20
     6a0:	5f 93       	push	r21
     6a2:	6f 93       	push	r22
     6a4:	7f 93       	push	r23
     6a6:	8f 93       	push	r24
     6a8:	9f 93       	push	r25
     6aa:	af 93       	push	r26
     6ac:	bf 93       	push	r27
     6ae:	ef 93       	push	r30
     6b0:	ff 93       	push	r31
	uint8_t low, high;
	unsigned int val;
	if (brightness_level != 0)
     6b2:	80 91 e1 02 	lds	r24, 0x02E1
     6b6:	88 23       	and	r24, r24
     6b8:	b9 f5       	brne	.+110    	; 0x728 <__vector_21+0x98>
		return;
	// Read 2-byte value. Must read ADCL first because that locks the value.
	low = ADCL;
     6ba:	30 91 78 00 	lds	r19, 0x0078
	high = ADCH;
     6be:	20 91 79 00 	lds	r18, 0x0079
	val = (high << 8) | low;
     6c2:	92 2f       	mov	r25, r18
     6c4:	80 e0       	ldi	r24, 0x00	; 0
     6c6:	63 2f       	mov	r22, r19
     6c8:	70 e0       	ldi	r23, 0x00	; 0
     6ca:	68 2b       	or	r22, r24
     6cc:	79 2b       	or	r23, r25
	// Set brightness to a value between min & max based on light reading.
	if (val >= PHOTOCELL_DARK) {
     6ce:	83 e0       	ldi	r24, 0x03	; 3
     6d0:	6f 3f       	cpi	r22, 0xFF	; 255
     6d2:	78 07       	cpc	r23, r24
     6d4:	18 f0       	brcs	.+6      	; 0x6dc <__vector_21+0x4c>
     6d6:	8d e2       	ldi	r24, 0x2D	; 45
     6d8:	90 e0       	ldi	r25, 0x00	; 0
     6da:	1b c0       	rjmp	.+54     	; 0x712 <__vector_21+0x82>
		val = PHOTOCELL_MIN;
	} else if (val <= PHOTOCELL_LIGHT) {
     6dc:	82 e0       	ldi	r24, 0x02	; 2
     6de:	69 35       	cpi	r22, 0x59	; 89
     6e0:	78 07       	cpc	r23, r24
     6e2:	18 f4       	brcc	.+6      	; 0x6ea <__vector_21+0x5a>
     6e4:	8a e5       	ldi	r24, 0x5A	; 90
     6e6:	90 e0       	ldi	r25, 0x00	; 0
     6e8:	14 c0       	rjmp	.+40     	; 0x712 <__vector_21+0x82>
		val = PHOTOCELL_MAX;
	} else {
		val = PHOTOCELL_MAX - (((unsigned long)(PHOTOCELL_MAX - PHOTOCELL_MIN)) *
     6ea:	68 55       	subi	r22, 0x58	; 88
     6ec:	72 40       	sbci	r23, 0x02	; 2
     6ee:	80 e0       	ldi	r24, 0x00	; 0
     6f0:	90 e0       	ldi	r25, 0x00	; 0
     6f2:	2d e2       	ldi	r18, 0x2D	; 45
     6f4:	30 e0       	ldi	r19, 0x00	; 0
     6f6:	40 e0       	ldi	r20, 0x00	; 0
     6f8:	50 e0       	ldi	r21, 0x00	; 0
     6fa:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <__mulsi3>
     6fe:	27 ea       	ldi	r18, 0xA7	; 167
     700:	31 e0       	ldi	r19, 0x01	; 1
     702:	40 e0       	ldi	r20, 0x00	; 0
     704:	50 e0       	ldi	r21, 0x00	; 0
     706:	0e 94 5b 1b 	call	0x36b6	; 0x36b6 <__udivmodsi4>
     70a:	8a e5       	ldi	r24, 0x5A	; 90
     70c:	90 e0       	ldi	r25, 0x00	; 0
     70e:	82 1b       	sub	r24, r18
     710:	93 0b       	sbc	r25, r19
				(val - PHOTOCELL_LIGHT)) / (PHOTOCELL_DARK - PHOTOCELL_LIGHT);
	}
	set_vfd_brightness(val);
     712:	98 2f       	mov	r25, r24
}

void set_vfd_brightness(uint8_t brightness) {
	// Set PWM value, don't set it so high that
	// we could damage the MAX chip or display
	if (brightness > BRIGHTNESS_MAX)
     714:	8b 35       	cpi	r24, 0x5B	; 91
     716:	10 f0       	brcs	.+4      	; 0x71c <__vector_21+0x8c>
     718:	9a e5       	ldi	r25, 0x5A	; 90
     71a:	03 c0       	rjmp	.+6      	; 0x722 <__vector_21+0x92>
		brightness = BRIGHTNESS_MAX;

	// Or so low its not visible
	if (brightness < BRIGHTNESS_MIN)
     71c:	8e 31       	cpi	r24, 0x1E	; 30
     71e:	08 f4       	brcc	.+2      	; 0x722 <__vector_21+0x92>
     720:	9e e1       	ldi	r25, 0x1E	; 30
	//// Round up to the next brightness increment
	//if (brightness % BRIGHTNESS_INCREMENT != 0) {
	//  brightness += BRIGHTNESS_INCREMENT - (brightness % BRIGHTNESS_INCREMENT);
	//}

	if (OCR0A == brightness)
     722:	87 b5       	in	r24, 0x27	; 39
     724:	89 13       	cpse	r24, r25
		return;

	OCR0A = brightness;
     726:	97 bd       	out	0x27, r25	; 39
	} else {
		val = PHOTOCELL_MAX - (((unsigned long)(PHOTOCELL_MAX - PHOTOCELL_MIN)) *
				(val - PHOTOCELL_LIGHT)) / (PHOTOCELL_DARK - PHOTOCELL_LIGHT);
	}
	set_vfd_brightness(val);
}
     728:	ff 91       	pop	r31
     72a:	ef 91       	pop	r30
     72c:	bf 91       	pop	r27
     72e:	af 91       	pop	r26
     730:	9f 91       	pop	r25
     732:	8f 91       	pop	r24
     734:	7f 91       	pop	r23
     736:	6f 91       	pop	r22
     738:	5f 91       	pop	r21
     73a:	4f 91       	pop	r20
     73c:	3f 91       	pop	r19
     73e:	2f 91       	pop	r18
     740:	0f 90       	pop	r0
     742:	0f be       	out	0x3f, r0	; 63
     744:	0f 90       	pop	r0
     746:	1f 90       	pop	r1
     748:	18 95       	reti

0000074a <boost_init>:

/**************************** BOOST *****************************/

// We control the boost converter by changing the PWM output
// pins
void boost_init(uint8_t brightness) {
     74a:	98 2f       	mov	r25, r24
}

void set_vfd_brightness(uint8_t brightness) {
	// Set PWM value, don't set it so high that
	// we could damage the MAX chip or display
	if (brightness > BRIGHTNESS_MAX)
     74c:	8b 35       	cpi	r24, 0x5B	; 91
     74e:	10 f0       	brcs	.+4      	; 0x754 <boost_init+0xa>
     750:	9a e5       	ldi	r25, 0x5A	; 90
     752:	03 c0       	rjmp	.+6      	; 0x75a <boost_init+0x10>
		brightness = BRIGHTNESS_MAX;

	// Or so low its not visible
	if (brightness < BRIGHTNESS_MIN)
     754:	8e 31       	cpi	r24, 0x1E	; 30
     756:	08 f4       	brcc	.+2      	; 0x75a <boost_init+0x10>
     758:	9e e1       	ldi	r25, 0x1E	; 30
	//// Round up to the next brightness increment
	//if (brightness % BRIGHTNESS_INCREMENT != 0) {
	//  brightness += BRIGHTNESS_INCREMENT - (brightness % BRIGHTNESS_INCREMENT);
	//}

	if (OCR0A == brightness)
     75a:	87 b5       	in	r24, 0x27	; 39
     75c:	89 13       	cpse	r24, r25
		return;

	OCR0A = brightness;
     75e:	97 bd       	out	0x27, r25	; 39
void boost_init(uint8_t brightness) {

	set_vfd_brightness(brightness);

	// fast PWM, set OC0A (boost output pin) on match
	TCCR0A = _BV(WGM00) | _BV(WGM01);  
     760:	83 e0       	ldi	r24, 0x03	; 3
     762:	84 bd       	out	0x24, r24	; 36

	// Use the fastest clock
	TCCR0B = _BV(CS00);
     764:	81 e0       	ldi	r24, 0x01	; 1
     766:	85 bd       	out	0x25, r24	; 37

	TCCR0A |= _BV(COM0A1);
     768:	84 b5       	in	r24, 0x24	; 36
     76a:	80 68       	ori	r24, 0x80	; 128
     76c:	84 bd       	out	0x24, r24	; 36
	TIMSK0 |= _BV(TOIE0); // turn on the interrupt for muxing
     76e:	80 91 6e 00 	lds	r24, 0x006E
     772:	81 60       	ori	r24, 0x01	; 1
     774:	80 93 6e 00 	sts	0x006E, r24
	sei();
     778:	78 94       	sei
}
     77a:	08 95       	ret

0000077c <set_vfd_brightness>:

void set_vfd_brightness(uint8_t brightness) {
     77c:	98 2f       	mov	r25, r24
	// Set PWM value, don't set it so high that
	// we could damage the MAX chip or display
	if (brightness > BRIGHTNESS_MAX)
     77e:	8b 35       	cpi	r24, 0x5B	; 91
     780:	10 f0       	brcs	.+4      	; 0x786 <set_vfd_brightness+0xa>
     782:	9a e5       	ldi	r25, 0x5A	; 90
     784:	03 c0       	rjmp	.+6      	; 0x78c <set_vfd_brightness+0x10>
		brightness = BRIGHTNESS_MAX;

	// Or so low its not visible
	if (brightness < BRIGHTNESS_MIN)
     786:	8e 31       	cpi	r24, 0x1E	; 30
     788:	08 f4       	brcc	.+2      	; 0x78c <set_vfd_brightness+0x10>
     78a:	9e e1       	ldi	r25, 0x1E	; 30
	//// Round up to the next brightness increment
	//if (brightness % BRIGHTNESS_INCREMENT != 0) {
	//  brightness += BRIGHTNESS_INCREMENT - (brightness % BRIGHTNESS_INCREMENT);
	//}

	if (OCR0A == brightness)
     78c:	87 b5       	in	r24, 0x27	; 39
     78e:	89 13       	cpse	r24, r25
		return;

	OCR0A = brightness;
     790:	97 bd       	out	0x27, r25	; 39
     792:	08 95       	ret

00000794 <display_time>:

	}
}

// This displays a time on the clock
void display_time(uint8_t h, uint8_t m, uint8_t s) {
     794:	1f 93       	push	r17
     796:	18 2f       	mov	r17, r24
     798:	26 2f       	mov	r18, r22
	 * 	8		32
	 * 		16			1
	 */

	// seconds and minutes are at the end
	display[8] =  pgm_read_byte(numbertable_p + (s % 10));
     79a:	84 2f       	mov	r24, r20
     79c:	6a e0       	ldi	r22, 0x0A	; 10
     79e:	0e 94 1b 1b 	call	0x3636	; 0x3636 <__udivmodqi4>
     7a2:	e9 2f       	mov	r30, r25
     7a4:	f0 e0       	ldi	r31, 0x00	; 0
     7a6:	ec 57       	subi	r30, 0x7C	; 124
     7a8:	ff 4f       	sbci	r31, 0xFF	; 255
     7aa:	e4 91       	lpm	r30, Z+
     7ac:	e0 93 dd 02 	sts	0x02DD, r30
	display[7] =  pgm_read_byte(numbertable_p + (s / 10));
     7b0:	84 2f       	mov	r24, r20
     7b2:	0e 94 1b 1b 	call	0x3636	; 0x3636 <__udivmodqi4>
     7b6:	e8 2f       	mov	r30, r24
     7b8:	f0 e0       	ldi	r31, 0x00	; 0
     7ba:	ec 57       	subi	r30, 0x7C	; 124
     7bc:	ff 4f       	sbci	r31, 0xFF	; 255
     7be:	e4 91       	lpm	r30, Z+
     7c0:	e0 93 dc 02 	sts	0x02DC, r30

	switch(secondDisp) {
     7c4:	80 91 3d 02 	lds	r24, 0x023D
     7c8:	83 30       	cpi	r24, 0x03	; 3
     7ca:	91 f0       	breq	.+36     	; 0x7f0 <display_time+0x5c>
     7cc:	84 30       	cpi	r24, 0x04	; 4
     7ce:	28 f4       	brcc	.+10     	; 0x7da <display_time+0x46>
     7d0:	81 30       	cpi	r24, 0x01	; 1
     7d2:	91 f0       	breq	.+36     	; 0x7f8 <display_time+0x64>
     7d4:	82 30       	cpi	r24, 0x02	; 2
     7d6:	50 f4       	brcc	.+20     	; 0x7ec <display_time+0x58>
     7d8:	07 c0       	rjmp	.+14     	; 0x7e8 <display_time+0x54>
     7da:	85 30       	cpi	r24, 0x05	; 5
     7dc:	69 f0       	breq	.+26     	; 0x7f8 <display_time+0x64>
     7de:	85 30       	cpi	r24, 0x05	; 5
     7e0:	48 f0       	brcs	.+18     	; 0x7f4 <display_time+0x60>
     7e2:	86 30       	cpi	r24, 0x06	; 6
     7e4:	69 f4       	brne	.+26     	; 0x800 <display_time+0x6c>
     7e6:	0a c0       	rjmp	.+20     	; 0x7fc <display_time+0x68>
		case 0:
			display[3] = 0x08;
     7e8:	88 e0       	ldi	r24, 0x08	; 8
     7ea:	0b c0       	rjmp	.+22     	; 0x802 <display_time+0x6e>
		case 1:
			display[3] = 0x02;
			display[6] = 0x02;
			break;
		case 2:
			display[3] = 0x40;
     7ec:	80 e4       	ldi	r24, 0x40	; 64
     7ee:	09 c0       	rjmp	.+18     	; 0x802 <display_time+0x6e>
			display[6] = 0x40;
			break;
		case 3:
			display[3] = 0x80;
     7f0:	80 e8       	ldi	r24, 0x80	; 128
     7f2:	07 c0       	rjmp	.+14     	; 0x802 <display_time+0x6e>
			display[6] = 0x80;
			break;
		case 4:
			display[3] = 0x04;
     7f4:	84 e0       	ldi	r24, 0x04	; 4
     7f6:	05 c0       	rjmp	.+10     	; 0x802 <display_time+0x6e>
			display[6] = 0x04;
			break;
		case 5:
			display[3] = 0x02;
     7f8:	82 e0       	ldi	r24, 0x02	; 2
     7fa:	03 c0       	rjmp	.+6      	; 0x802 <display_time+0x6e>
			display[6] = 0x02;
			break;
		case 6:
			display[3] = 0x20;
     7fc:	80 e2       	ldi	r24, 0x20	; 32
     7fe:	01 c0       	rjmp	.+2      	; 0x802 <display_time+0x6e>
			display[6] = 0x20;
			break;
		default:
			display[3] = 0x10;
     800:	80 e1       	ldi	r24, 0x10	; 16
     802:	80 93 d8 02 	sts	0x02D8, r24
			display[6] = 0x10;
     806:	80 93 db 02 	sts	0x02DB, r24
	}

	if (secondDisp==7) {
     80a:	80 91 3d 02 	lds	r24, 0x023D
     80e:	87 30       	cpi	r24, 0x07	; 7
     810:	19 f4       	brne	.+6      	; 0x818 <display_time+0x84>
		secondDisp=0;
     812:	10 92 3d 02 	sts	0x023D, r1
     816:	05 c0       	rjmp	.+10     	; 0x822 <display_time+0x8e>
	} else {
		secondDisp+=1;
     818:	80 91 3d 02 	lds	r24, 0x023D
     81c:	8f 5f       	subi	r24, 0xFF	; 255
     81e:	80 93 3d 02 	sts	0x023D, r24
	}


	display[5] =  pgm_read_byte(numbertable_p + (m % 10));
     822:	82 2f       	mov	r24, r18
     824:	6a e0       	ldi	r22, 0x0A	; 10
     826:	0e 94 1b 1b 	call	0x3636	; 0x3636 <__udivmodqi4>
     82a:	e9 2f       	mov	r30, r25
     82c:	f0 e0       	ldi	r31, 0x00	; 0
     82e:	ec 57       	subi	r30, 0x7C	; 124
     830:	ff 4f       	sbci	r31, 0xFF	; 255
     832:	e4 91       	lpm	r30, Z+
     834:	e0 93 da 02 	sts	0x02DA, r30
	display[4] =  pgm_read_byte(numbertable_p + (m / 10)); 
     838:	82 2f       	mov	r24, r18
     83a:	0e 94 1b 1b 	call	0x3636	; 0x3636 <__udivmodqi4>
     83e:	e8 2f       	mov	r30, r24
     840:	f0 e0       	ldi	r31, 0x00	; 0
     842:	ec 57       	subi	r30, 0x7C	; 124
     844:	ff 4f       	sbci	r31, 0xFF	; 255
     846:	e4 91       	lpm	r30, Z+
     848:	e0 93 d9 02 	sts	0x02D9, r30


	// check euro (24h) or US (12h) style time
	if (region == REGION_US) {
     84c:	80 91 38 02 	lds	r24, 0x0238
     850:	88 23       	and	r24, r24
     852:	61 f5       	brne	.+88     	; 0x8ac <display_time+0x118>
		display[2] =  pgm_read_byte(numbertable_p + ( (((h+11)%12)+1) % 10));
     854:	81 2f       	mov	r24, r17
     856:	90 e0       	ldi	r25, 0x00	; 0
     858:	0b 96       	adiw	r24, 0x0b	; 11
     85a:	6c e0       	ldi	r22, 0x0C	; 12
     85c:	70 e0       	ldi	r23, 0x00	; 0
     85e:	0e 94 48 1b 	call	0x3690	; 0x3690 <__divmodhi4>
     862:	9c 01       	movw	r18, r24
     864:	2f 5f       	subi	r18, 0xFF	; 255
     866:	3f 4f       	sbci	r19, 0xFF	; 255
     868:	c9 01       	movw	r24, r18
     86a:	6a e0       	ldi	r22, 0x0A	; 10
     86c:	70 e0       	ldi	r23, 0x00	; 0
     86e:	0e 94 48 1b 	call	0x3690	; 0x3690 <__divmodhi4>
     872:	fc 01       	movw	r30, r24
     874:	ec 57       	subi	r30, 0x7C	; 124
     876:	ff 4f       	sbci	r31, 0xFF	; 255
     878:	e4 91       	lpm	r30, Z+
     87a:	e0 93 d7 02 	sts	0x02D7, r30
		display[1] =  pgm_read_byte(numbertable_p + ( (((h+11)%12)+1) / 10));
     87e:	c9 01       	movw	r24, r18
     880:	6a e0       	ldi	r22, 0x0A	; 10
     882:	70 e0       	ldi	r23, 0x00	; 0
     884:	0e 94 48 1b 	call	0x3690	; 0x3690 <__divmodhi4>
     888:	fb 01       	movw	r30, r22
     88a:	ec 57       	subi	r30, 0x7C	; 124
     88c:	ff 4f       	sbci	r31, 0xFF	; 255
     88e:	e4 91       	lpm	r30, Z+
     890:	e0 93 d6 02 	sts	0x02D6, r30

		// We use the '*' as an am/pm notice
		if (h >= 12)
     894:	1c 30       	cpi	r17, 0x0C	; 12
     896:	20 f0       	brcs	.+8      	; 0x8a0 <display_time+0x10c>
			display[0] |= 0x1;  // 'pm' notice
     898:	80 91 d5 02 	lds	r24, 0x02D5
     89c:	81 60       	ori	r24, 0x01	; 1
     89e:	03 c0       	rjmp	.+6      	; 0x8a6 <display_time+0x112>
		else 
			display[0] &= ~0x1;  // 'pm' notice
     8a0:	80 91 d5 02 	lds	r24, 0x02D5
     8a4:	8e 7f       	andi	r24, 0xFE	; 254
     8a6:	80 93 d5 02 	sts	0x02D5, r24
     8aa:	1a c0       	rjmp	.+52     	; 0x8e0 <display_time+0x14c>
	} else {
		display[2] =  pgm_read_byte(numbertable_p + ( (h%24) % 10));
     8ac:	81 2f       	mov	r24, r17
     8ae:	68 e1       	ldi	r22, 0x18	; 24
     8b0:	0e 94 1b 1b 	call	0x3636	; 0x3636 <__udivmodqi4>
     8b4:	29 2f       	mov	r18, r25
     8b6:	89 2f       	mov	r24, r25
     8b8:	6a e0       	ldi	r22, 0x0A	; 10
     8ba:	0e 94 1b 1b 	call	0x3636	; 0x3636 <__udivmodqi4>
     8be:	e9 2f       	mov	r30, r25
     8c0:	f0 e0       	ldi	r31, 0x00	; 0
     8c2:	ec 57       	subi	r30, 0x7C	; 124
     8c4:	ff 4f       	sbci	r31, 0xFF	; 255
     8c6:	e4 91       	lpm	r30, Z+
     8c8:	e0 93 d7 02 	sts	0x02D7, r30
		display[1] =  pgm_read_byte(numbertable_p + ( (h%24) / 10));
     8cc:	82 2f       	mov	r24, r18
     8ce:	0e 94 1b 1b 	call	0x3636	; 0x3636 <__udivmodqi4>
     8d2:	e8 2f       	mov	r30, r24
     8d4:	f0 e0       	ldi	r31, 0x00	; 0
     8d6:	ec 57       	subi	r30, 0x7C	; 124
     8d8:	ff 4f       	sbci	r31, 0xFF	; 255
     8da:	e4 91       	lpm	r30, Z+
     8dc:	e0 93 d6 02 	sts	0x02D6, r30
	}
}
     8e0:	1f 91       	pop	r17
     8e2:	08 95       	ret

000008e4 <display_alarm>:

// Kinda like display_time but just hours and minutes
void display_alarm(uint8_t h, uint8_t m){ 
     8e4:	38 2f       	mov	r19, r24
     8e6:	26 2f       	mov	r18, r22
	display[8] = 0;
     8e8:	10 92 dd 02 	sts	0x02DD, r1
	display[7] = 0;
     8ec:	10 92 dc 02 	sts	0x02DC, r1
	display[6] = 0;
     8f0:	10 92 db 02 	sts	0x02DB, r1
	display[5] = pgm_read_byte(numbertable_p + (m % 10));
     8f4:	86 2f       	mov	r24, r22
     8f6:	6a e0       	ldi	r22, 0x0A	; 10
     8f8:	0e 94 1b 1b 	call	0x3636	; 0x3636 <__udivmodqi4>
     8fc:	e9 2f       	mov	r30, r25
     8fe:	f0 e0       	ldi	r31, 0x00	; 0
     900:	ec 57       	subi	r30, 0x7C	; 124
     902:	ff 4f       	sbci	r31, 0xFF	; 255
     904:	e4 91       	lpm	r30, Z+
     906:	e0 93 da 02 	sts	0x02DA, r30
	display[4] = pgm_read_byte(numbertable_p + (m / 10)); 
     90a:	82 2f       	mov	r24, r18
     90c:	0e 94 1b 1b 	call	0x3636	; 0x3636 <__udivmodqi4>
     910:	e8 2f       	mov	r30, r24
     912:	f0 e0       	ldi	r31, 0x00	; 0
     914:	ec 57       	subi	r30, 0x7C	; 124
     916:	ff 4f       	sbci	r31, 0xFF	; 255
     918:	e4 91       	lpm	r30, Z+
     91a:	e0 93 d9 02 	sts	0x02D9, r30
	display[3] = 0;
     91e:	10 92 d8 02 	sts	0x02D8, r1

	// check euro or US style time
	if (region == REGION_US) {
     922:	80 91 38 02 	lds	r24, 0x0238
     926:	88 23       	and	r24, r24
     928:	09 f0       	breq	.+2      	; 0x92c <display_alarm+0x48>
     92a:	3b c0       	rjmp	.+118    	; 0x9a2 <display_alarm+0xbe>
		if (h >= 12) {
     92c:	3c 30       	cpi	r19, 0x0C	; 12
     92e:	58 f0       	brcs	.+22     	; 0x946 <display_alarm+0x62>
			display[0] |= 0x1;  // 'pm' notice
     930:	80 91 d5 02 	lds	r24, 0x02D5
     934:	81 60       	ori	r24, 0x01	; 1
     936:	80 93 d5 02 	sts	0x02D5, r24
			display[7] = pgm_read_byte(alphatable_p + 'p' - 'a');
     93a:	e7 e7       	ldi	r30, 0x77	; 119
     93c:	f0 e0       	ldi	r31, 0x00	; 0
     93e:	e4 91       	lpm	r30, Z+
     940:	e0 93 dc 02 	sts	0x02DC, r30
     944:	0a c0       	rjmp	.+20     	; 0x95a <display_alarm+0x76>
		} else {
			display[7] = pgm_read_byte(alphatable_p + 'a' - 'a');
     946:	e8 e6       	ldi	r30, 0x68	; 104
     948:	f0 e0       	ldi	r31, 0x00	; 0
     94a:	e4 91       	lpm	r30, Z+
     94c:	e0 93 dc 02 	sts	0x02DC, r30
			display[0] &= ~0x1;  // 'am' notice
     950:	80 91 d5 02 	lds	r24, 0x02D5
     954:	8e 7f       	andi	r24, 0xFE	; 254
     956:	80 93 d5 02 	sts	0x02D5, r24
		}
		display[8] = pgm_read_byte(alphatable_p + 'm' - 'a');
     95a:	e4 e7       	ldi	r30, 0x74	; 116
     95c:	f0 e0       	ldi	r31, 0x00	; 0
     95e:	e4 91       	lpm	r30, Z+
     960:	e0 93 dd 02 	sts	0x02DD, r30

		display[2] =  pgm_read_byte(numbertable_p + ( (((h+11)%12)+1) % 10));
     964:	83 2f       	mov	r24, r19
     966:	90 e0       	ldi	r25, 0x00	; 0
     968:	0b 96       	adiw	r24, 0x0b	; 11
     96a:	6c e0       	ldi	r22, 0x0C	; 12
     96c:	70 e0       	ldi	r23, 0x00	; 0
     96e:	0e 94 48 1b 	call	0x3690	; 0x3690 <__divmodhi4>
     972:	9c 01       	movw	r18, r24
     974:	2f 5f       	subi	r18, 0xFF	; 255
     976:	3f 4f       	sbci	r19, 0xFF	; 255
     978:	c9 01       	movw	r24, r18
     97a:	6a e0       	ldi	r22, 0x0A	; 10
     97c:	70 e0       	ldi	r23, 0x00	; 0
     97e:	0e 94 48 1b 	call	0x3690	; 0x3690 <__divmodhi4>
     982:	fc 01       	movw	r30, r24
     984:	ec 57       	subi	r30, 0x7C	; 124
     986:	ff 4f       	sbci	r31, 0xFF	; 255
     988:	e4 91       	lpm	r30, Z+
     98a:	e0 93 d7 02 	sts	0x02D7, r30
		display[1] =  pgm_read_byte(numbertable_p + ( (((h+11)%12)+1) / 10));
     98e:	c9 01       	movw	r24, r18
     990:	6a e0       	ldi	r22, 0x0A	; 10
     992:	70 e0       	ldi	r23, 0x00	; 0
     994:	0e 94 48 1b 	call	0x3690	; 0x3690 <__divmodhi4>
     998:	fb 01       	movw	r30, r22
     99a:	ec 57       	subi	r30, 0x7C	; 124
     99c:	ff 4f       	sbci	r31, 0xFF	; 255
     99e:	e4 91       	lpm	r30, Z+
     9a0:	1e c0       	rjmp	.+60     	; 0x9de <display_alarm+0xfa>
	} else {
		display[2] =  pgm_read_byte(numbertable_p + ( (((h+23)%24)+1) % 10));
     9a2:	83 2f       	mov	r24, r19
     9a4:	90 e0       	ldi	r25, 0x00	; 0
     9a6:	47 96       	adiw	r24, 0x17	; 23
     9a8:	68 e1       	ldi	r22, 0x18	; 24
     9aa:	70 e0       	ldi	r23, 0x00	; 0
     9ac:	0e 94 48 1b 	call	0x3690	; 0x3690 <__divmodhi4>
     9b0:	9c 01       	movw	r18, r24
     9b2:	2f 5f       	subi	r18, 0xFF	; 255
     9b4:	3f 4f       	sbci	r19, 0xFF	; 255
     9b6:	c9 01       	movw	r24, r18
     9b8:	6a e0       	ldi	r22, 0x0A	; 10
     9ba:	70 e0       	ldi	r23, 0x00	; 0
     9bc:	0e 94 48 1b 	call	0x3690	; 0x3690 <__divmodhi4>
     9c0:	fc 01       	movw	r30, r24
     9c2:	ec 57       	subi	r30, 0x7C	; 124
     9c4:	ff 4f       	sbci	r31, 0xFF	; 255
     9c6:	e4 91       	lpm	r30, Z+
     9c8:	e0 93 d7 02 	sts	0x02D7, r30
		display[1] =  pgm_read_byte(numbertable_p + ( (((h+23)%24)+1) / 10));
     9cc:	c9 01       	movw	r24, r18
     9ce:	6a e0       	ldi	r22, 0x0A	; 10
     9d0:	70 e0       	ldi	r23, 0x00	; 0
     9d2:	0e 94 48 1b 	call	0x3690	; 0x3690 <__divmodhi4>
     9d6:	fb 01       	movw	r30, r22
     9d8:	ec 57       	subi	r30, 0x7C	; 124
     9da:	ff 4f       	sbci	r31, 0xFF	; 255
     9dc:	e4 91       	lpm	r30, Z+
     9de:	e0 93 d6 02 	sts	0x02D6, r30
     9e2:	08 95       	ret

000009e4 <set_alarm>:
}

/**************************** SUB-MENUS *****************************/

void set_alarm(void) 
{
     9e4:	ef 92       	push	r14
     9e6:	ff 92       	push	r15
     9e8:	0f 93       	push	r16
     9ea:	1f 93       	push	r17
	uint8_t hour, min, sec;

	hour = min = sec = 0;
	mode = SHOW_MENU;

	hour = alarm_h;
     9ec:	10 91 e0 02 	lds	r17, 0x02E0
	min = alarm_m;
     9f0:	00 91 d2 02 	lds	r16, 0x02D2
	sec = 0;

	timeoutcounter = INACTIVITYTIMEOUT;
     9f4:	8a e0       	ldi	r24, 0x0A	; 10
     9f6:	80 93 4b 02 	sts	0x024B, r24
     9fa:	ff 24       	eor	r15, r15
	while (1) {
		if (just_pressed & 0x1) { // mode change
			return;
		}
		if (just_pressed || pressed) {
			timeoutcounter = INACTIVITYTIMEOUT;  
     9fc:	ea e0       	ldi	r30, 0x0A	; 10
     9fe:	ee 2e       	mov	r14, r30
	sec = 0;

	timeoutcounter = INACTIVITYTIMEOUT;

	while (1) {
		if (just_pressed & 0x1) { // mode change
     a00:	80 91 48 02 	lds	r24, 0x0248
     a04:	80 fd       	sbrc	r24, 0
     a06:	d3 c0       	rjmp	.+422    	; 0xbae <set_alarm+0x1ca>
			return;
		}
		if (just_pressed || pressed) {
     a08:	80 91 48 02 	lds	r24, 0x0248
     a0c:	88 23       	and	r24, r24
     a0e:	21 f4       	brne	.+8      	; 0xa18 <set_alarm+0x34>
     a10:	80 91 49 02 	lds	r24, 0x0249
     a14:	88 23       	and	r24, r24
     a16:	19 f0       	breq	.+6      	; 0xa1e <set_alarm+0x3a>
			timeoutcounter = INACTIVITYTIMEOUT;  
     a18:	e0 92 4b 02 	sts	0x024B, r14
     a1c:	29 c0       	rjmp	.+82     	; 0xa70 <set_alarm+0x8c>
			// timeout w/no buttons pressed after 3 seconds?
		} else if (!timeoutcounter) {
     a1e:	80 91 4b 02 	lds	r24, 0x024B
     a22:	88 23       	and	r24, r24
     a24:	29 f5       	brne	.+74     	; 0xa70 <set_alarm+0x8c>
			//timed out!
			displaymode = SHOW_TIME;     
     a26:	10 92 e3 02 	sts	0x02E3, r1
			alarm_h = hour;
     a2a:	10 93 e0 02 	sts	0x02E0, r17
			alarm_m = min;
     a2e:	00 93 d2 02 	sts	0x02D2, r16
			eeprom_write_byte((uint8_t *)EE_ALARM_HOUR, alarm_h);    
     a32:	20 91 e0 02 	lds	r18, 0x02E0
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
     a36:	f9 99       	sbic	0x1f, 1	; 31
     a38:	fe cf       	rjmp	.-4      	; 0xa36 <set_alarm+0x52>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     a3a:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
     a3c:	87 e0       	ldi	r24, 0x07	; 7
     a3e:	90 e0       	ldi	r25, 0x00	; 0
     a40:	92 bd       	out	0x22, r25	; 34
     a42:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
     a44:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
     a46:	0f b6       	in	r0, 0x3f	; 63
     a48:	f8 94       	cli
     a4a:	fa 9a       	sbi	0x1f, 2	; 31
     a4c:	f9 9a       	sbi	0x1f, 1	; 31
     a4e:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte((uint8_t *)EE_ALARM_MIN, alarm_m);    
     a50:	20 91 d2 02 	lds	r18, 0x02D2
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
     a54:	f9 99       	sbic	0x1f, 1	; 31
     a56:	fe cf       	rjmp	.-4      	; 0xa54 <set_alarm+0x70>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     a58:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
     a5a:	88 e0       	ldi	r24, 0x08	; 8
     a5c:	90 e0       	ldi	r25, 0x00	; 0
     a5e:	92 bd       	out	0x22, r25	; 34
     a60:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
     a62:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
     a64:	0f b6       	in	r0, 0x3f	; 63
     a66:	f8 94       	cli
     a68:	fa 9a       	sbi	0x1f, 2	; 31
     a6a:	f9 9a       	sbi	0x1f, 1	; 31
     a6c:	0f be       	out	0x3f, r0	; 63
     a6e:	9f c0       	rjmp	.+318    	; 0xbae <set_alarm+0x1ca>
			return;
		}
		if (just_pressed & 0x2) {
     a70:	80 91 48 02 	lds	r24, 0x0248
     a74:	81 ff       	sbrs	r24, 1
     a76:	4e c0       	rjmp	.+156    	; 0xb14 <set_alarm+0x130>
			just_pressed = 0;
     a78:	10 92 48 02 	sts	0x0248, r1
			if (mode == SHOW_MENU) {
     a7c:	ff 20       	and	r15, r15
     a7e:	89 f4       	brne	.+34     	; 0xaa2 <set_alarm+0xbe>
				// ok now its selected
				mode = SET_HOUR;
				display_alarm(hour, min);
     a80:	81 2f       	mov	r24, r17
     a82:	60 2f       	mov	r22, r16
     a84:	0e 94 72 04 	call	0x8e4	; 0x8e4 <display_alarm>
				display[1] |= 0x1;
     a88:	80 91 d6 02 	lds	r24, 0x02D6
     a8c:	81 60       	ori	r24, 0x01	; 1
     a8e:	80 93 d6 02 	sts	0x02D6, r24
				display[2] |= 0x1;	
     a92:	80 91 d7 02 	lds	r24, 0x02D7
     a96:	81 60       	ori	r24, 0x01	; 1
     a98:	80 93 d7 02 	sts	0x02D7, r24
     a9c:	ff 24       	eor	r15, r15
     a9e:	f3 94       	inc	r15
     aa0:	39 c0       	rjmp	.+114    	; 0xb14 <set_alarm+0x130>
			} else if (mode == SET_HOUR) {
     aa2:	81 e0       	ldi	r24, 0x01	; 1
     aa4:	f8 16       	cp	r15, r24
     aa6:	89 f4       	brne	.+34     	; 0xaca <set_alarm+0xe6>
				mode = SET_MIN;
				display_alarm(hour, min);
     aa8:	81 2f       	mov	r24, r17
     aaa:	60 2f       	mov	r22, r16
     aac:	0e 94 72 04 	call	0x8e4	; 0x8e4 <display_alarm>
				display[4] |= 0x1;
     ab0:	80 91 d9 02 	lds	r24, 0x02D9
     ab4:	81 60       	ori	r24, 0x01	; 1
     ab6:	80 93 d9 02 	sts	0x02D9, r24
				display[5] |= 0x1;
     aba:	80 91 da 02 	lds	r24, 0x02DA
     abe:	81 60       	ori	r24, 0x01	; 1
     ac0:	80 93 da 02 	sts	0x02DA, r24
     ac4:	72 e0       	ldi	r23, 0x02	; 2
     ac6:	f7 2e       	mov	r15, r23
     ac8:	25 c0       	rjmp	.+74     	; 0xb14 <set_alarm+0x130>
			} else {
				// done!
				alarm_h = hour;
     aca:	10 93 e0 02 	sts	0x02E0, r17
				alarm_m = min;
     ace:	00 93 d2 02 	sts	0x02D2, r16
				eeprom_write_byte((uint8_t *)EE_ALARM_HOUR, alarm_h);    
     ad2:	20 91 e0 02 	lds	r18, 0x02E0
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
     ad6:	f9 99       	sbic	0x1f, 1	; 31
     ad8:	fe cf       	rjmp	.-4      	; 0xad6 <set_alarm+0xf2>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     ada:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
     adc:	87 e0       	ldi	r24, 0x07	; 7
     ade:	90 e0       	ldi	r25, 0x00	; 0
     ae0:	92 bd       	out	0x22, r25	; 34
     ae2:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
     ae4:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
     ae6:	0f b6       	in	r0, 0x3f	; 63
     ae8:	f8 94       	cli
     aea:	fa 9a       	sbi	0x1f, 2	; 31
     aec:	f9 9a       	sbi	0x1f, 1	; 31
     aee:	0f be       	out	0x3f, r0	; 63
				eeprom_write_byte((uint8_t *)EE_ALARM_MIN, alarm_m);    
     af0:	20 91 d2 02 	lds	r18, 0x02D2
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
     af4:	f9 99       	sbic	0x1f, 1	; 31
     af6:	fe cf       	rjmp	.-4      	; 0xaf4 <set_alarm+0x110>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     af8:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
     afa:	88 e0       	ldi	r24, 0x08	; 8
     afc:	90 e0       	ldi	r25, 0x00	; 0
     afe:	92 bd       	out	0x22, r25	; 34
     b00:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
     b02:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
     b04:	0f b6       	in	r0, 0x3f	; 63
     b06:	f8 94       	cli
     b08:	fa 9a       	sbi	0x1f, 2	; 31
     b0a:	f9 9a       	sbi	0x1f, 1	; 31
     b0c:	0f be       	out	0x3f, r0	; 63
				displaymode = SHOW_TIME;
     b0e:	10 92 e3 02 	sts	0x02E3, r1
     b12:	4d c0       	rjmp	.+154    	; 0xbae <set_alarm+0x1ca>
				return;
			}
		}
		if ((just_pressed & 0x4) || (pressed & 0x4)) {
     b14:	80 91 48 02 	lds	r24, 0x0248
     b18:	82 fd       	sbrc	r24, 2
     b1a:	04 c0       	rjmp	.+8      	; 0xb24 <set_alarm+0x140>
     b1c:	80 91 49 02 	lds	r24, 0x0249
     b20:	82 ff       	sbrs	r24, 2
     b22:	6e cf       	rjmp	.-292    	; 0xa00 <set_alarm+0x1c>
			just_pressed = 0;
     b24:	10 92 48 02 	sts	0x0248, r1

			if (mode == SET_HOUR) {
     b28:	81 e0       	ldi	r24, 0x01	; 1
     b2a:	f8 16       	cp	r15, r24
     b2c:	b1 f4       	brne	.+44     	; 0xb5a <set_alarm+0x176>
				hour = (hour+1) % 24;
     b2e:	81 2f       	mov	r24, r17
     b30:	90 e0       	ldi	r25, 0x00	; 0
     b32:	01 96       	adiw	r24, 0x01	; 1
     b34:	68 e1       	ldi	r22, 0x18	; 24
     b36:	70 e0       	ldi	r23, 0x00	; 0
     b38:	0e 94 48 1b 	call	0x3690	; 0x3690 <__divmodhi4>
     b3c:	18 2f       	mov	r17, r24
				display_alarm(hour, min);
     b3e:	60 2f       	mov	r22, r16
     b40:	0e 94 72 04 	call	0x8e4	; 0x8e4 <display_alarm>
				display[1] |= 0x1;
     b44:	80 91 d6 02 	lds	r24, 0x02D6
     b48:	81 60       	ori	r24, 0x01	; 1
     b4a:	80 93 d6 02 	sts	0x02D6, r24
				display[2] |= 0x1;
     b4e:	80 91 d7 02 	lds	r24, 0x02D7
     b52:	81 60       	ori	r24, 0x01	; 1
     b54:	80 93 d7 02 	sts	0x02D7, r24
     b58:	19 c0       	rjmp	.+50     	; 0xb8c <set_alarm+0x1a8>
			}
			if (mode == SET_MIN) {
     b5a:	82 e0       	ldi	r24, 0x02	; 2
     b5c:	f8 16       	cp	r15, r24
     b5e:	b1 f4       	brne	.+44     	; 0xb8c <set_alarm+0x1a8>
				min = (min+1) % 60;
     b60:	80 2f       	mov	r24, r16
     b62:	90 e0       	ldi	r25, 0x00	; 0
     b64:	01 96       	adiw	r24, 0x01	; 1
     b66:	6c e3       	ldi	r22, 0x3C	; 60
     b68:	70 e0       	ldi	r23, 0x00	; 0
     b6a:	0e 94 48 1b 	call	0x3690	; 0x3690 <__divmodhi4>
     b6e:	08 2f       	mov	r16, r24
				display_alarm(hour, min);
     b70:	81 2f       	mov	r24, r17
     b72:	60 2f       	mov	r22, r16
     b74:	0e 94 72 04 	call	0x8e4	; 0x8e4 <display_alarm>
				display[4] |= 0x1;
     b78:	80 91 d9 02 	lds	r24, 0x02D9
     b7c:	81 60       	ori	r24, 0x01	; 1
     b7e:	80 93 d9 02 	sts	0x02D9, r24
				display[5] |= 0x1;
     b82:	80 91 da 02 	lds	r24, 0x02DA
     b86:	81 60       	ori	r24, 0x01	; 1
     b88:	80 93 da 02 	sts	0x02DA, r24
			}

			if (pressed & 0x4)
     b8c:	80 91 49 02 	lds	r24, 0x0249
     b90:	82 ff       	sbrs	r24, 2
     b92:	36 cf       	rjmp	.-404    	; 0xa00 <set_alarm+0x1c>

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
     b94:	78 94       	sei

	milliseconds = 0;
     b96:	10 92 46 02 	sts	0x0246, r1
     b9a:	10 92 45 02 	sts	0x0245, r1
	while (milliseconds < ms);
     b9e:	80 91 45 02 	lds	r24, 0x0245
     ba2:	90 91 46 02 	lds	r25, 0x0246
     ba6:	8b 34       	cpi	r24, 0x4B	; 75
     ba8:	91 05       	cpc	r25, r1
     baa:	c8 f3       	brcs	.-14     	; 0xb9e <set_alarm+0x1ba>
     bac:	29 cf       	rjmp	.-430    	; 0xa00 <set_alarm+0x1c>

			if (pressed & 0x4)
				delayms(75);
		}
	}
}
     bae:	1f 91       	pop	r17
     bb0:	0f 91       	pop	r16
     bb2:	ff 90       	pop	r15
     bb4:	ef 90       	pop	r14
     bb6:	08 95       	ret

00000bb8 <display_timezone>:
		display[1] =  pgm_read_byte(numbertable_p + ( (((h+23)%24)+1) / 10));
	}
}

// Kinda like display_time but just hours and minutes allows negative hours.
void display_timezone(int8_t h, uint8_t m){ 
     bb8:	48 2f       	mov	r20, r24
     bba:	26 2f       	mov	r18, r22
	display[8] = pgm_read_byte(alphatable_p + 'c' - 'a');
     bbc:	ea e6       	ldi	r30, 0x6A	; 106
     bbe:	f0 e0       	ldi	r31, 0x00	; 0
     bc0:	84 91       	lpm	r24, Z+
     bc2:	80 93 dd 02 	sts	0x02DD, r24
	display[7] = pgm_read_byte(alphatable_p + 't' - 'a');
     bc6:	71 96       	adiw	r30, 0x11	; 17
     bc8:	84 91       	lpm	r24, Z+
     bca:	80 93 dc 02 	sts	0x02DC, r24
	display[6] = pgm_read_byte(alphatable_p + 'u' - 'a');
     bce:	31 96       	adiw	r30, 0x01	; 1
     bd0:	e4 91       	lpm	r30, Z+
     bd2:	e0 93 db 02 	sts	0x02DB, r30
	display[5] = pgm_read_byte(numbertable_p + (m % 10));
     bd6:	86 2f       	mov	r24, r22
     bd8:	6a e0       	ldi	r22, 0x0A	; 10
     bda:	0e 94 1b 1b 	call	0x3636	; 0x3636 <__udivmodqi4>
     bde:	e9 2f       	mov	r30, r25
     be0:	f0 e0       	ldi	r31, 0x00	; 0
     be2:	ec 57       	subi	r30, 0x7C	; 124
     be4:	ff 4f       	sbci	r31, 0xFF	; 255
     be6:	e4 91       	lpm	r30, Z+
     be8:	e0 93 da 02 	sts	0x02DA, r30
	display[4] = pgm_read_byte(numbertable_p + (m / 10)); 
     bec:	82 2f       	mov	r24, r18
     bee:	0e 94 1b 1b 	call	0x3636	; 0x3636 <__udivmodqi4>
     bf2:	e8 2f       	mov	r30, r24
     bf4:	f0 e0       	ldi	r31, 0x00	; 0
     bf6:	ec 57       	subi	r30, 0x7C	; 124
     bf8:	ff 4f       	sbci	r31, 0xFF	; 255
     bfa:	e4 91       	lpm	r30, Z+
     bfc:	e0 93 d9 02 	sts	0x02D9, r30
	display[3] = 0;
     c00:	10 92 d8 02 	sts	0x02D8, r1
	display[2] = pgm_read_byte(numbertable_p + (abs(h) % 10));
     c04:	24 2f       	mov	r18, r20
     c06:	33 27       	eor	r19, r19
     c08:	27 fd       	sbrc	r18, 7
     c0a:	30 95       	com	r19
     c0c:	37 ff       	sbrs	r19, 7
     c0e:	03 c0       	rjmp	.+6      	; 0xc16 <display_timezone+0x5e>
     c10:	30 95       	com	r19
     c12:	21 95       	neg	r18
     c14:	3f 4f       	sbci	r19, 0xFF	; 255
     c16:	c9 01       	movw	r24, r18
     c18:	6a e0       	ldi	r22, 0x0A	; 10
     c1a:	70 e0       	ldi	r23, 0x00	; 0
     c1c:	0e 94 48 1b 	call	0x3690	; 0x3690 <__divmodhi4>
     c20:	fc 01       	movw	r30, r24
     c22:	ec 57       	subi	r30, 0x7C	; 124
     c24:	ff 4f       	sbci	r31, 0xFF	; 255
     c26:	e4 91       	lpm	r30, Z+
     c28:	e0 93 d7 02 	sts	0x02D7, r30
	display[1] = pgm_read_byte(numbertable_p + (abs(h) / 10));
     c2c:	c9 01       	movw	r24, r18
     c2e:	6a e0       	ldi	r22, 0x0A	; 10
     c30:	70 e0       	ldi	r23, 0x00	; 0
     c32:	0e 94 48 1b 	call	0x3690	; 0x3690 <__divmodhi4>
     c36:	fb 01       	movw	r30, r22
     c38:	ec 57       	subi	r30, 0x7C	; 124
     c3a:	ff 4f       	sbci	r31, 0xFF	; 255
     c3c:	e4 91       	lpm	r30, Z+
     c3e:	e0 93 d6 02 	sts	0x02D6, r30
	// We use the '-' as a negative sign
	if (h >= 0)
     c42:	47 fd       	sbrc	r20, 7
     c44:	04 c0       	rjmp	.+8      	; 0xc4e <display_timezone+0x96>
		display[0] &= ~0x2;  // positive numbers, implicit sign
     c46:	80 91 d5 02 	lds	r24, 0x02D5
     c4a:	8d 7f       	andi	r24, 0xFD	; 253
     c4c:	03 c0       	rjmp	.+6      	; 0xc54 <display_timezone+0x9c>
	else 
		display[0] |= 0x2;  // negative numbers, display negative sign
     c4e:	80 91 d5 02 	lds	r24, 0x02D5
     c52:	82 60       	ori	r24, 0x02	; 2
     c54:	80 93 d5 02 	sts	0x02D5, r24
     c58:	08 95       	ret

00000c5a <display_str>:

}

// display words (menus, prompts, etc)
void display_str(char *s) {
     c5a:	cf 93       	push	r28
     c5c:	df 93       	push	r29
	uint8_t i;

	// don't use the lefthand dot/slash digit
	display[0] = 0;
     c5e:	10 92 d5 02 	sts	0x02D5, r1
     c62:	ec 01       	movw	r28, r24
     c64:	a6 ed       	ldi	r26, 0xD6	; 214
     c66:	b2 e0       	ldi	r27, 0x02	; 2

	// up to 8 characters
	for (i=1; i<9; i++) {
		// check for null-termination
		if (s[i-1] == 0)
     c68:	e8 81       	ld	r30, Y
     c6a:	ee 23       	and	r30, r30
     c6c:	d1 f0       	breq	.+52     	; 0xca2 <display_str+0x48>
			return;

		// Numbers and leters are looked up in the font table!
		if ((s[i-1] >= 'a') && (s[i-1] <= 'z')) {
     c6e:	8e 2f       	mov	r24, r30
     c70:	81 56       	subi	r24, 0x61	; 97
     c72:	8a 31       	cpi	r24, 0x1A	; 26
     c74:	28 f4       	brcc	.+10     	; 0xc80 <display_str+0x26>
			display[i] =  pgm_read_byte(alphatable_p + s[i-1] - 'a');
     c76:	f0 e0       	ldi	r31, 0x00	; 0
     c78:	e9 5f       	subi	r30, 0xF9	; 249
     c7a:	ff 4f       	sbci	r31, 0xFF	; 255
     c7c:	e4 91       	lpm	r30, Z+
     c7e:	08 c0       	rjmp	.+16     	; 0xc90 <display_str+0x36>
		} else if ((s[i-1] >= '0') && (s[i-1] <= '9')) {
     c80:	8e 2f       	mov	r24, r30
     c82:	80 53       	subi	r24, 0x30	; 48
     c84:	8a 30       	cpi	r24, 0x0A	; 10
     c86:	30 f4       	brcc	.+12     	; 0xc94 <display_str+0x3a>
			display[i] =  pgm_read_byte(numbertable_p + s[i-1] - '0');
     c88:	f0 e0       	ldi	r31, 0x00	; 0
     c8a:	ec 5a       	subi	r30, 0xAC	; 172
     c8c:	ff 4f       	sbci	r31, 0xFF	; 255
     c8e:	e4 91       	lpm	r30, Z+
     c90:	ec 93       	st	X, r30
     c92:	01 c0       	rjmp	.+2      	; 0xc96 <display_str+0x3c>
		} else {
			display[i] = 0;      // spaces and other stuff are ignored :(
     c94:	1c 92       	st	X, r1
     c96:	21 96       	adiw	r28, 0x01	; 1
     c98:	11 96       	adiw	r26, 0x01	; 1

	// don't use the lefthand dot/slash digit
	display[0] = 0;

	// up to 8 characters
	for (i=1; i<9; i++) {
     c9a:	82 e0       	ldi	r24, 0x02	; 2
     c9c:	ae 3d       	cpi	r26, 0xDE	; 222
     c9e:	b8 07       	cpc	r27, r24
     ca0:	19 f7       	brne	.-58     	; 0xc68 <display_str+0xe>
			display[i] =  pgm_read_byte(numbertable_p + s[i-1] - '0');
		} else {
			display[i] = 0;      // spaces and other stuff are ignored :(
		}
	}
}
     ca2:	df 91       	pop	r29
     ca4:	cf 91       	pop	r28
     ca6:	08 95       	ret

00000ca8 <display_date>:
}

/**************************** DISPLAY *****************************/

// We can display the current date!
void display_date(uint8_t style) {
     ca8:	cf 93       	push	r28
     caa:	df 93       	push	r29

	// This type is mm-dd-yy OR dd-mm-yy depending on our pref.
	if (style == DATE) {
     cac:	88 23       	and	r24, r24
     cae:	09 f0       	breq	.+2      	; 0xcb2 <display_date+0xa>
     cb0:	96 c0       	rjmp	.+300    	; 0xdde <display_date+0x136>
		display[0] = 0;
     cb2:	10 92 d5 02 	sts	0x02D5, r1
		display[6] = display[3] = 0x02;     // put dashes between num
     cb6:	82 e0       	ldi	r24, 0x02	; 2
     cb8:	80 93 d8 02 	sts	0x02D8, r24
     cbc:	80 93 db 02 	sts	0x02DB, r24

		if (region == REGION_US) {
     cc0:	80 91 38 02 	lds	r24, 0x0238
     cc4:	88 23       	and	r24, r24
     cc6:	09 f0       	breq	.+2      	; 0xcca <display_date+0x22>
     cc8:	37 c0       	rjmp	.+110    	; 0xd38 <display_date+0x90>
			// mm-dd-yy
			display[1] = pgm_read_byte(numbertable_p + (date_m / 10));
     cca:	80 91 e4 02 	lds	r24, 0x02E4
     cce:	6a e0       	ldi	r22, 0x0A	; 10
     cd0:	0e 94 27 1b 	call	0x364e	; 0x364e <__divmodqi4>
     cd4:	e8 2f       	mov	r30, r24
     cd6:	ff 27       	eor	r31, r31
     cd8:	e7 fd       	sbrc	r30, 7
     cda:	f0 95       	com	r31
     cdc:	ec 57       	subi	r30, 0x7C	; 124
     cde:	ff 4f       	sbci	r31, 0xFF	; 255
     ce0:	e4 91       	lpm	r30, Z+
     ce2:	e0 93 d6 02 	sts	0x02D6, r30
			display[2] = pgm_read_byte(numbertable_p + (date_m % 10));
     ce6:	80 91 e4 02 	lds	r24, 0x02E4
     cea:	6a e0       	ldi	r22, 0x0A	; 10
     cec:	0e 94 27 1b 	call	0x364e	; 0x364e <__divmodqi4>
     cf0:	e9 2f       	mov	r30, r25
     cf2:	ff 27       	eor	r31, r31
     cf4:	e7 fd       	sbrc	r30, 7
     cf6:	f0 95       	com	r31
     cf8:	ec 57       	subi	r30, 0x7C	; 124
     cfa:	ff 4f       	sbci	r31, 0xFF	; 255
     cfc:	e4 91       	lpm	r30, Z+
     cfe:	e0 93 d7 02 	sts	0x02D7, r30
			display[4] = pgm_read_byte(numbertable_p + (date_d / 10));
     d02:	80 91 d4 02 	lds	r24, 0x02D4
     d06:	6a e0       	ldi	r22, 0x0A	; 10
     d08:	0e 94 27 1b 	call	0x364e	; 0x364e <__divmodqi4>
     d0c:	e8 2f       	mov	r30, r24
     d0e:	ff 27       	eor	r31, r31
     d10:	e7 fd       	sbrc	r30, 7
     d12:	f0 95       	com	r31
     d14:	ec 57       	subi	r30, 0x7C	; 124
     d16:	ff 4f       	sbci	r31, 0xFF	; 255
     d18:	e4 91       	lpm	r30, Z+
     d1a:	e0 93 d9 02 	sts	0x02D9, r30
			display[5] = pgm_read_byte(numbertable_p + (date_d % 10));
     d1e:	80 91 d4 02 	lds	r24, 0x02D4
     d22:	6a e0       	ldi	r22, 0x0A	; 10
     d24:	0e 94 27 1b 	call	0x364e	; 0x364e <__divmodqi4>
     d28:	e9 2f       	mov	r30, r25
     d2a:	ff 27       	eor	r31, r31
     d2c:	e7 fd       	sbrc	r30, 7
     d2e:	f0 95       	com	r31
     d30:	ec 57       	subi	r30, 0x7C	; 124
     d32:	ff 4f       	sbci	r31, 0xFF	; 255
     d34:	e4 91       	lpm	r30, Z+
     d36:	36 c0       	rjmp	.+108    	; 0xda4 <display_date+0xfc>
		} else {
			// dd-mm-yy
			display[1] = pgm_read_byte(numbertable_p + (date_d / 10));
     d38:	80 91 d4 02 	lds	r24, 0x02D4
     d3c:	6a e0       	ldi	r22, 0x0A	; 10
     d3e:	0e 94 27 1b 	call	0x364e	; 0x364e <__divmodqi4>
     d42:	e8 2f       	mov	r30, r24
     d44:	ff 27       	eor	r31, r31
     d46:	e7 fd       	sbrc	r30, 7
     d48:	f0 95       	com	r31
     d4a:	ec 57       	subi	r30, 0x7C	; 124
     d4c:	ff 4f       	sbci	r31, 0xFF	; 255
     d4e:	e4 91       	lpm	r30, Z+
     d50:	e0 93 d6 02 	sts	0x02D6, r30
			display[2] = pgm_read_byte(numbertable_p + (date_d % 10));
     d54:	80 91 d4 02 	lds	r24, 0x02D4
     d58:	6a e0       	ldi	r22, 0x0A	; 10
     d5a:	0e 94 27 1b 	call	0x364e	; 0x364e <__divmodqi4>
     d5e:	e9 2f       	mov	r30, r25
     d60:	ff 27       	eor	r31, r31
     d62:	e7 fd       	sbrc	r30, 7
     d64:	f0 95       	com	r31
     d66:	ec 57       	subi	r30, 0x7C	; 124
     d68:	ff 4f       	sbci	r31, 0xFF	; 255
     d6a:	e4 91       	lpm	r30, Z+
     d6c:	e0 93 d7 02 	sts	0x02D7, r30
			display[4] = pgm_read_byte(numbertable_p + (date_m / 10));
     d70:	80 91 e4 02 	lds	r24, 0x02E4
     d74:	6a e0       	ldi	r22, 0x0A	; 10
     d76:	0e 94 27 1b 	call	0x364e	; 0x364e <__divmodqi4>
     d7a:	e8 2f       	mov	r30, r24
     d7c:	ff 27       	eor	r31, r31
     d7e:	e7 fd       	sbrc	r30, 7
     d80:	f0 95       	com	r31
     d82:	ec 57       	subi	r30, 0x7C	; 124
     d84:	ff 4f       	sbci	r31, 0xFF	; 255
     d86:	e4 91       	lpm	r30, Z+
     d88:	e0 93 d9 02 	sts	0x02D9, r30
			display[5] = pgm_read_byte(numbertable_p + (date_m % 10));
     d8c:	80 91 e4 02 	lds	r24, 0x02E4
     d90:	6a e0       	ldi	r22, 0x0A	; 10
     d92:	0e 94 27 1b 	call	0x364e	; 0x364e <__divmodqi4>
     d96:	e9 2f       	mov	r30, r25
     d98:	ff 27       	eor	r31, r31
     d9a:	e7 fd       	sbrc	r30, 7
     d9c:	f0 95       	com	r31
     d9e:	ec 57       	subi	r30, 0x7C	; 124
     da0:	ff 4f       	sbci	r31, 0xFF	; 255
     da2:	e4 91       	lpm	r30, Z+
     da4:	e0 93 da 02 	sts	0x02DA, r30
		}
		// the yy part is the same
		display[7] = pgm_read_byte(numbertable_p + (date_y / 10));
     da8:	80 91 d1 02 	lds	r24, 0x02D1
     dac:	6a e0       	ldi	r22, 0x0A	; 10
     dae:	0e 94 27 1b 	call	0x364e	; 0x364e <__divmodqi4>
     db2:	e8 2f       	mov	r30, r24
     db4:	ff 27       	eor	r31, r31
     db6:	e7 fd       	sbrc	r30, 7
     db8:	f0 95       	com	r31
     dba:	ec 57       	subi	r30, 0x7C	; 124
     dbc:	ff 4f       	sbci	r31, 0xFF	; 255
     dbe:	e4 91       	lpm	r30, Z+
     dc0:	e0 93 dc 02 	sts	0x02DC, r30
		display[8] = pgm_read_byte(numbertable_p + (date_y % 10));
     dc4:	80 91 d1 02 	lds	r24, 0x02D1
     dc8:	6a e0       	ldi	r22, 0x0A	; 10
     dca:	0e 94 27 1b 	call	0x364e	; 0x364e <__divmodqi4>
     dce:	e9 2f       	mov	r30, r25
     dd0:	ff 27       	eor	r31, r31
     dd2:	e7 fd       	sbrc	r30, 7
     dd4:	f0 95       	com	r31
     dd6:	ec 57       	subi	r30, 0x7C	; 124
     dd8:	ff 4f       	sbci	r31, 0xFF	; 255
     dda:	e4 91       	lpm	r30, Z+
     ddc:	ee c0       	rjmp	.+476    	; 0xfba <display_date+0x312>

	} else if (style == DAY) {
     dde:	81 30       	cpi	r24, 0x01	; 1
     de0:	09 f0       	breq	.+2      	; 0xde4 <display_date+0x13c>
     de2:	ed c0       	rjmp	.+474    	; 0xfbe <display_date+0x316>
		uint16_t month, year;
		uint8_t dotw;

		// Calculate day of the week

		month = date_m;
     de4:	80 91 e4 02 	lds	r24, 0x02E4
     de8:	c8 2f       	mov	r28, r24
     dea:	dd 27       	eor	r29, r29
     dec:	c7 fd       	sbrc	r28, 7
     dee:	d0 95       	com	r29
		year = 2000 + date_y;
     df0:	80 91 d1 02 	lds	r24, 0x02D1
     df4:	e8 2f       	mov	r30, r24
     df6:	ff 27       	eor	r31, r31
     df8:	e7 fd       	sbrc	r30, 7
     dfa:	f0 95       	com	r31
     dfc:	e0 53       	subi	r30, 0x30	; 48
     dfe:	f8 4f       	sbci	r31, 0xF8	; 248
		if (date_m < 3)  {
     e00:	80 91 e4 02 	lds	r24, 0x02E4
     e04:	83 30       	cpi	r24, 0x03	; 3
     e06:	14 f4       	brge	.+4      	; 0xe0c <display_date+0x164>
			month += 12;
     e08:	2c 96       	adiw	r28, 0x0c	; 12
			year -= 1;
     e0a:	31 97       	sbiw	r30, 0x01	; 1
		}
		dotw = (date_d + (2 * month) + (6 * (month+1)/10) + year + (year/4) - (year/100) + (year/400) + 1) % 7;
     e0c:	20 91 d4 02 	lds	r18, 0x02D4

		// Display the day first
		display[8] = display[7] = 0;
     e10:	10 92 dc 02 	sts	0x02DC, r1
     e14:	10 92 dd 02 	sts	0x02DD, r1
		switch (dotw) {
     e18:	33 27       	eor	r19, r19
     e1a:	27 fd       	sbrc	r18, 7
     e1c:	30 95       	com	r19
     e1e:	2f 5f       	subi	r18, 0xFF	; 255
     e20:	3f 4f       	sbci	r19, 0xFF	; 255
     e22:	2e 0f       	add	r18, r30
     e24:	3f 1f       	adc	r19, r31
     e26:	ce 01       	movw	r24, r28
     e28:	88 0f       	add	r24, r24
     e2a:	99 1f       	adc	r25, r25
     e2c:	28 0f       	add	r18, r24
     e2e:	39 1f       	adc	r19, r25
     e30:	cf 01       	movw	r24, r30
     e32:	96 95       	lsr	r25
     e34:	87 95       	ror	r24
     e36:	96 95       	lsr	r25
     e38:	87 95       	ror	r24
     e3a:	28 0f       	add	r18, r24
     e3c:	39 1f       	adc	r19, r25
     e3e:	cf 01       	movw	r24, r30
     e40:	60 e9       	ldi	r22, 0x90	; 144
     e42:	71 e0       	ldi	r23, 0x01	; 1
     e44:	0e 94 34 1b 	call	0x3668	; 0x3668 <__udivmodhi4>
     e48:	26 0f       	add	r18, r22
     e4a:	37 1f       	adc	r19, r23
     e4c:	cf 01       	movw	r24, r30
     e4e:	64 e6       	ldi	r22, 0x64	; 100
     e50:	70 e0       	ldi	r23, 0x00	; 0
     e52:	0e 94 34 1b 	call	0x3668	; 0x3668 <__udivmodhi4>
     e56:	26 1b       	sub	r18, r22
     e58:	37 0b       	sbc	r19, r23
     e5a:	ae 01       	movw	r20, r28
     e5c:	4f 5f       	subi	r20, 0xFF	; 255
     e5e:	5f 4f       	sbci	r21, 0xFF	; 255
     e60:	ca 01       	movw	r24, r20
     e62:	88 0f       	add	r24, r24
     e64:	99 1f       	adc	r25, r25
     e66:	84 0f       	add	r24, r20
     e68:	95 1f       	adc	r25, r21
     e6a:	88 0f       	add	r24, r24
     e6c:	99 1f       	adc	r25, r25
     e6e:	6a e0       	ldi	r22, 0x0A	; 10
     e70:	70 e0       	ldi	r23, 0x00	; 0
     e72:	0e 94 34 1b 	call	0x3668	; 0x3668 <__udivmodhi4>
     e76:	c9 01       	movw	r24, r18
     e78:	86 0f       	add	r24, r22
     e7a:	97 1f       	adc	r25, r23
     e7c:	67 e0       	ldi	r22, 0x07	; 7
     e7e:	70 e0       	ldi	r23, 0x00	; 0
     e80:	0e 94 34 1b 	call	0x3668	; 0x3668 <__udivmodhi4>
     e84:	83 30       	cpi	r24, 0x03	; 3
     e86:	b9 f0       	breq	.+46     	; 0xeb6 <display_date+0x20e>
     e88:	84 30       	cpi	r24, 0x04	; 4
     e8a:	28 f4       	brcc	.+10     	; 0xe96 <display_date+0x1ee>
     e8c:	81 30       	cpi	r24, 0x01	; 1
     e8e:	69 f0       	breq	.+26     	; 0xeaa <display_date+0x202>
     e90:	82 30       	cpi	r24, 0x02	; 2
     e92:	70 f4       	brcc	.+28     	; 0xeb0 <display_date+0x208>
     e94:	07 c0       	rjmp	.+14     	; 0xea4 <display_date+0x1fc>
     e96:	85 30       	cpi	r24, 0x05	; 5
     e98:	a1 f0       	breq	.+40     	; 0xec2 <display_date+0x21a>
     e9a:	85 30       	cpi	r24, 0x05	; 5
     e9c:	78 f0       	brcs	.+30     	; 0xebc <display_date+0x214>
     e9e:	86 30       	cpi	r24, 0x06	; 6
     ea0:	b9 f4       	brne	.+46     	; 0xed0 <display_date+0x228>
     ea2:	12 c0       	rjmp	.+36     	; 0xec8 <display_date+0x220>
			case 0:
				display_str("sunday"); break;
     ea4:	80 e0       	ldi	r24, 0x00	; 0
     ea6:	91 e0       	ldi	r25, 0x01	; 1
     ea8:	11 c0       	rjmp	.+34     	; 0xecc <display_date+0x224>
			case 1:
				display_str("monday"); break;
     eaa:	87 e0       	ldi	r24, 0x07	; 7
     eac:	91 e0       	ldi	r25, 0x01	; 1
     eae:	0e c0       	rjmp	.+28     	; 0xecc <display_date+0x224>
			case 2:
				display_str("tuesday"); break;
     eb0:	8e e0       	ldi	r24, 0x0E	; 14
     eb2:	91 e0       	ldi	r25, 0x01	; 1
     eb4:	0b c0       	rjmp	.+22     	; 0xecc <display_date+0x224>
			case 3:
				display_str("wednsday"); break;
     eb6:	86 e1       	ldi	r24, 0x16	; 22
     eb8:	91 e0       	ldi	r25, 0x01	; 1
     eba:	08 c0       	rjmp	.+16     	; 0xecc <display_date+0x224>
			case 4:
				display_str("thursday"); break;
     ebc:	8f e1       	ldi	r24, 0x1F	; 31
     ebe:	91 e0       	ldi	r25, 0x01	; 1
     ec0:	05 c0       	rjmp	.+10     	; 0xecc <display_date+0x224>
			case 5:
				display_str("friday"); break;
     ec2:	88 e2       	ldi	r24, 0x28	; 40
     ec4:	91 e0       	ldi	r25, 0x01	; 1
     ec6:	02 c0       	rjmp	.+4      	; 0xecc <display_date+0x224>
			case 6:
				display_str("saturday"); break;
     ec8:	8f e2       	ldi	r24, 0x2F	; 47
     eca:	91 e0       	ldi	r25, 0x01	; 1
     ecc:	0e 94 2d 06 	call	0xc5a	; 0xc5a <display_str>

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
     ed0:	78 94       	sei

	milliseconds = 0;
     ed2:	10 92 46 02 	sts	0x0246, r1
     ed6:	10 92 45 02 	sts	0x0245, r1
	while (milliseconds < ms);
     eda:	80 91 45 02 	lds	r24, 0x0245
     ede:	90 91 46 02 	lds	r25, 0x0246
     ee2:	88 5e       	subi	r24, 0xE8	; 232
     ee4:	93 40       	sbci	r25, 0x03	; 3
     ee6:	c8 f3       	brcs	.-14     	; 0xeda <display_date+0x232>

		// wait one seconds about
		delayms(1000);

		// Then display the month and date
		display[6] = display[5] = display[4] = 0;
     ee8:	10 92 d9 02 	sts	0x02D9, r1
     eec:	10 92 da 02 	sts	0x02DA, r1
     ef0:	10 92 db 02 	sts	0x02DB, r1
		switch (date_m) {
     ef4:	80 91 e4 02 	lds	r24, 0x02E4
     ef8:	86 30       	cpi	r24, 0x06	; 6
     efa:	79 f1       	breq	.+94     	; 0xf5a <display_date+0x2b2>
     efc:	87 30       	cpi	r24, 0x07	; 7
     efe:	74 f4       	brge	.+28     	; 0xf1c <display_date+0x274>
     f00:	83 30       	cpi	r24, 0x03	; 3
     f02:	11 f1       	breq	.+68     	; 0xf48 <display_date+0x2a0>
     f04:	84 30       	cpi	r24, 0x04	; 4
     f06:	2c f4       	brge	.+10     	; 0xf12 <display_date+0x26a>
     f08:	81 30       	cpi	r24, 0x01	; 1
     f0a:	c1 f0       	breq	.+48     	; 0xf3c <display_date+0x294>
     f0c:	82 30       	cpi	r24, 0x02	; 2
     f0e:	d9 f5       	brne	.+118    	; 0xf86 <display_date+0x2de>
     f10:	18 c0       	rjmp	.+48     	; 0xf42 <display_date+0x29a>
     f12:	84 30       	cpi	r24, 0x04	; 4
     f14:	e1 f0       	breq	.+56     	; 0xf4e <display_date+0x2a6>
     f16:	85 30       	cpi	r24, 0x05	; 5
     f18:	b1 f5       	brne	.+108    	; 0xf86 <display_date+0x2de>
     f1a:	1c c0       	rjmp	.+56     	; 0xf54 <display_date+0x2ac>
     f1c:	89 30       	cpi	r24, 0x09	; 9
     f1e:	31 f1       	breq	.+76     	; 0xf6c <display_date+0x2c4>
     f20:	8a 30       	cpi	r24, 0x0A	; 10
     f22:	2c f4       	brge	.+10     	; 0xf2e <display_date+0x286>
     f24:	87 30       	cpi	r24, 0x07	; 7
     f26:	e1 f0       	breq	.+56     	; 0xf60 <display_date+0x2b8>
     f28:	88 30       	cpi	r24, 0x08	; 8
     f2a:	69 f5       	brne	.+90     	; 0xf86 <display_date+0x2de>
     f2c:	1c c0       	rjmp	.+56     	; 0xf66 <display_date+0x2be>
     f2e:	8b 30       	cpi	r24, 0x0B	; 11
     f30:	19 f1       	breq	.+70     	; 0xf78 <display_date+0x2d0>
     f32:	8b 30       	cpi	r24, 0x0B	; 11
     f34:	f4 f0       	brlt	.+60     	; 0xf72 <display_date+0x2ca>
     f36:	8c 30       	cpi	r24, 0x0C	; 12
     f38:	31 f5       	brne	.+76     	; 0xf86 <display_date+0x2de>
     f3a:	21 c0       	rjmp	.+66     	; 0xf7e <display_date+0x2d6>
			case 1:
				display_str("jan"); break;
     f3c:	88 e3       	ldi	r24, 0x38	; 56
     f3e:	91 e0       	ldi	r25, 0x01	; 1
     f40:	20 c0       	rjmp	.+64     	; 0xf82 <display_date+0x2da>
			case 2:
				display_str("feb"); break;
     f42:	8c e3       	ldi	r24, 0x3C	; 60
     f44:	91 e0       	ldi	r25, 0x01	; 1
     f46:	1d c0       	rjmp	.+58     	; 0xf82 <display_date+0x2da>
			case 3:
				display_str("march"); break;
     f48:	80 e4       	ldi	r24, 0x40	; 64
     f4a:	91 e0       	ldi	r25, 0x01	; 1
     f4c:	1a c0       	rjmp	.+52     	; 0xf82 <display_date+0x2da>
			case 4:
				display_str("april"); break;
     f4e:	86 e4       	ldi	r24, 0x46	; 70
     f50:	91 e0       	ldi	r25, 0x01	; 1
     f52:	17 c0       	rjmp	.+46     	; 0xf82 <display_date+0x2da>
			case 5:
				display_str("may"); break;
     f54:	8c e4       	ldi	r24, 0x4C	; 76
     f56:	91 e0       	ldi	r25, 0x01	; 1
     f58:	14 c0       	rjmp	.+40     	; 0xf82 <display_date+0x2da>
			case 6:
				display_str("june"); break;
     f5a:	80 e5       	ldi	r24, 0x50	; 80
     f5c:	91 e0       	ldi	r25, 0x01	; 1
     f5e:	11 c0       	rjmp	.+34     	; 0xf82 <display_date+0x2da>
			case 7:
				display_str("july"); break;
     f60:	85 e5       	ldi	r24, 0x55	; 85
     f62:	91 e0       	ldi	r25, 0x01	; 1
     f64:	0e c0       	rjmp	.+28     	; 0xf82 <display_date+0x2da>
			case 8:
				display_str("augst"); break;
     f66:	8a e5       	ldi	r24, 0x5A	; 90
     f68:	91 e0       	ldi	r25, 0x01	; 1
     f6a:	0b c0       	rjmp	.+22     	; 0xf82 <display_date+0x2da>
			case 9:
				display_str("sept"); break;
     f6c:	80 e6       	ldi	r24, 0x60	; 96
     f6e:	91 e0       	ldi	r25, 0x01	; 1
     f70:	08 c0       	rjmp	.+16     	; 0xf82 <display_date+0x2da>
			case 10:
				display_str("octob"); break;
     f72:	85 e6       	ldi	r24, 0x65	; 101
     f74:	91 e0       	ldi	r25, 0x01	; 1
     f76:	05 c0       	rjmp	.+10     	; 0xf82 <display_date+0x2da>
			case 11:
				display_str("novem"); break;
     f78:	8b e6       	ldi	r24, 0x6B	; 107
     f7a:	91 e0       	ldi	r25, 0x01	; 1
     f7c:	02 c0       	rjmp	.+4      	; 0xf82 <display_date+0x2da>
			case 12:
				display_str("decem"); break;
     f7e:	81 e7       	ldi	r24, 0x71	; 113
     f80:	91 e0       	ldi	r25, 0x01	; 1
     f82:	0e 94 2d 06 	call	0xc5a	; 0xc5a <display_str>
		}
		display[7] = pgm_read_byte(numbertable_p + (date_d / 10));
     f86:	80 91 d4 02 	lds	r24, 0x02D4
     f8a:	6a e0       	ldi	r22, 0x0A	; 10
     f8c:	0e 94 27 1b 	call	0x364e	; 0x364e <__divmodqi4>
     f90:	e8 2f       	mov	r30, r24
     f92:	ff 27       	eor	r31, r31
     f94:	e7 fd       	sbrc	r30, 7
     f96:	f0 95       	com	r31
     f98:	ec 57       	subi	r30, 0x7C	; 124
     f9a:	ff 4f       	sbci	r31, 0xFF	; 255
     f9c:	e4 91       	lpm	r30, Z+
     f9e:	e0 93 dc 02 	sts	0x02DC, r30
		display[8] = pgm_read_byte(numbertable_p + (date_d % 10));
     fa2:	80 91 d4 02 	lds	r24, 0x02D4
     fa6:	6a e0       	ldi	r22, 0x0A	; 10
     fa8:	0e 94 27 1b 	call	0x364e	; 0x364e <__divmodqi4>
     fac:	e9 2f       	mov	r30, r25
     fae:	ff 27       	eor	r31, r31
     fb0:	e7 fd       	sbrc	r30, 7
     fb2:	f0 95       	com	r31
     fb4:	ec 57       	subi	r30, 0x7C	; 124
     fb6:	ff 4f       	sbci	r31, 0xFF	; 255
     fb8:	e4 91       	lpm	r30, Z+
     fba:	e0 93 dd 02 	sts	0x02DD, r30

	}
}
     fbe:	df 91       	pop	r29
     fc0:	cf 91       	pop	r28
     fc2:	08 95       	ret

00000fc4 <set_region>:
			}
		}
	}
}

void set_region(void) {
     fc4:	0f 93       	push	r16
     fc6:	1f 93       	push	r17
     fc8:	cf 93       	push	r28
     fca:	df 93       	push	r29
	uint8_t mode = SHOW_MENU;

	timeoutcounter = INACTIVITYTIMEOUT;;  
     fcc:	8a e0       	ldi	r24, 0x0A	; 10
     fce:	80 93 4b 02 	sts	0x024B, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     fd2:	f9 99       	sbic	0x1f, 1	; 31
     fd4:	fe cf       	rjmp	.-4      	; 0xfd2 <set_region+0xe>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
     fd6:	8b e0       	ldi	r24, 0x0B	; 11
     fd8:	90 e0       	ldi	r25, 0x00	; 0
     fda:	92 bd       	out	0x22, r25	; 34
     fdc:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     fde:	f8 9a       	sbi	0x1f, 0	; 31
     fe0:	80 b5       	in	r24, 0x20	; 32
	region = eeprom_read_byte((uint8_t *)EE_REGION);
     fe2:	80 93 38 02 	sts	0x0238, r24
     fe6:	10 e0       	ldi	r17, 0x00	; 0

	while (1) {
		if (just_pressed || pressed) {
			timeoutcounter = INACTIVITYTIMEOUT;;  
     fe8:	0a e0       	ldi	r16, 0x0A	; 10
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
     fea:	cb e0       	ldi	r28, 0x0B	; 11
     fec:	d0 e0       	ldi	r29, 0x00	; 0
     fee:	01 c0       	rjmp	.+2      	; 0xff2 <set_region+0x2e>

void set_region(void) {
	uint8_t mode = SHOW_MENU;

	timeoutcounter = INACTIVITYTIMEOUT;;  
	region = eeprom_read_byte((uint8_t *)EE_REGION);
     ff0:	10 e0       	ldi	r17, 0x00	; 0

	while (1) {
		if (just_pressed || pressed) {
     ff2:	80 91 48 02 	lds	r24, 0x0248
     ff6:	88 23       	and	r24, r24
     ff8:	21 f4       	brne	.+8      	; 0x1002 <set_region+0x3e>
     ffa:	80 91 49 02 	lds	r24, 0x0249
     ffe:	88 23       	and	r24, r24
    1000:	19 f0       	breq	.+6      	; 0x1008 <set_region+0x44>
			timeoutcounter = INACTIVITYTIMEOUT;;  
    1002:	00 93 4b 02 	sts	0x024B, r16
    1006:	04 c0       	rjmp	.+8      	; 0x1010 <set_region+0x4c>
			// timeout w/no buttons pressed after 3 seconds?
		} else if (!timeoutcounter) {
    1008:	80 91 4b 02 	lds	r24, 0x024B
    100c:	88 23       	and	r24, r24
    100e:	c9 f0       	breq	.+50     	; 0x1042 <set_region+0x7e>
			//timed out!
			displaymode = SHOW_TIME;     
			return;
		}
		if (just_pressed & 0x1) { // mode change
    1010:	80 91 48 02 	lds	r24, 0x0248
    1014:	80 fd       	sbrc	r24, 0
    1016:	3f c0       	rjmp	.+126    	; 0x1096 <set_region+0xd2>
			return;
		}
		if (just_pressed & 0x2) {
    1018:	80 91 48 02 	lds	r24, 0x0248
    101c:	81 ff       	sbrs	r24, 1
    101e:	14 c0       	rjmp	.+40     	; 0x1048 <set_region+0x84>
			just_pressed = 0;
    1020:	10 92 48 02 	sts	0x0248, r1
			if (mode == SHOW_MENU) {
    1024:	11 23       	and	r17, r17
    1026:	69 f4       	brne	.+26     	; 0x1042 <set_region+0x7e>
				// start!
				mode = SET_REG;
				// display region
				if (region == REGION_US) {
    1028:	80 91 38 02 	lds	r24, 0x0238
    102c:	88 23       	and	r24, r24
    102e:	19 f4       	brne	.+6      	; 0x1036 <set_region+0x72>
					display_str("usa-12hr");
    1030:	87 e7       	ldi	r24, 0x77	; 119
    1032:	91 e0       	ldi	r25, 0x01	; 1
    1034:	02 c0       	rjmp	.+4      	; 0x103a <set_region+0x76>
				} else {
					display_str("eur-24hr");
    1036:	80 e8       	ldi	r24, 0x80	; 128
    1038:	91 e0       	ldi	r25, 0x01	; 1
    103a:	0e 94 2d 06 	call	0xc5a	; 0xc5a <display_str>
    103e:	11 e0       	ldi	r17, 0x01	; 1
    1040:	03 c0       	rjmp	.+6      	; 0x1048 <set_region+0x84>
				}
			} else {	
				displaymode = SHOW_TIME;
    1042:	10 92 e3 02 	sts	0x02E3, r1
    1046:	27 c0       	rjmp	.+78     	; 0x1096 <set_region+0xd2>
				return;
			}
		}
		if (just_pressed & 0x4) {
    1048:	80 91 48 02 	lds	r24, 0x0248
    104c:	82 ff       	sbrs	r24, 2
    104e:	d1 cf       	rjmp	.-94     	; 0xff2 <set_region+0x2e>
			just_pressed = 0;
    1050:	10 92 48 02 	sts	0x0248, r1
			if (mode == SET_REG) {
    1054:	11 30       	cpi	r17, 0x01	; 1
    1056:	61 f6       	brne	.-104    	; 0xff0 <set_region+0x2c>
				region = !region;
    1058:	90 e0       	ldi	r25, 0x00	; 0
    105a:	80 91 38 02 	lds	r24, 0x0238
    105e:	88 23       	and	r24, r24
    1060:	09 f4       	brne	.+2      	; 0x1064 <set_region+0xa0>
    1062:	91 e0       	ldi	r25, 0x01	; 1
    1064:	90 93 38 02 	sts	0x0238, r25
				if (region == REGION_US) {
    1068:	99 23       	and	r25, r25
    106a:	19 f4       	brne	.+6      	; 0x1072 <set_region+0xae>
					display_str("usa-12hr");
    106c:	87 e7       	ldi	r24, 0x77	; 119
    106e:	91 e0       	ldi	r25, 0x01	; 1
    1070:	02 c0       	rjmp	.+4      	; 0x1076 <set_region+0xb2>
				} else {
					display_str("eur-24hr");
    1072:	80 e8       	ldi	r24, 0x80	; 128
    1074:	91 e0       	ldi	r25, 0x01	; 1
    1076:	0e 94 2d 06 	call	0xc5a	; 0xc5a <display_str>
				}
				eeprom_write_byte((uint8_t *)EE_REGION, region);
    107a:	80 91 38 02 	lds	r24, 0x0238
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    107e:	f9 99       	sbic	0x1f, 1	; 31
    1080:	fe cf       	rjmp	.-4      	; 0x107e <set_region+0xba>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1082:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1084:	d2 bd       	out	0x22, r29	; 34
    1086:	c1 bd       	out	0x21, r28	; 33
#endif
    EEDR = __value;
    1088:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
    108a:	0f b6       	in	r0, 0x3f	; 63
    108c:	f8 94       	cli
    108e:	fa 9a       	sbi	0x1f, 2	; 31
    1090:	f9 9a       	sbi	0x1f, 1	; 31
    1092:	0f be       	out	0x3f, r0	; 63
    1094:	ae cf       	rjmp	.-164    	; 0xff2 <set_region+0x2e>
			}
		}
	}
}
    1096:	df 91       	pop	r29
    1098:	cf 91       	pop	r28
    109a:	1f 91       	pop	r17
    109c:	0f 91       	pop	r16
    109e:	08 95       	ret

000010a0 <set_volume>:
	display[7] = pgm_read_byte(numbertable_p + (brightness / 10)) | 0x1;
	display[8] = pgm_read_byte(numbertable_p + (brightness % 10)) | 0x1;
	set_vfd_brightness(brightness);
}

void set_volume(void) {
    10a0:	ef 92       	push	r14
    10a2:	ff 92       	push	r15
    10a4:	0f 93       	push	r16
    10a6:	1f 93       	push	r17
    10a8:	cf 93       	push	r28
    10aa:	df 93       	push	r29
	uint8_t mode = SHOW_MENU;
	uint8_t volume;

	timeoutcounter = INACTIVITYTIMEOUT;;  
    10ac:	8a e0       	ldi	r24, 0x0A	; 10
    10ae:	80 93 4b 02 	sts	0x024B, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    10b2:	f9 99       	sbic	0x1f, 1	; 31
    10b4:	fe cf       	rjmp	.-4      	; 0x10b2 <set_volume+0x12>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    10b6:	8a e0       	ldi	r24, 0x0A	; 10
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	92 bd       	out	0x22, r25	; 34
    10bc:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    10be:	f8 9a       	sbi	0x1f, 0	; 31
    10c0:	f0 b4       	in	r15, 0x20	; 32
    10c2:	00 e0       	ldi	r16, 0x00	; 0
	volume = eeprom_read_byte((uint8_t *)EE_VOLUME);

	while (1) {
		if (just_pressed || pressed) {
			timeoutcounter = INACTIVITYTIMEOUT;;  
    10c4:	5a e0       	ldi	r21, 0x0A	; 10
    10c6:	e5 2e       	mov	r14, r21
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    10c8:	ca e0       	ldi	r28, 0x0A	; 10
    10ca:	d0 e0       	ldi	r29, 0x00	; 0
    10cc:	01 c0       	rjmp	.+2      	; 0x10d0 <set_volume+0x30>
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    10ce:	00 e0       	ldi	r16, 0x00	; 0

	timeoutcounter = INACTIVITYTIMEOUT;;  
	volume = eeprom_read_byte((uint8_t *)EE_VOLUME);

	while (1) {
		if (just_pressed || pressed) {
    10d0:	80 91 48 02 	lds	r24, 0x0248
    10d4:	88 23       	and	r24, r24
    10d6:	21 f4       	brne	.+8      	; 0x10e0 <set_volume+0x40>
    10d8:	80 91 49 02 	lds	r24, 0x0249
    10dc:	88 23       	and	r24, r24
    10de:	19 f0       	breq	.+6      	; 0x10e6 <set_volume+0x46>
			timeoutcounter = INACTIVITYTIMEOUT;;  
    10e0:	e0 92 4b 02 	sts	0x024B, r14
    10e4:	04 c0       	rjmp	.+8      	; 0x10ee <set_volume+0x4e>
			// timeout w/no buttons pressed after 3 seconds?
		} else if (!timeoutcounter) {
    10e6:	80 91 4b 02 	lds	r24, 0x024B
    10ea:	88 23       	and	r24, r24
    10ec:	69 f1       	breq	.+90     	; 0x1148 <set_volume+0xa8>
			//timed out!
			displaymode = SHOW_TIME;     
			return;
		}
		if (just_pressed & 0x1) { // mode change
    10ee:	80 91 48 02 	lds	r24, 0x0248
    10f2:	80 fd       	sbrc	r24, 0
    10f4:	6c c0       	rjmp	.+216    	; 0x11ce <set_volume+0x12e>
			return;
		}
		if (just_pressed & 0x2) {
    10f6:	80 91 48 02 	lds	r24, 0x0248
    10fa:	81 ff       	sbrs	r24, 1
    10fc:	28 c0       	rjmp	.+80     	; 0x114e <set_volume+0xae>
			just_pressed = 0;
    10fe:	10 92 48 02 	sts	0x0248, r1
			if (mode == SHOW_MENU) {
    1102:	00 23       	and	r16, r16
    1104:	09 f5       	brne	.+66     	; 0x1148 <set_volume+0xa8>
				// start!
				mode = SET_VOL;
				// display volume
				if (volume) {
    1106:	ff 20       	and	r15, r15
    1108:	51 f0       	breq	.+20     	; 0x111e <set_volume+0x7e>
					display_str("vol high");
    110a:	89 e8       	ldi	r24, 0x89	; 137
    110c:	91 e0       	ldi	r25, 0x01	; 1
    110e:	0e 94 2d 06 	call	0xc5a	; 0xc5a <display_str>
					display[5] |= 0x1;
    1112:	80 91 da 02 	lds	r24, 0x02DA
    1116:	81 60       	ori	r24, 0x01	; 1
    1118:	80 93 da 02 	sts	0x02DA, r24
    111c:	04 c0       	rjmp	.+8      	; 0x1126 <set_volume+0x86>
				} else {
					display_str("vol  low");
    111e:	82 e9       	ldi	r24, 0x92	; 146
    1120:	91 e0       	ldi	r25, 0x01	; 1
    1122:	0e 94 2d 06 	call	0xc5a	; 0xc5a <display_str>
				}
				display[6] |= 0x1;
    1126:	80 91 db 02 	lds	r24, 0x02DB
    112a:	81 60       	ori	r24, 0x01	; 1
    112c:	80 93 db 02 	sts	0x02DB, r24
				display[7] |= 0x1;
    1130:	80 91 dc 02 	lds	r24, 0x02DC
    1134:	81 60       	ori	r24, 0x01	; 1
    1136:	80 93 dc 02 	sts	0x02DC, r24
				display[8] |= 0x1;
    113a:	80 91 dd 02 	lds	r24, 0x02DD
    113e:	81 60       	ori	r24, 0x01	; 1
    1140:	80 93 dd 02 	sts	0x02DD, r24
    1144:	01 e0       	ldi	r16, 0x01	; 1
    1146:	03 c0       	rjmp	.+6      	; 0x114e <set_volume+0xae>
			} else {	
				displaymode = SHOW_TIME;
    1148:	10 92 e3 02 	sts	0x02E3, r1
    114c:	40 c0       	rjmp	.+128    	; 0x11ce <set_volume+0x12e>
				return;
			}
		}
		if (just_pressed & 0x4) {
    114e:	80 91 48 02 	lds	r24, 0x0248
    1152:	82 ff       	sbrs	r24, 2
    1154:	bd cf       	rjmp	.-134    	; 0x10d0 <set_volume+0x30>
			just_pressed = 0;
    1156:	10 92 48 02 	sts	0x0248, r1
			if (mode == SET_VOL) {
    115a:	01 30       	cpi	r16, 0x01	; 1
    115c:	09 f0       	breq	.+2      	; 0x1160 <set_volume+0xc0>
    115e:	b7 cf       	rjmp	.-146    	; 0x10ce <set_volume+0x2e>
				volume = !volume;
    1160:	10 e0       	ldi	r17, 0x00	; 0
    1162:	ff 20       	and	r15, r15
    1164:	09 f4       	brne	.+2      	; 0x1168 <set_volume+0xc8>
    1166:	11 e0       	ldi	r17, 0x01	; 1
    1168:	f1 2e       	mov	r15, r17
				if (volume) {
    116a:	11 23       	and	r17, r17
    116c:	51 f0       	breq	.+20     	; 0x1182 <set_volume+0xe2>
					display_str("vol high");
    116e:	89 e8       	ldi	r24, 0x89	; 137
    1170:	91 e0       	ldi	r25, 0x01	; 1
    1172:	0e 94 2d 06 	call	0xc5a	; 0xc5a <display_str>
					display[5] |= 0x1;
    1176:	80 91 da 02 	lds	r24, 0x02DA
    117a:	81 60       	ori	r24, 0x01	; 1
    117c:	80 93 da 02 	sts	0x02DA, r24
    1180:	04 c0       	rjmp	.+8      	; 0x118a <set_volume+0xea>
				} else {
					display_str("vol  low");
    1182:	82 e9       	ldi	r24, 0x92	; 146
    1184:	91 e0       	ldi	r25, 0x01	; 1
    1186:	0e 94 2d 06 	call	0xc5a	; 0xc5a <display_str>
				}
				display[6] |= 0x1;
    118a:	80 91 db 02 	lds	r24, 0x02DB
    118e:	81 60       	ori	r24, 0x01	; 1
    1190:	80 93 db 02 	sts	0x02DB, r24
				display[7] |= 0x1;
    1194:	80 91 dc 02 	lds	r24, 0x02DC
    1198:	81 60       	ori	r24, 0x01	; 1
    119a:	80 93 dc 02 	sts	0x02DC, r24
				display[8] |= 0x1;
    119e:	80 91 dd 02 	lds	r24, 0x02DD
    11a2:	81 60       	ori	r24, 0x01	; 1
    11a4:	80 93 dd 02 	sts	0x02DD, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    11a8:	f9 99       	sbic	0x1f, 1	; 31
    11aa:	fe cf       	rjmp	.-4      	; 0x11a8 <set_volume+0x108>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    11ac:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    11ae:	d2 bd       	out	0x22, r29	; 34
    11b0:	c1 bd       	out	0x21, r28	; 33
#endif
    EEDR = __value;
    11b2:	10 bd       	out	0x20, r17	; 32

    __asm__ __volatile__ (
    11b4:	0f b6       	in	r0, 0x3f	; 63
    11b6:	f8 94       	cli
    11b8:	fa 9a       	sbi	0x1f, 2	; 31
    11ba:	f9 9a       	sbi	0x1f, 1	; 31
    11bc:	0f be       	out	0x3f, r0	; 63
				eeprom_write_byte((uint8_t *)EE_VOLUME, volume);
				speaker_init();
    11be:	0e 94 7f 02 	call	0x4fe	; 0x4fe <speaker_init>
				beep(4000, 1);
    11c2:	80 ea       	ldi	r24, 0xA0	; 160
    11c4:	9f e0       	ldi	r25, 0x0F	; 15
    11c6:	61 e0       	ldi	r22, 0x01	; 1
    11c8:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <beep>
    11cc:	81 cf       	rjmp	.-254    	; 0x10d0 <set_volume+0x30>
			}
		}
	}
}
    11ce:	df 91       	pop	r29
    11d0:	cf 91       	pop	r28
    11d2:	1f 91       	pop	r17
    11d4:	0f 91       	pop	r16
    11d6:	ff 90       	pop	r15
    11d8:	ef 90       	pop	r14
    11da:	08 95       	ret

000011dc <set_brightness>:
				delayms(75);
		}
	}
}

void set_brightness(void) {
    11dc:	ff 92       	push	r15
    11de:	0f 93       	push	r16
    11e0:	1f 93       	push	r17
	uint8_t mode = SHOW_MENU;

	timeoutcounter = INACTIVITYTIMEOUT;;  
    11e2:	8a e0       	ldi	r24, 0x0A	; 10
    11e4:	80 93 4b 02 	sts	0x024B, r24
    11e8:	10 e0       	ldi	r17, 0x00	; 0

	while (1) {
		if (just_pressed || pressed) {
			timeoutcounter = INACTIVITYTIMEOUT;;  
    11ea:	6a e0       	ldi	r22, 0x0A	; 10
    11ec:	f6 2e       	mov	r15, r22
		if ((just_pressed & 0x4) || (pressed & 0x4)) {
			just_pressed = 0;
			if (mode == SET_BRITE) {
				// Increment brightness level. Zero means auto-dim.
				if (brightness_level == 0) {
					brightness_level = BRIGHTNESS_MIN;
    11ee:	0e e1       	ldi	r16, 0x1E	; 30
    11f0:	01 c0       	rjmp	.+2      	; 0x11f4 <set_brightness+0x18>
}

void set_brightness(void) {
	uint8_t mode = SHOW_MENU;

	timeoutcounter = INACTIVITYTIMEOUT;;  
    11f2:	10 e0       	ldi	r17, 0x00	; 0

	while (1) {
		if (just_pressed || pressed) {
    11f4:	80 91 48 02 	lds	r24, 0x0248
    11f8:	88 23       	and	r24, r24
    11fa:	21 f4       	brne	.+8      	; 0x1204 <set_brightness+0x28>
    11fc:	80 91 49 02 	lds	r24, 0x0249
    1200:	88 23       	and	r24, r24
    1202:	19 f0       	breq	.+6      	; 0x120a <set_brightness+0x2e>
			timeoutcounter = INACTIVITYTIMEOUT;;  
    1204:	f0 92 4b 02 	sts	0x024B, r15
    1208:	0b c0       	rjmp	.+22     	; 0x1220 <set_brightness+0x44>
			// timeout w/no buttons pressed after 3 seconds?
		} else if (!timeoutcounter) {
    120a:	80 91 4b 02 	lds	r24, 0x024B
    120e:	88 23       	and	r24, r24
    1210:	39 f4       	brne	.+14     	; 0x1220 <set_brightness+0x44>
			//timed out!
			displaymode = SHOW_TIME;     
    1212:	10 92 e3 02 	sts	0x02E3, r1
			eeprom_write_byte((uint8_t *)EE_BRIGHT, brightness_level);
    1216:	20 91 e1 02 	lds	r18, 0x02E1
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    121a:	f9 99       	sbic	0x1f, 1	; 31
    121c:	fe cf       	rjmp	.-4      	; 0x121a <set_brightness+0x3e>
    121e:	1d c0       	rjmp	.+58     	; 0x125a <set_brightness+0x7e>
			return;
		}
		if (just_pressed & 0x1) { // mode change
    1220:	80 91 48 02 	lds	r24, 0x0248
    1224:	80 fd       	sbrc	r24, 0
    1226:	4a c0       	rjmp	.+148    	; 0x12bc <set_brightness+0xe0>
			return;
		}
		if (just_pressed & 0x2) {
    1228:	80 91 48 02 	lds	r24, 0x0248
    122c:	81 ff       	sbrs	r24, 1
    122e:	21 c0       	rjmp	.+66     	; 0x1272 <set_brightness+0x96>

			just_pressed = 0;
    1230:	10 92 48 02 	sts	0x0248, r1
			if (mode == SHOW_MENU) {
    1234:	11 23       	and	r17, r17
    1236:	59 f4       	brne	.+22     	; 0x124e <set_brightness+0x72>
				// start!
				mode = SET_BRITE;
				// display brightness
				display_str("brite ");
    1238:	8b e9       	ldi	r24, 0x9B	; 155
    123a:	91 e0       	ldi	r25, 0x01	; 1
    123c:	0e 94 2d 06 	call	0xc5a	; 0xc5a <display_str>
				display_brightness(brightness_level);
    1240:	80 91 e1 02 	lds	r24, 0x02E1
    1244:	90 e0       	ldi	r25, 0x00	; 0
    1246:	0e 94 5e 01 	call	0x2bc	; 0x2bc <display_brightness>
    124a:	11 e0       	ldi	r17, 0x01	; 1
    124c:	12 c0       	rjmp	.+36     	; 0x1272 <set_brightness+0x96>
			} else {	
				displaymode = SHOW_TIME;
    124e:	10 92 e3 02 	sts	0x02E3, r1
				eeprom_write_byte((uint8_t *)EE_BRIGHT, brightness_level);
    1252:	20 91 e1 02 	lds	r18, 0x02E1
    1256:	f9 99       	sbic	0x1f, 1	; 31
    1258:	fe cf       	rjmp	.-4      	; 0x1256 <set_brightness+0x7a>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    125a:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    125c:	89 e0       	ldi	r24, 0x09	; 9
    125e:	90 e0       	ldi	r25, 0x00	; 0
    1260:	92 bd       	out	0x22, r25	; 34
    1262:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    1264:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    1266:	0f b6       	in	r0, 0x3f	; 63
    1268:	f8 94       	cli
    126a:	fa 9a       	sbi	0x1f, 2	; 31
    126c:	f9 9a       	sbi	0x1f, 1	; 31
    126e:	0f be       	out	0x3f, r0	; 63
    1270:	25 c0       	rjmp	.+74     	; 0x12bc <set_brightness+0xe0>
				return;
			}
		}
		if ((just_pressed & 0x4) || (pressed & 0x4)) {
    1272:	80 91 48 02 	lds	r24, 0x0248
    1276:	82 fd       	sbrc	r24, 2
    1278:	04 c0       	rjmp	.+8      	; 0x1282 <set_brightness+0xa6>
    127a:	80 91 49 02 	lds	r24, 0x0249
    127e:	82 ff       	sbrs	r24, 2
    1280:	b9 cf       	rjmp	.-142    	; 0x11f4 <set_brightness+0x18>
			just_pressed = 0;
    1282:	10 92 48 02 	sts	0x0248, r1
			if (mode == SET_BRITE) {
    1286:	11 30       	cpi	r17, 0x01	; 1
    1288:	09 f0       	breq	.+2      	; 0x128c <set_brightness+0xb0>
    128a:	b3 cf       	rjmp	.-154    	; 0x11f2 <set_brightness+0x16>
				// Increment brightness level. Zero means auto-dim.
				if (brightness_level == 0) {
    128c:	80 91 e1 02 	lds	r24, 0x02E1
    1290:	88 23       	and	r24, r24
    1292:	19 f4       	brne	.+6      	; 0x129a <set_brightness+0xbe>
					brightness_level = BRIGHTNESS_MIN;
    1294:	00 93 e1 02 	sts	0x02E1, r16
    1298:	0b c0       	rjmp	.+22     	; 0x12b0 <set_brightness+0xd4>
				} else {
					brightness_level += BRIGHTNESS_INCREMENT;
    129a:	80 91 e1 02 	lds	r24, 0x02E1
    129e:	8b 5f       	subi	r24, 0xFB	; 251
    12a0:	80 93 e1 02 	sts	0x02E1, r24
					if (brightness_level > BRIGHTNESS_MAX) {
    12a4:	80 91 e1 02 	lds	r24, 0x02E1
    12a8:	8b 35       	cpi	r24, 0x5B	; 91
    12aa:	10 f0       	brcs	.+4      	; 0x12b0 <set_brightness+0xd4>
#ifdef FEATURE_AUTODIM
						brightness_level = 0;
    12ac:	10 92 e1 02 	sts	0x02E1, r1
#else
						brightness_level = BRIGHTNESS_MIN;
#endif
					}
				}
				display_brightness(brightness_level);
    12b0:	80 91 e1 02 	lds	r24, 0x02E1
    12b4:	90 e0       	ldi	r25, 0x00	; 0
    12b6:	0e 94 5e 01 	call	0x2bc	; 0x2bc <display_brightness>
    12ba:	9c cf       	rjmp	.-200    	; 0x11f4 <set_brightness+0x18>
			}
		}
	}
}
    12bc:	1f 91       	pop	r17
    12be:	0f 91       	pop	r16
    12c0:	ff 90       	pop	r15
    12c2:	08 95       	ret

000012c4 <vfd_init>:

/************************* LOW LEVEL DISPLAY ************************/

// Setup SPI
void vfd_init(void) {
	SPCR  = _BV(SPE) | _BV(MSTR) | _BV(SPR0);
    12c4:	81 e5       	ldi	r24, 0x51	; 81
    12c6:	8c bd       	out	0x2c, r24	; 44
}
    12c8:	08 95       	ret

000012ca <vfd_send>:
	vfd_send(d);
}

// send raw data to display, its pretty straightforward. Just send 32 bits via SPI
// the bottom 20 define the segments
void vfd_send(uint32_t d) {
    12ca:	9b 01       	movw	r18, r22
    12cc:	ac 01       	movw	r20, r24
	// send lowest 20 bits
	cli();       // to prevent flicker we turn off interrupts
    12ce:	f8 94       	cli
	spi_xfer(d >> 16);
    12d0:	aa 27       	eor	r26, r26
    12d2:	bb 27       	eor	r27, r27
	}
}

// Send 1 byte via SPI
void spi_xfer(uint8_t c) {
	SPDR = c;
    12d4:	8e bd       	out	0x2e, r24	; 46
	while (! (SPSR & _BV(SPIF)))
    12d6:	0d b4       	in	r0, 0x2d	; 45
    12d8:	07 fe       	sbrs	r0, 7
    12da:	fd cf       	rjmp	.-6      	; 0x12d6 <vfd_send+0xc>
// the bottom 20 define the segments
void vfd_send(uint32_t d) {
	// send lowest 20 bits
	cli();       // to prevent flicker we turn off interrupts
	spi_xfer(d >> 16);
	spi_xfer(d >> 8);
    12dc:	bb 27       	eor	r27, r27
    12de:	a5 2f       	mov	r26, r21
    12e0:	94 2f       	mov	r25, r20
    12e2:	83 2f       	mov	r24, r19
	}
}

// Send 1 byte via SPI
void spi_xfer(uint8_t c) {
	SPDR = c;
    12e4:	8e bd       	out	0x2e, r24	; 46
	while (! (SPSR & _BV(SPIF)))
    12e6:	0d b4       	in	r0, 0x2d	; 45
    12e8:	07 fe       	sbrs	r0, 7
    12ea:	fd cf       	rjmp	.-6      	; 0x12e6 <vfd_send+0x1c>
	}
}

// Send 1 byte via SPI
void spi_xfer(uint8_t c) {
	SPDR = c;
    12ec:	2e bd       	out	0x2e, r18	; 46
	while (! (SPSR & _BV(SPIF)))
    12ee:	0d b4       	in	r0, 0x2d	; 45
    12f0:	07 fe       	sbrs	r0, 7
    12f2:	fd cf       	rjmp	.-6      	; 0x12ee <vfd_send+0x24>
	spi_xfer(d >> 16);
	spi_xfer(d >> 8);
	spi_xfer(d);

	// latch data
	VFDLOAD_PORT |= _BV(VFDLOAD);
    12f4:	40 9a       	sbi	0x08, 0	; 8
	VFDLOAD_PORT &= ~_BV(VFDLOAD);
    12f6:	40 98       	cbi	0x08, 0	; 8
	sei();
    12f8:	78 94       	sei
}
    12fa:	08 95       	ret

000012fc <setdisplay>:
}

// This changes and updates the display
// We use the digit/segment table to determine which
// pins on the MAX6921 to turn on
void setdisplay(uint8_t digit, uint8_t segments) {
    12fc:	af 92       	push	r10
    12fe:	bf 92       	push	r11
    1300:	cf 92       	push	r12
    1302:	df 92       	push	r13
    1304:	ef 92       	push	r14
    1306:	ff 92       	push	r15
    1308:	0f 93       	push	r16
    130a:	1f 93       	push	r17
	uint32_t d = 0;  // we only need 20 bits but 32 will do
	uint8_t i;

	// Set the digit selection pin
	d |= _BV(pgm_read_byte(digittable_p + digit));
    130c:	e8 2f       	mov	r30, r24
    130e:	f0 e0       	ldi	r31, 0x00	; 0
    1310:	e0 56       	subi	r30, 0x60	; 96
    1312:	ff 4f       	sbci	r31, 0xFF	; 255
    1314:	e4 91       	lpm	r30, Z+
    1316:	81 e0       	ldi	r24, 0x01	; 1
    1318:	90 e0       	ldi	r25, 0x00	; 0
    131a:	02 c0       	rjmp	.+4      	; 0x1320 <setdisplay+0x24>
    131c:	88 0f       	add	r24, r24
    131e:	99 1f       	adc	r25, r25
    1320:	ea 95       	dec	r30
    1322:	e2 f7       	brpl	.-8      	; 0x131c <setdisplay+0x20>
    1324:	7c 01       	movw	r14, r24
    1326:	00 27       	eor	r16, r16
    1328:	f7 fc       	sbrc	r15, 7
    132a:	00 95       	com	r16
    132c:	10 2f       	mov	r17, r16
    132e:	20 91 4c 02 	lds	r18, 0x024C
    1332:	30 91 4d 02 	lds	r19, 0x024D
    1336:	40 91 4e 02 	lds	r20, 0x024E
    133a:	50 91 4f 02 	lds	r21, 0x024F
    133e:	a0 e0       	ldi	r26, 0x00	; 0
    1340:	b0 e0       	ldi	r27, 0x00	; 0


	// Set the individual segments for this digit
	for (i=0; i<8; i++) {
		if (segments & _BV(i)) {
    1342:	70 e0       	ldi	r23, 0x00	; 0
			t = 1;
			t <<= pgm_read_byte(segmenttable_p + i);
    1344:	f1 e0       	ldi	r31, 0x01	; 1
    1346:	af 2e       	mov	r10, r31
    1348:	b1 2c       	mov	r11, r1
    134a:	c1 2c       	mov	r12, r1
    134c:	d1 2c       	mov	r13, r1
	d |= _BV(pgm_read_byte(digittable_p + digit));


	// Set the individual segments for this digit
	for (i=0; i<8; i++) {
		if (segments & _BV(i)) {
    134e:	cb 01       	movw	r24, r22
    1350:	0a 2e       	mov	r0, r26
    1352:	02 c0       	rjmp	.+4      	; 0x1358 <setdisplay+0x5c>
    1354:	95 95       	asr	r25
    1356:	87 95       	ror	r24
    1358:	0a 94       	dec	r0
    135a:	e2 f7       	brpl	.-8      	; 0x1354 <setdisplay+0x58>
    135c:	80 ff       	sbrs	r24, 0
    135e:	11 c0       	rjmp	.+34     	; 0x1382 <setdisplay+0x86>
			t = 1;
			t <<= pgm_read_byte(segmenttable_p + i);
    1360:	fd 01       	movw	r30, r26
    1362:	e5 55       	subi	r30, 0x55	; 85
    1364:	ff 4f       	sbci	r31, 0xFF	; 255
    1366:	e4 91       	lpm	r30, Z+
    1368:	a6 01       	movw	r20, r12
    136a:	95 01       	movw	r18, r10
    136c:	04 c0       	rjmp	.+8      	; 0x1376 <setdisplay+0x7a>
    136e:	22 0f       	add	r18, r18
    1370:	33 1f       	adc	r19, r19
    1372:	44 1f       	adc	r20, r20
    1374:	55 1f       	adc	r21, r21
    1376:	ea 95       	dec	r30
    1378:	d2 f7       	brpl	.-12     	; 0x136e <setdisplay+0x72>
			d |= t;
    137a:	e2 2a       	or	r14, r18
    137c:	f3 2a       	or	r15, r19
    137e:	04 2b       	or	r16, r20
    1380:	15 2b       	or	r17, r21
    1382:	11 96       	adiw	r26, 0x01	; 1
	// Set the digit selection pin
	d |= _BV(pgm_read_byte(digittable_p + digit));


	// Set the individual segments for this digit
	for (i=0; i<8; i++) {
    1384:	a8 30       	cpi	r26, 0x08	; 8
    1386:	b1 05       	cpc	r27, r1
    1388:	11 f7       	brne	.-60     	; 0x134e <setdisplay+0x52>
    138a:	20 93 4c 02 	sts	0x024C, r18
    138e:	30 93 4d 02 	sts	0x024D, r19
    1392:	40 93 4e 02 	sts	0x024E, r20
    1396:	50 93 4f 02 	sts	0x024F, r21
			d |= t;
		}
	}

	// Shift the data out to the display
	vfd_send(d);
    139a:	c8 01       	movw	r24, r16
    139c:	b7 01       	movw	r22, r14
    139e:	0e 94 65 09 	call	0x12ca	; 0x12ca <vfd_send>
}
    13a2:	1f 91       	pop	r17
    13a4:	0f 91       	pop	r16
    13a6:	ff 90       	pop	r15
    13a8:	ef 90       	pop	r14
    13aa:	df 90       	pop	r13
    13ac:	cf 90       	pop	r12
    13ae:	bf 90       	pop	r11
    13b0:	af 90       	pop	r10
    13b2:	08 95       	ret

000013b4 <__vector_16>:
void kickthedog(void) {
	wdt_reset();
}

// called @ (F_CPU/256) = ~30khz (31.25 khz)
SIGNAL (SIG_OVERFLOW0) {
    13b4:	1f 92       	push	r1
    13b6:	0f 92       	push	r0
    13b8:	0f b6       	in	r0, 0x3f	; 63
    13ba:	0f 92       	push	r0
    13bc:	11 24       	eor	r1, r1
    13be:	2f 93       	push	r18
    13c0:	3f 93       	push	r19
    13c2:	4f 93       	push	r20
    13c4:	5f 93       	push	r21
    13c6:	6f 93       	push	r22
    13c8:	7f 93       	push	r23
    13ca:	8f 93       	push	r24
    13cc:	9f 93       	push	r25
    13ce:	af 93       	push	r26
    13d0:	bf 93       	push	r27
    13d2:	ef 93       	push	r30
    13d4:	ff 93       	push	r31
	// allow other interrupts to go off while we're doing display updates
	sei();
    13d6:	78 94       	sei
	displaymode = SHOW_TIME;
}

// we reset the watchdog timer 
void kickthedog(void) {
	wdt_reset();
    13d8:	a8 95       	wdr

	// kick the dog
	kickthedog();

	// divide down to 100Hz * digits
	muxdiv++;
    13da:	80 91 3f 02 	lds	r24, 0x023F
    13de:	90 91 40 02 	lds	r25, 0x0240
    13e2:	01 96       	adiw	r24, 0x01	; 1
    13e4:	90 93 40 02 	sts	0x0240, r25
    13e8:	80 93 3f 02 	sts	0x023F, r24
	if (muxdiv < MUX_DIVIDER)
    13ec:	81 97       	sbiw	r24, 0x21	; 33
    13ee:	08 f4       	brcc	.+2      	; 0x13f2 <__vector_16+0x3e>
    13f0:	6c c0       	rjmp	.+216    	; 0x14ca <__vector_16+0x116>
		return;
	muxdiv = 0;
    13f2:	10 92 40 02 	sts	0x0240, r1
    13f6:	10 92 3f 02 	sts	0x023F, r1
	// now at 100Hz * digits

	// ok its not really 1ms but its like within 10% :)
	milliseconds++;
    13fa:	80 91 45 02 	lds	r24, 0x0245
    13fe:	90 91 46 02 	lds	r25, 0x0246
    1402:	01 96       	adiw	r24, 0x01	; 1
    1404:	90 93 46 02 	sts	0x0246, r25
    1408:	80 93 45 02 	sts	0x0245, r24

	// Cycle through each digit in the display
	if (currdigit >= DISPLAYSIZE)
    140c:	80 91 3e 02 	lds	r24, 0x023E
    1410:	89 30       	cpi	r24, 0x09	; 9
    1412:	10 f0       	brcs	.+4      	; 0x1418 <__vector_16+0x64>
		currdigit = 0;
    1414:	10 92 3e 02 	sts	0x023E, r1

	// Set the current display's segments
	setdisplay(currdigit, display[currdigit]);
    1418:	80 91 3e 02 	lds	r24, 0x023E
    141c:	e8 2f       	mov	r30, r24
    141e:	f0 e0       	ldi	r31, 0x00	; 0
    1420:	eb 52       	subi	r30, 0x2B	; 43
    1422:	fd 4f       	sbci	r31, 0xFD	; 253
    1424:	60 81       	ld	r22, Z
    1426:	0e 94 7e 09 	call	0x12fc	; 0x12fc <setdisplay>
	// and go to the next
	currdigit++;
    142a:	80 91 3e 02 	lds	r24, 0x023E
    142e:	8f 5f       	subi	r24, 0xFF	; 255
    1430:	80 93 3e 02 	sts	0x023E, r24

	// check if we should have the alarm on
	if (alarming && !snoozetimer) {
    1434:	80 91 e2 02 	lds	r24, 0x02E2
    1438:	88 23       	and	r24, r24
    143a:	09 f4       	brne	.+2      	; 0x143e <__vector_16+0x8a>
    143c:	46 c0       	rjmp	.+140    	; 0x14ca <__vector_16+0x116>
    143e:	80 91 43 02 	lds	r24, 0x0243
    1442:	90 91 44 02 	lds	r25, 0x0244
    1446:	89 2b       	or	r24, r25
    1448:	09 f0       	breq	.+2      	; 0x144c <__vector_16+0x98>
    144a:	3f c0       	rjmp	.+126    	; 0x14ca <__vector_16+0x116>
		alarmdiv++;
    144c:	80 91 41 02 	lds	r24, 0x0241
    1450:	90 91 42 02 	lds	r25, 0x0242
    1454:	01 96       	adiw	r24, 0x01	; 1
    1456:	90 93 42 02 	sts	0x0242, r25
    145a:	80 93 41 02 	sts	0x0241, r24
		if (alarmdiv > ALARM_DIVIDER) {
    145e:	85 36       	cpi	r24, 0x65	; 101
    1460:	91 05       	cpc	r25, r1
    1462:	98 f1       	brcs	.+102    	; 0x14ca <__vector_16+0x116>
			alarmdiv = 0;
    1464:	10 92 42 02 	sts	0x0242, r1
    1468:	10 92 41 02 	sts	0x0241, r1
			return;
		}
		// This part only gets reached at 1Hz

		// This sets the buzzer frequency
		ICR1 = 250;
    146c:	8a ef       	ldi	r24, 0xFA	; 250
    146e:	90 e0       	ldi	r25, 0x00	; 0
    1470:	90 93 87 00 	sts	0x0087, r25
    1474:	80 93 86 00 	sts	0x0086, r24
		OCR1A = OCR1B = ICR1/2;
    1478:	80 91 86 00 	lds	r24, 0x0086
    147c:	90 91 87 00 	lds	r25, 0x0087
    1480:	96 95       	lsr	r25
    1482:	87 95       	ror	r24
    1484:	90 93 8b 00 	sts	0x008B, r25
    1488:	80 93 8a 00 	sts	0x008A, r24
    148c:	80 91 8a 00 	lds	r24, 0x008A
    1490:	90 91 8b 00 	lds	r25, 0x008B
    1494:	90 93 89 00 	sts	0x0089, r25
    1498:	80 93 88 00 	sts	0x0088, r24

		// ok alarm is ringing!
		if (alarming & 0xF0) { // top bit indicates pulsing alarm state
    149c:	80 91 e2 02 	lds	r24, 0x02E2
    14a0:	80 7f       	andi	r24, 0xF0	; 240
    14a2:	49 f0       	breq	.+18     	; 0x14b6 <__vector_16+0x102>
			alarming &= ~0xF0;
    14a4:	80 91 e2 02 	lds	r24, 0x02E2
    14a8:	8f 70       	andi	r24, 0x0F	; 15
    14aa:	80 93 e2 02 	sts	0x02E2, r24
			TCCR1B &= ~_BV(CS11); // turn buzzer off!
    14ae:	80 91 81 00 	lds	r24, 0x0081
    14b2:	8d 7f       	andi	r24, 0xFD	; 253
    14b4:	08 c0       	rjmp	.+16     	; 0x14c6 <__vector_16+0x112>
		} else {
			alarming |= 0xF0;
    14b6:	80 91 e2 02 	lds	r24, 0x02E2
    14ba:	80 6f       	ori	r24, 0xF0	; 240
    14bc:	80 93 e2 02 	sts	0x02E2, r24
			TCCR1B |= _BV(CS11); // turn buzzer on!
    14c0:	80 91 81 00 	lds	r24, 0x0081
    14c4:	82 60       	ori	r24, 0x02	; 2
    14c6:	80 93 81 00 	sts	0x0081, r24
		}
	}

}
    14ca:	ff 91       	pop	r31
    14cc:	ef 91       	pop	r30
    14ce:	bf 91       	pop	r27
    14d0:	af 91       	pop	r26
    14d2:	9f 91       	pop	r25
    14d4:	8f 91       	pop	r24
    14d6:	7f 91       	pop	r23
    14d8:	6f 91       	pop	r22
    14da:	5f 91       	pop	r21
    14dc:	4f 91       	pop	r20
    14de:	3f 91       	pop	r19
    14e0:	2f 91       	pop	r18
    14e2:	0f 90       	pop	r0
    14e4:	0f be       	out	0x3f, r0	; 63
    14e6:	0f 90       	pop	r0
    14e8:	1f 90       	pop	r1
    14ea:	18 95       	reti

000014ec <fix_time>:

//Fixes the time variables whenever time is changed
void fix_time(void) {

	// a minute!
	if (time_s >= 60) {
    14ec:	80 91 e5 02 	lds	r24, 0x02E5
    14f0:	8c 33       	cpi	r24, 0x3C	; 60
    14f2:	54 f0       	brlt	.+20     	; 0x1508 <fix_time+0x1c>
		time_s = time_s - 60;
    14f4:	80 91 e5 02 	lds	r24, 0x02E5
    14f8:	8c 53       	subi	r24, 0x3C	; 60
    14fa:	80 93 e5 02 	sts	0x02E5, r24
		time_m++;
    14fe:	80 91 de 02 	lds	r24, 0x02DE
    1502:	8f 5f       	subi	r24, 0xFF	; 255
    1504:	80 93 de 02 	sts	0x02DE, r24
	}
	// If someone decides to make offset seconds with a negative number...
	if (time_s < 0) {
    1508:	80 91 e5 02 	lds	r24, 0x02E5
    150c:	87 ff       	sbrs	r24, 7
    150e:	0a c0       	rjmp	.+20     	; 0x1524 <fix_time+0x38>
		time_s =  60 + time_s;
    1510:	80 91 e5 02 	lds	r24, 0x02E5
    1514:	84 5c       	subi	r24, 0xC4	; 196
    1516:	80 93 e5 02 	sts	0x02E5, r24
		time_m--;
    151a:	80 91 de 02 	lds	r24, 0x02DE
    151e:	81 50       	subi	r24, 0x01	; 1
    1520:	80 93 de 02 	sts	0x02DE, r24
	}

	// an hour...
	if (time_m >= 60) {
    1524:	80 91 de 02 	lds	r24, 0x02DE
    1528:	8c 33       	cpi	r24, 0x3C	; 60
    152a:	44 f1       	brlt	.+80     	; 0x157c <fix_time+0x90>
		time_m = time_m - 60;
    152c:	80 91 de 02 	lds	r24, 0x02DE
    1530:	8c 53       	subi	r24, 0x3C	; 60
    1532:	80 93 de 02 	sts	0x02DE, r24
		time_h++; 
    1536:	80 91 50 02 	lds	r24, 0x0250
    153a:	8f 5f       	subi	r24, 0xFF	; 255
    153c:	80 93 50 02 	sts	0x0250, r24
		// let's write the time to the EEPROM
		eeprom_write_byte((uint8_t *)EE_HOUR, time_h);
    1540:	20 91 50 02 	lds	r18, 0x0250
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1544:	f9 99       	sbic	0x1f, 1	; 31
    1546:	fe cf       	rjmp	.-4      	; 0x1544 <fix_time+0x58>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1548:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    154a:	84 e0       	ldi	r24, 0x04	; 4
    154c:	90 e0       	ldi	r25, 0x00	; 0
    154e:	92 bd       	out	0x22, r25	; 34
    1550:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    1552:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    1554:	0f b6       	in	r0, 0x3f	; 63
    1556:	f8 94       	cli
    1558:	fa 9a       	sbi	0x1f, 2	; 31
    155a:	f9 9a       	sbi	0x1f, 1	; 31
    155c:	0f be       	out	0x3f, r0	; 63
		eeprom_write_byte((uint8_t *)EE_MIN, time_m);
    155e:	20 91 de 02 	lds	r18, 0x02DE
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1562:	f9 99       	sbic	0x1f, 1	; 31
    1564:	fe cf       	rjmp	.-4      	; 0x1562 <fix_time+0x76>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1566:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1568:	85 e0       	ldi	r24, 0x05	; 5
    156a:	90 e0       	ldi	r25, 0x00	; 0
    156c:	92 bd       	out	0x22, r25	; 34
    156e:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    1570:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    1572:	0f b6       	in	r0, 0x3f	; 63
    1574:	f8 94       	cli
    1576:	fa 9a       	sbi	0x1f, 2	; 31
    1578:	f9 9a       	sbi	0x1f, 1	; 31
    157a:	0f be       	out	0x3f, r0	; 63
	}
	// When offsets create negative minutes...
	if (time_m < 0) {
    157c:	80 91 de 02 	lds	r24, 0x02DE
    1580:	87 ff       	sbrs	r24, 7
    1582:	28 c0       	rjmp	.+80     	; 0x15d4 <fix_time+0xe8>
		time_m = 60 + time_m;
    1584:	80 91 de 02 	lds	r24, 0x02DE
    1588:	84 5c       	subi	r24, 0xC4	; 196
    158a:	80 93 de 02 	sts	0x02DE, r24
		time_h--; 
    158e:	80 91 50 02 	lds	r24, 0x0250
    1592:	81 50       	subi	r24, 0x01	; 1
    1594:	80 93 50 02 	sts	0x0250, r24
		eeprom_write_byte((uint8_t *)EE_HOUR, time_h);
    1598:	20 91 50 02 	lds	r18, 0x0250
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    159c:	f9 99       	sbic	0x1f, 1	; 31
    159e:	fe cf       	rjmp	.-4      	; 0x159c <fix_time+0xb0>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    15a0:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    15a2:	84 e0       	ldi	r24, 0x04	; 4
    15a4:	90 e0       	ldi	r25, 0x00	; 0
    15a6:	92 bd       	out	0x22, r25	; 34
    15a8:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    15aa:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    15ac:	0f b6       	in	r0, 0x3f	; 63
    15ae:	f8 94       	cli
    15b0:	fa 9a       	sbi	0x1f, 2	; 31
    15b2:	f9 9a       	sbi	0x1f, 1	; 31
    15b4:	0f be       	out	0x3f, r0	; 63
		eeprom_write_byte((uint8_t *)EE_MIN, time_m);
    15b6:	20 91 de 02 	lds	r18, 0x02DE
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    15ba:	f9 99       	sbic	0x1f, 1	; 31
    15bc:	fe cf       	rjmp	.-4      	; 0x15ba <fix_time+0xce>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    15be:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    15c0:	85 e0       	ldi	r24, 0x05	; 5
    15c2:	90 e0       	ldi	r25, 0x00	; 0
    15c4:	92 bd       	out	0x22, r25	; 34
    15c6:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    15c8:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    15ca:	0f b6       	in	r0, 0x3f	; 63
    15cc:	f8 94       	cli
    15ce:	fa 9a       	sbi	0x1f, 2	; 31
    15d0:	f9 9a       	sbi	0x1f, 1	; 31
    15d2:	0f be       	out	0x3f, r0	; 63
	}

	// a day....
	if (time_h >= 24) {
    15d4:	80 91 50 02 	lds	r24, 0x0250
    15d8:	88 31       	cpi	r24, 0x18	; 24
    15da:	cc f0       	brlt	.+50     	; 0x160e <fix_time+0x122>
		time_h = time_h - 24;
    15dc:	80 91 50 02 	lds	r24, 0x0250
    15e0:	88 51       	subi	r24, 0x18	; 24
    15e2:	80 93 50 02 	sts	0x0250, r24
		date_d++;
    15e6:	80 91 d4 02 	lds	r24, 0x02D4
    15ea:	8f 5f       	subi	r24, 0xFF	; 255
    15ec:	80 93 d4 02 	sts	0x02D4, r24
		eeprom_write_byte((uint8_t *)EE_DAY, date_d);
    15f0:	20 91 d4 02 	lds	r18, 0x02D4
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    15f4:	f9 99       	sbic	0x1f, 1	; 31
    15f6:	fe cf       	rjmp	.-4      	; 0x15f4 <fix_time+0x108>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    15f8:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    15fa:	83 e0       	ldi	r24, 0x03	; 3
    15fc:	90 e0       	ldi	r25, 0x00	; 0
    15fe:	92 bd       	out	0x22, r25	; 34
    1600:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    1602:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    1604:	0f b6       	in	r0, 0x3f	; 63
    1606:	f8 94       	cli
    1608:	fa 9a       	sbi	0x1f, 2	; 31
    160a:	f9 9a       	sbi	0x1f, 1	; 31
    160c:	0f be       	out	0x3f, r0	; 63
	}
	// When offsets create negative hours...
	if (time_h < 0) {
    160e:	80 91 50 02 	lds	r24, 0x0250
    1612:	87 ff       	sbrs	r24, 7
    1614:	19 c0       	rjmp	.+50     	; 0x1648 <fix_time+0x15c>
		time_h = 24 + time_h;
    1616:	80 91 50 02 	lds	r24, 0x0250
    161a:	88 5e       	subi	r24, 0xE8	; 232
    161c:	80 93 50 02 	sts	0x0250, r24
		date_d--;
    1620:	80 91 d4 02 	lds	r24, 0x02D4
    1624:	81 50       	subi	r24, 0x01	; 1
    1626:	80 93 d4 02 	sts	0x02D4, r24
		eeprom_write_byte((uint8_t *)EE_DAY, date_d);
    162a:	20 91 d4 02 	lds	r18, 0x02D4
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    162e:	f9 99       	sbic	0x1f, 1	; 31
    1630:	fe cf       	rjmp	.-4      	; 0x162e <fix_time+0x142>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1632:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1634:	83 e0       	ldi	r24, 0x03	; 3
    1636:	90 e0       	ldi	r25, 0x00	; 0
    1638:	92 bd       	out	0x22, r25	; 34
    163a:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    163c:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    163e:	0f b6       	in	r0, 0x3f	; 63
    1640:	f8 94       	cli
    1642:	fa 9a       	sbi	0x1f, 2	; 31
    1644:	f9 9a       	sbi	0x1f, 1	; 31
    1646:	0f be       	out	0x3f, r0	; 63
	//}


	// a full month!
	// we check the leapyear and date to verify when it's time to roll over months
	if ((date_d > 31) ||
    1648:	80 91 d4 02 	lds	r24, 0x02D4
    164c:	80 32       	cpi	r24, 0x20	; 32
    164e:	7c f5       	brge	.+94     	; 0x16ae <fix_time+0x1c2>
    1650:	80 91 d4 02 	lds	r24, 0x02D4
    1654:	8f 31       	cpi	r24, 0x1F	; 31
    1656:	81 f4       	brne	.+32     	; 0x1678 <fix_time+0x18c>
    1658:	80 91 e4 02 	lds	r24, 0x02E4
    165c:	84 30       	cpi	r24, 0x04	; 4
    165e:	39 f1       	breq	.+78     	; 0x16ae <fix_time+0x1c2>
    1660:	80 91 e4 02 	lds	r24, 0x02E4
    1664:	86 30       	cpi	r24, 0x06	; 6
    1666:	19 f1       	breq	.+70     	; 0x16ae <fix_time+0x1c2>
    1668:	80 91 e4 02 	lds	r24, 0x02E4
    166c:	89 30       	cpi	r24, 0x09	; 9
    166e:	f9 f0       	breq	.+62     	; 0x16ae <fix_time+0x1c2>
    1670:	80 91 e4 02 	lds	r24, 0x02E4
    1674:	8b 30       	cpi	r24, 0x0B	; 11
    1676:	d9 f0       	breq	.+54     	; 0x16ae <fix_time+0x1c2>
    1678:	80 91 d4 02 	lds	r24, 0x02D4
    167c:	8e 31       	cpi	r24, 0x1E	; 30
    167e:	21 f4       	brne	.+8      	; 0x1688 <fix_time+0x19c>
    1680:	80 91 e4 02 	lds	r24, 0x02E4
    1684:	82 30       	cpi	r24, 0x02	; 2
    1686:	99 f0       	breq	.+38     	; 0x16ae <fix_time+0x1c2>
    1688:	80 91 d4 02 	lds	r24, 0x02D4
    168c:	8d 31       	cpi	r24, 0x1D	; 29
    168e:	31 f5       	brne	.+76     	; 0x16dc <fix_time+0x1f0>
    1690:	80 91 e4 02 	lds	r24, 0x02E4
    1694:	82 30       	cpi	r24, 0x02	; 2
    1696:	11 f5       	brne	.+68     	; 0x16dc <fix_time+0x1f0>
    1698:	80 91 d1 02 	lds	r24, 0x02D1
    169c:	99 27       	eor	r25, r25
    169e:	87 fd       	sbrc	r24, 7
    16a0:	90 95       	com	r25
    16a2:	80 53       	subi	r24, 0x30	; 48
    16a4:	98 4f       	sbci	r25, 0xF8	; 248
    16a6:	0e 94 02 02 	call	0x404	; 0x404 <leapyear>
    16aa:	88 23       	and	r24, r24
    16ac:	b9 f4       	brne	.+46     	; 0x16dc <fix_time+0x1f0>
			((date_d == 31) && ((date_m == 4)||(date_m == 6)||(date_m == 9)||(date_m == 11))) ||
			((date_d == 30) && (date_m == 2)) ||
			((date_d == 29) && (date_m == 2) && !leapyear(2000+date_y))) {
		date_d = 1;
    16ae:	81 e0       	ldi	r24, 0x01	; 1
    16b0:	80 93 d4 02 	sts	0x02D4, r24
		date_m++;
    16b4:	80 91 e4 02 	lds	r24, 0x02E4
    16b8:	8f 5f       	subi	r24, 0xFF	; 255
    16ba:	80 93 e4 02 	sts	0x02E4, r24
		eeprom_write_byte((uint8_t *)EE_MONTH, date_m);
    16be:	20 91 e4 02 	lds	r18, 0x02E4
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    16c2:	f9 99       	sbic	0x1f, 1	; 31
    16c4:	fe cf       	rjmp	.-4      	; 0x16c2 <fix_time+0x1d6>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    16c6:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    16c8:	82 e0       	ldi	r24, 0x02	; 2
    16ca:	90 e0       	ldi	r25, 0x00	; 0
    16cc:	92 bd       	out	0x22, r25	; 34
    16ce:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    16d0:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    16d2:	0f b6       	in	r0, 0x3f	; 63
    16d4:	f8 94       	cli
    16d6:	fa 9a       	sbi	0x1f, 2	; 31
    16d8:	f9 9a       	sbi	0x1f, 1	; 31
    16da:	0f be       	out	0x3f, r0	; 63
	}
	// When offsets create negative days...
	if (date_d < 1) {
    16dc:	80 91 d4 02 	lds	r24, 0x02D4
    16e0:	18 16       	cp	r1, r24
    16e2:	0c f4       	brge	.+2      	; 0x16e6 <fix_time+0x1fa>
    16e4:	52 c0       	rjmp	.+164    	; 0x178a <fix_time+0x29e>
		//Find which month we are going back to:
		switch (date_m) {
    16e6:	80 91 e4 02 	lds	r24, 0x02E4
    16ea:	86 30       	cpi	r24, 0x06	; 6
    16ec:	d1 f0       	breq	.+52     	; 0x1722 <fix_time+0x236>
    16ee:	87 30       	cpi	r24, 0x07	; 7
    16f0:	64 f4       	brge	.+24     	; 0x170a <fix_time+0x21e>
    16f2:	83 30       	cpi	r24, 0x03	; 3
    16f4:	29 f1       	breq	.+74     	; 0x1740 <fix_time+0x254>
    16f6:	84 30       	cpi	r24, 0x04	; 4
    16f8:	1c f4       	brge	.+6      	; 0x1700 <fix_time+0x214>
    16fa:	81 30       	cpi	r24, 0x01	; 1
    16fc:	94 f4       	brge	.+36     	; 0x1722 <fix_time+0x236>
    16fe:	33 c0       	rjmp	.+102    	; 0x1766 <fix_time+0x27a>
    1700:	84 30       	cpi	r24, 0x04	; 4
    1702:	79 f0       	breq	.+30     	; 0x1722 <fix_time+0x236>
    1704:	85 30       	cpi	r24, 0x05	; 5
    1706:	79 f5       	brne	.+94     	; 0x1766 <fix_time+0x27a>
    1708:	10 c0       	rjmp	.+32     	; 0x172a <fix_time+0x23e>
    170a:	8a 30       	cpi	r24, 0x0A	; 10
    170c:	1c f4       	brge	.+6      	; 0x1714 <fix_time+0x228>
    170e:	88 30       	cpi	r24, 0x08	; 8
    1710:	44 f4       	brge	.+16     	; 0x1722 <fix_time+0x236>
    1712:	0b c0       	rjmp	.+22     	; 0x172a <fix_time+0x23e>
    1714:	8b 30       	cpi	r24, 0x0B	; 11
    1716:	29 f0       	breq	.+10     	; 0x1722 <fix_time+0x236>
    1718:	8b 30       	cpi	r24, 0x0B	; 11
    171a:	3c f0       	brlt	.+14     	; 0x172a <fix_time+0x23e>
    171c:	8c 30       	cpi	r24, 0x0C	; 12
    171e:	19 f5       	brne	.+70     	; 0x1766 <fix_time+0x27a>
    1720:	04 c0       	rjmp	.+8      	; 0x172a <fix_time+0x23e>
			case 4: //April -> March
			case 6: //June -> May
			case 8: //August -> July
			case 9: //September -> August
			case 11: //November -> October
				date_d = 31 + date_d;
    1722:	80 91 d4 02 	lds	r24, 0x02D4
    1726:	81 5e       	subi	r24, 0xE1	; 225
    1728:	03 c0       	rjmp	.+6      	; 0x1730 <fix_time+0x244>

			case 5: //May -> April
			case 7: //July -> June
			case 10: //October -> September
			case 12: //December -> November
				date_d = 30 + date_d;
    172a:	80 91 d4 02 	lds	r24, 0x02D4
    172e:	82 5e       	subi	r24, 0xE2	; 226
    1730:	80 93 d4 02 	sts	0x02D4, r24
				date_m--;
    1734:	80 91 e4 02 	lds	r24, 0x02E4
    1738:	81 50       	subi	r24, 0x01	; 1
    173a:	80 93 e4 02 	sts	0x02E4, r24
    173e:	16 c0       	rjmp	.+44     	; 0x176c <fix_time+0x280>
				break;

			case 3: //March -> February, the fun case
				//If we are in a leapyear, February is 29 days long...
				if ( leapyear(2000+date_y) )
    1740:	80 91 d1 02 	lds	r24, 0x02D1
    1744:	99 27       	eor	r25, r25
    1746:	87 fd       	sbrc	r24, 7
    1748:	90 95       	com	r25
    174a:	80 53       	subi	r24, 0x30	; 48
    174c:	98 4f       	sbci	r25, 0xF8	; 248
    174e:	0e 94 02 02 	call	0x404	; 0x404 <leapyear>
    1752:	88 23       	and	r24, r24
    1754:	21 f0       	breq	.+8      	; 0x175e <fix_time+0x272>
					date_d = 29 + date_d;
    1756:	80 91 d4 02 	lds	r24, 0x02D4
    175a:	83 5e       	subi	r24, 0xE3	; 227
    175c:	e9 cf       	rjmp	.-46     	; 0x1730 <fix_time+0x244>
				else //otherwise, it is 28 days long...
					date_d = 28 + date_d;
    175e:	80 91 d4 02 	lds	r24, 0x02D4
    1762:	84 5e       	subi	r24, 0xE4	; 228
    1764:	e5 cf       	rjmp	.-54     	; 0x1730 <fix_time+0x244>
				date_m--;
				break;
			default:
				date_d = 1;
    1766:	81 e0       	ldi	r24, 0x01	; 1
    1768:	80 93 d4 02 	sts	0x02D4, r24
				break;
		}

		eeprom_write_byte((uint8_t *)EE_MONTH, date_m);
    176c:	20 91 e4 02 	lds	r18, 0x02E4
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1770:	f9 99       	sbic	0x1f, 1	; 31
    1772:	fe cf       	rjmp	.-4      	; 0x1770 <fix_time+0x284>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1774:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1776:	82 e0       	ldi	r24, 0x02	; 2
    1778:	90 e0       	ldi	r25, 0x00	; 0
    177a:	92 bd       	out	0x22, r25	; 34
    177c:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    177e:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    1780:	0f b6       	in	r0, 0x3f	; 63
    1782:	f8 94       	cli
    1784:	fa 9a       	sbi	0x1f, 2	; 31
    1786:	f9 9a       	sbi	0x1f, 1	; 31
    1788:	0f be       	out	0x3f, r0	; 63
	}

	// HAPPY NEW YEAR!
	if (date_m >= 13) {
    178a:	80 91 e4 02 	lds	r24, 0x02E4
    178e:	8d 30       	cpi	r24, 0x0D	; 13
    1790:	bc f0       	brlt	.+46     	; 0x17c0 <fix_time+0x2d4>
		date_y++;
    1792:	80 91 d1 02 	lds	r24, 0x02D1
    1796:	8f 5f       	subi	r24, 0xFF	; 255
    1798:	80 93 d1 02 	sts	0x02D1, r24
		date_m = 1;
    179c:	81 e0       	ldi	r24, 0x01	; 1
    179e:	80 93 e4 02 	sts	0x02E4, r24
		eeprom_write_byte((uint8_t *)EE_YEAR, date_y);
    17a2:	20 91 d1 02 	lds	r18, 0x02D1
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    17a6:	f9 99       	sbic	0x1f, 1	; 31
    17a8:	fe cf       	rjmp	.-4      	; 0x17a6 <fix_time+0x2ba>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    17aa:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    17ac:	81 e0       	ldi	r24, 0x01	; 1
    17ae:	90 e0       	ldi	r25, 0x00	; 0
    17b0:	92 bd       	out	0x22, r25	; 34
    17b2:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    17b4:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    17b6:	0f b6       	in	r0, 0x3f	; 63
    17b8:	f8 94       	cli
    17ba:	fa 9a       	sbi	0x1f, 2	; 31
    17bc:	f9 9a       	sbi	0x1f, 1	; 31
    17be:	0f be       	out	0x3f, r0	; 63
	}
	//This takes away the years and is cheaper than any cream you can buy...
	if (date_m < 1) {
    17c0:	80 91 e4 02 	lds	r24, 0x02E4
    17c4:	18 16       	cp	r1, r24
    17c6:	44 f1       	brlt	.+80     	; 0x1818 <fix_time+0x32c>
		date_m = 12 + date_m;
    17c8:	80 91 e4 02 	lds	r24, 0x02E4
    17cc:	84 5f       	subi	r24, 0xF4	; 244
    17ce:	80 93 e4 02 	sts	0x02E4, r24
		date_y--;
    17d2:	80 91 d1 02 	lds	r24, 0x02D1
    17d6:	81 50       	subi	r24, 0x01	; 1
    17d8:	80 93 d1 02 	sts	0x02D1, r24
		eeprom_write_byte((uint8_t *)EE_MONTH, date_m);
    17dc:	20 91 e4 02 	lds	r18, 0x02E4
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    17e0:	f9 99       	sbic	0x1f, 1	; 31
    17e2:	fe cf       	rjmp	.-4      	; 0x17e0 <fix_time+0x2f4>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    17e4:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    17e6:	82 e0       	ldi	r24, 0x02	; 2
    17e8:	90 e0       	ldi	r25, 0x00	; 0
    17ea:	92 bd       	out	0x22, r25	; 34
    17ec:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    17ee:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    17f0:	0f b6       	in	r0, 0x3f	; 63
    17f2:	f8 94       	cli
    17f4:	fa 9a       	sbi	0x1f, 2	; 31
    17f6:	f9 9a       	sbi	0x1f, 1	; 31
    17f8:	0f be       	out	0x3f, r0	; 63
		eeprom_write_byte((uint8_t *)EE_YEAR, date_y);
    17fa:	20 91 d1 02 	lds	r18, 0x02D1
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    17fe:	f9 99       	sbic	0x1f, 1	; 31
    1800:	fe cf       	rjmp	.-4      	; 0x17fe <fix_time+0x312>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1802:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1804:	81 e0       	ldi	r24, 0x01	; 1
    1806:	90 e0       	ldi	r25, 0x00	; 0
    1808:	92 bd       	out	0x22, r25	; 34
    180a:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    180c:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    180e:	0f b6       	in	r0, 0x3f	; 63
    1810:	f8 94       	cli
    1812:	fa 9a       	sbi	0x1f, 2	; 31
    1814:	f9 9a       	sbi	0x1f, 1	; 31
    1816:	0f be       	out	0x3f, r0	; 63
    1818:	08 95       	ret

0000181a <spi_xfer>:
	}
}

// Send 1 byte via SPI
void spi_xfer(uint8_t c) {
	SPDR = c;
    181a:	8e bd       	out	0x2e, r24	; 46
	while (! (SPSR & _BV(SPIF)))
    181c:	0d b4       	in	r0, 0x2d	; 45
    181e:	07 fe       	sbrs	r0, 7
    1820:	fd cf       	rjmp	.-6      	; 0x181c <spi_xfer+0x2>
		;
}
    1822:	08 95       	ret

00001824 <check_alarm>:
	VFDLOAD_PORT &= ~_BV(VFDLOAD);
	sei();
}

//Checks the alarm against the passed time.
void check_alarm(uint8_t h, uint8_t m, uint8_t s) {
    1824:	98 2f       	mov	r25, r24

	if (alarm_on && (alarm_h == h) && (alarm_m == m) && (0 == s)) {
    1826:	80 91 df 02 	lds	r24, 0x02DF
    182a:	88 23       	and	r24, r24
    182c:	b1 f0       	breq	.+44     	; 0x185a <check_alarm+0x36>
    182e:	80 91 e0 02 	lds	r24, 0x02E0
    1832:	89 17       	cp	r24, r25
    1834:	91 f4       	brne	.+36     	; 0x185a <check_alarm+0x36>
    1836:	80 91 d2 02 	lds	r24, 0x02D2
    183a:	86 17       	cp	r24, r22
    183c:	71 f4       	brne	.+28     	; 0x185a <check_alarm+0x36>
    183e:	44 23       	and	r20, r20
    1840:	61 f4       	brne	.+24     	; 0x185a <check_alarm+0x36>
		DEBUGP("alarm on!");
    1842:	8f ec       	ldi	r24, 0xCF	; 207
    1844:	90 e0       	ldi	r25, 0x00	; 0
    1846:	61 e0       	ldi	r22, 0x01	; 1
    1848:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <ROM_putstring>
		alarming = 1;
    184c:	81 e0       	ldi	r24, 0x01	; 1
    184e:	80 93 e2 02 	sts	0x02E2, r24
		snoozetimer = 0;
    1852:	10 92 44 02 	sts	0x0244, r1
    1856:	10 92 43 02 	sts	0x0243, r1
    185a:	08 95       	ret

0000185c <__vector_9>:
// This variable keeps track of whether we have not pressed any
// buttons in a few seconds, and turns off the menu display
volatile uint8_t timeoutcounter = 0;

// this goes off once a second
SIGNAL (TIMER2_OVF_vect) {
    185c:	1f 92       	push	r1
    185e:	0f 92       	push	r0
    1860:	0f b6       	in	r0, 0x3f	; 63
    1862:	0f 92       	push	r0
    1864:	11 24       	eor	r1, r1
    1866:	2f 93       	push	r18
    1868:	3f 93       	push	r19
    186a:	4f 93       	push	r20
    186c:	5f 93       	push	r21
    186e:	6f 93       	push	r22
    1870:	7f 93       	push	r23
    1872:	8f 93       	push	r24
    1874:	9f 93       	push	r25
    1876:	af 93       	push	r26
    1878:	bf 93       	push	r27
    187a:	ef 93       	push	r30
    187c:	ff 93       	push	r31
	CLKPR = _BV(CLKPCE);  //MEME
    187e:	80 e8       	ldi	r24, 0x80	; 128
    1880:	80 93 61 00 	sts	0x0061, r24
	CLKPR = 0;
    1884:	10 92 61 00 	sts	0x0061, r1

	time_s++;             // one second has gone by
    1888:	80 91 e5 02 	lds	r24, 0x02E5
    188c:	8f 5f       	subi	r24, 0xFF	; 255
    188e:	80 93 e5 02 	sts	0x02E5, r24

	fix_time();
    1892:	0e 94 76 0a 	call	0x14ec	; 0x14ec <fix_time>

	// If we're in low power mode we should get out now since the display is off
	if (sleepmode)
    1896:	80 91 39 02 	lds	r24, 0x0239
    189a:	88 23       	and	r24, r24
    189c:	09 f0       	breq	.+2      	; 0x18a0 <__vector_9+0x44>
    189e:	52 c0       	rjmp	.+164    	; 0x1944 <__vector_9+0xe8>
		return;


	if (displaymode == SHOW_TIME) {
    18a0:	80 91 e3 02 	lds	r24, 0x02E3
    18a4:	88 23       	and	r24, r24
    18a6:	a9 f4       	brne	.+42     	; 0x18d2 <__vector_9+0x76>
		display_time(time_h, time_m, time_s);
    18a8:	80 91 50 02 	lds	r24, 0x0250
    18ac:	60 91 de 02 	lds	r22, 0x02DE
    18b0:	40 91 e5 02 	lds	r20, 0x02E5
    18b4:	0e 94 ca 03 	call	0x794	; 0x794 <display_time>

		if (alarm_on)
    18b8:	80 91 df 02 	lds	r24, 0x02DF
    18bc:	88 23       	and	r24, r24
    18be:	21 f0       	breq	.+8      	; 0x18c8 <__vector_9+0x6c>
			display[0] |= 0x2;
    18c0:	80 91 d5 02 	lds	r24, 0x02D5
    18c4:	82 60       	ori	r24, 0x02	; 2
    18c6:	03 c0       	rjmp	.+6      	; 0x18ce <__vector_9+0x72>
		else 
			display[0] &= ~0x2;
    18c8:	80 91 d5 02 	lds	r24, 0x02D5
    18cc:	8d 7f       	andi	r24, 0xFD	; 253
    18ce:	80 93 d5 02 	sts	0x02D5, r24
	ADCSRA |= _BV(ADIE);  // Enable ADC interrupt
}

// Start ADC conversion for dimmer
void dimmer_update(void) {
	if (brightness_level == 0) 
    18d2:	80 91 e1 02 	lds	r24, 0x02E1
    18d6:	88 23       	and	r24, r24
    18d8:	29 f4       	brne	.+10     	; 0x18e4 <__vector_9+0x88>
		ADCSRA |= _BV(ADSC);
    18da:	80 91 7a 00 	lds	r24, 0x007A
    18de:	80 64       	ori	r24, 0x40	; 64
    18e0:	80 93 7a 00 	sts	0x007A, r24
	}

#ifdef FEATURE_AUTODIM
	dimmer_update();
#endif
	check_alarm(time_h, time_m, time_s);
    18e4:	80 91 50 02 	lds	r24, 0x0250
    18e8:	60 91 de 02 	lds	r22, 0x02DE
    18ec:	40 91 e5 02 	lds	r20, 0x02E5
    18f0:	0e 94 12 0c 	call	0x1824	; 0x1824 <check_alarm>

	if (timeoutcounter)
    18f4:	80 91 4b 02 	lds	r24, 0x024B
    18f8:	88 23       	and	r24, r24
    18fa:	29 f0       	breq	.+10     	; 0x1906 <__vector_9+0xaa>
		timeoutcounter--;
    18fc:	80 91 4b 02 	lds	r24, 0x024B
    1900:	81 50       	subi	r24, 0x01	; 1
    1902:	80 93 4b 02 	sts	0x024B, r24
	if (buttonholdcounter)
    1906:	80 91 4a 02 	lds	r24, 0x024A
    190a:	88 23       	and	r24, r24
    190c:	29 f0       	breq	.+10     	; 0x1918 <__vector_9+0xbc>
		buttonholdcounter--;
    190e:	80 91 4a 02 	lds	r24, 0x024A
    1912:	81 50       	subi	r24, 0x01	; 1
    1914:	80 93 4a 02 	sts	0x024A, r24
	if (snoozetimer) {
    1918:	80 91 43 02 	lds	r24, 0x0243
    191c:	90 91 44 02 	lds	r25, 0x0244
    1920:	00 97       	sbiw	r24, 0x00	; 0
    1922:	81 f0       	breq	.+32     	; 0x1944 <__vector_9+0xe8>
		snoozetimer--;
    1924:	01 97       	sbiw	r24, 0x01	; 1
    1926:	90 93 44 02 	sts	0x0244, r25
    192a:	80 93 43 02 	sts	0x0243, r24
		if (snoozetimer % 2) 
    192e:	80 ff       	sbrs	r24, 0
    1930:	04 c0       	rjmp	.+8      	; 0x193a <__vector_9+0xde>
			display[0] |= 0x2;
    1932:	80 91 d5 02 	lds	r24, 0x02D5
    1936:	82 60       	ori	r24, 0x02	; 2
    1938:	03 c0       	rjmp	.+6      	; 0x1940 <__vector_9+0xe4>
		else
			display[0] &= ~0x2;
    193a:	80 91 d5 02 	lds	r24, 0x02D5
    193e:	8d 7f       	andi	r24, 0xFD	; 253
    1940:	80 93 d5 02 	sts	0x02D5, r24
	}
}
    1944:	ff 91       	pop	r31
    1946:	ef 91       	pop	r30
    1948:	bf 91       	pop	r27
    194a:	af 91       	pop	r26
    194c:	9f 91       	pop	r25
    194e:	8f 91       	pop	r24
    1950:	7f 91       	pop	r23
    1952:	6f 91       	pop	r22
    1954:	5f 91       	pop	r21
    1956:	4f 91       	pop	r20
    1958:	3f 91       	pop	r19
    195a:	2f 91       	pop	r18
    195c:	0f 90       	pop	r0
    195e:	0f be       	out	0x3f, r0	; 63
    1960:	0f 90       	pop	r0
    1962:	1f 90       	pop	r1
    1964:	18 95       	reti

00001966 <setalarmstate>:
}

// This turns on/off the alarm when the switch has been
// set. It also displays the alarm time
void setalarmstate(void) {
	if (ALARM_PIN & _BV(ALARM)) { 
    1966:	4a 9b       	sbis	0x09, 2	; 9
    1968:	34 c0       	rjmp	.+104    	; 0x19d2 <setalarmstate+0x6c>
		// Don't display the alarm/beep if we already have
		if  (!alarm_on) {
    196a:	80 91 df 02 	lds	r24, 0x02DF
    196e:	88 23       	and	r24, r24
    1970:	09 f0       	breq	.+2      	; 0x1974 <setalarmstate+0xe>
    1972:	4c c0       	rjmp	.+152    	; 0x1a0c <setalarmstate+0xa6>
			// alarm on!
			alarm_on = 1;
    1974:	81 e0       	ldi	r24, 0x01	; 1
    1976:	80 93 df 02 	sts	0x02DF, r24
			// reset snoozing
			snoozetimer = 0;
    197a:	10 92 44 02 	sts	0x0244, r1
    197e:	10 92 43 02 	sts	0x0243, r1
			// show the status on the VFD tube
			display_str("alarm on");
    1982:	82 ea       	ldi	r24, 0xA2	; 162
    1984:	91 e0       	ldi	r25, 0x01	; 1
    1986:	0e 94 2d 06 	call	0xc5a	; 0xc5a <display_str>
			// its not actually SHOW_SNOOZE but just anything but SHOW_TIME
			displaymode = SHOW_SNOOZE;
    198a:	89 e0       	ldi	r24, 0x09	; 9
    198c:	80 93 e3 02 	sts	0x02E3, r24

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    1990:	78 94       	sei

	milliseconds = 0;
    1992:	10 92 46 02 	sts	0x0246, r1
    1996:	10 92 45 02 	sts	0x0245, r1
	while (milliseconds < ms);
    199a:	80 91 45 02 	lds	r24, 0x0245
    199e:	90 91 46 02 	lds	r25, 0x0246
    19a2:	88 5e       	subi	r24, 0xE8	; 232
    19a4:	93 40       	sbci	r25, 0x03	; 3
    19a6:	c8 f3       	brcs	.-14     	; 0x199a <setalarmstate+0x34>
			display_str("alarm on");
			// its not actually SHOW_SNOOZE but just anything but SHOW_TIME
			displaymode = SHOW_SNOOZE;
			delayms(1000);
			// show the current alarm time set
			display_alarm(alarm_h, alarm_m);
    19a8:	80 91 e0 02 	lds	r24, 0x02E0
    19ac:	60 91 d2 02 	lds	r22, 0x02D2
    19b0:	0e 94 72 04 	call	0x8e4	; 0x8e4 <display_alarm>

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    19b4:	78 94       	sei

	milliseconds = 0;
    19b6:	10 92 46 02 	sts	0x0246, r1
    19ba:	10 92 45 02 	sts	0x0245, r1
	while (milliseconds < ms);
    19be:	80 91 45 02 	lds	r24, 0x0245
    19c2:	90 91 46 02 	lds	r25, 0x0246
    19c6:	88 5e       	subi	r24, 0xE8	; 232
    19c8:	93 40       	sbci	r25, 0x03	; 3
    19ca:	c8 f3       	brcs	.-14     	; 0x19be <setalarmstate+0x58>
			delayms(1000);
			// show the current alarm time set
			display_alarm(alarm_h, alarm_m);
			delayms(1000);
			// after a second, go back to clock mode
			displaymode = SHOW_TIME;
    19cc:	10 92 e3 02 	sts	0x02E3, r1
    19d0:	08 95       	ret
		}
	} else {
		if (alarm_on) {
    19d2:	80 91 df 02 	lds	r24, 0x02DF
    19d6:	88 23       	and	r24, r24
    19d8:	c9 f0       	breq	.+50     	; 0x1a0c <setalarmstate+0xa6>
			// turn off the alarm
			alarm_on = 0;
    19da:	10 92 df 02 	sts	0x02DF, r1
			snoozetimer = 0;
    19de:	10 92 44 02 	sts	0x0244, r1
    19e2:	10 92 43 02 	sts	0x0243, r1
			if (alarming) {
    19e6:	80 91 e2 02 	lds	r24, 0x02E2
    19ea:	88 23       	and	r24, r24
    19ec:	79 f0       	breq	.+30     	; 0x1a0c <setalarmstate+0xa6>
				// if the alarm is going off, we should turn it off
				// and quiet the speaker
				DEBUGP("alarm off");
    19ee:	89 ed       	ldi	r24, 0xD9	; 217
    19f0:	90 e0       	ldi	r25, 0x00	; 0
    19f2:	61 e0       	ldi	r22, 0x01	; 1
    19f4:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <ROM_putstring>
				alarming = 0;
    19f8:	10 92 e2 02 	sts	0x02E2, r1
				TCCR1B &= ~_BV(CS11); // turn it off!
    19fc:	80 91 81 00 	lds	r24, 0x0081
    1a00:	8d 7f       	andi	r24, 0xFD	; 253
    1a02:	80 93 81 00 	sts	0x0081, r24
				PORTB |= _BV(SPK1) | _BV(SPK2);
    1a06:	85 b1       	in	r24, 0x05	; 5
    1a08:	86 60       	ori	r24, 0x06	; 6
    1a0a:	85 b9       	out	0x05, r24	; 5
    1a0c:	08 95       	ret

00001a0e <wakeup>:
	CLKPR = 0;
	PORTC &= ~_BV(4);
}

void wakeup(void) {
	if (!sleepmode)
    1a0e:	80 91 39 02 	lds	r24, 0x0239
    1a12:	88 23       	and	r24, r24
    1a14:	09 f4       	brne	.+2      	; 0x1a18 <wakeup+0xa>
    1a16:	58 c0       	rjmp	.+176    	; 0x1ac8 <wakeup+0xba>
		return;
	CLKPR = _BV(CLKPCE);
    1a18:	80 e8       	ldi	r24, 0x80	; 128
    1a1a:	80 93 61 00 	sts	0x0061, r24
	CLKPR = 0;
    1a1e:	10 92 61 00 	sts	0x0061, r1
	DEBUGP("waketime");
    1a22:	86 e7       	ldi	r24, 0x76	; 118
    1a24:	91 e0       	ldi	r25, 0x01	; 1
    1a26:	61 e0       	ldi	r22, 0x01	; 1
    1a28:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <ROM_putstring>
	sleepmode = 0;
    1a2c:	10 92 39 02 	sts	0x0239, r1
    1a30:	80 e4       	ldi	r24, 0x40	; 64
    1a32:	9c e9       	ldi	r25, 0x9C	; 156
    1a34:	01 97       	sbiw	r24, 0x01	; 1
    1a36:	f1 f7       	brne	.-4      	; 0x1a34 <wakeup+0x26>
	// plugged in
	// wait to verify
	_delay_ms(20);
	if (ACSR & _BV(ACO)) 
    1a38:	00 b6       	in	r0, 0x30	; 48
    1a3a:	05 fc       	sbrc	r0, 5
    1a3c:	45 c0       	rjmp	.+138    	; 0x1ac8 <wakeup+0xba>
	kickthedog();
}


void initbuttons(void) {
	DDRB =  _BV(VFDCLK) | _BV(VFDDATA) | _BV(SPK1) | _BV(SPK2);
    1a3e:	8e e2       	ldi	r24, 0x2E	; 46
    1a40:	84 b9       	out	0x04, r24	; 4
	DDRD = _BV(BOOST) | _BV(VFDSWITCH);
    1a42:	88 e4       	ldi	r24, 0x48	; 72
    1a44:	8a b9       	out	0x0a, r24	; 10
	DDRC = _BV(VFDLOAD) | _BV(VFDBLANK);
    1a46:	89 e0       	ldi	r24, 0x09	; 9
    1a48:	87 b9       	out	0x07, r24	; 7
	PORTD = _BV(BUTTON1) | _BV(BUTTON3) | _BV(ALARM);
    1a4a:	84 e3       	ldi	r24, 0x34	; 52
    1a4c:	8b b9       	out	0x0b, r24	; 11
	PORTB = _BV(BUTTON2);
    1a4e:	91 e0       	ldi	r25, 0x01	; 1
    1a50:	95 b9       	out	0x05, r25	; 5

	PCICR = _BV(PCIE0) | _BV(PCIE2);
    1a52:	85 e0       	ldi	r24, 0x05	; 5
    1a54:	80 93 68 00 	sts	0x0068, r24
	PCMSK0 = _BV(PCINT0);
    1a58:	90 93 6b 00 	sts	0x006B, r25
	PCMSK2 = _BV(PCINT21) | _BV(PCINT20);    
    1a5c:	80 e3       	ldi	r24, 0x30	; 48
    1a5e:	80 93 6d 00 	sts	0x006D, r24

	// turn on pullups
	initbuttons();

#ifdef FEATURE_AUTODIM
	dimmer_init();
    1a62:	0e 94 23 03 	call	0x646	; 0x646 <dimmer_init>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1a66:	f9 99       	sbic	0x1f, 1	; 31
    1a68:	fe cf       	rjmp	.-4      	; 0x1a66 <wakeup+0x58>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    1a6a:	89 e0       	ldi	r24, 0x09	; 9
    1a6c:	90 e0       	ldi	r25, 0x00	; 0
    1a6e:	92 bd       	out	0x22, r25	; 34
    1a70:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1a72:	f8 9a       	sbi	0x1f, 0	; 31
    1a74:	80 b5       	in	r24, 0x20	; 32
#endif

	// turn on boost
	brightness_level = eeprom_read_byte((uint8_t *)EE_BRIGHT);
    1a76:	80 93 e1 02 	sts	0x02E1, r24
	boost_init(brightness_level);
    1a7a:	80 91 e1 02 	lds	r24, 0x02E1
    1a7e:	0e 94 a5 03 	call	0x74a	; 0x74a <boost_init>

/************************* LOW LEVEL DISPLAY ************************/

// Setup SPI
void vfd_init(void) {
	SPCR  = _BV(SPE) | _BV(MSTR) | _BV(SPR0);
    1a82:	81 e5       	ldi	r24, 0x51	; 81
    1a84:	8c bd       	out	0x2c, r24	; 44

	// turn on vfd control
	vfd_init();

	// turn on display
	VFDSWITCH_PORT &= ~_BV(VFDSWITCH); 
    1a86:	5b 98       	cbi	0x0b, 3	; 11
	VFDBLANK_PORT &= ~_BV(VFDBLANK);
    1a88:	43 98       	cbi	0x08, 3	; 8
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1a8a:	f9 99       	sbic	0x1f, 1	; 31
    1a8c:	fe cf       	rjmp	.-4      	; 0x1a8a <wakeup+0x7c>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    1a8e:	8a e0       	ldi	r24, 0x0A	; 10
    1a90:	90 e0       	ldi	r25, 0x00	; 0
    1a92:	92 bd       	out	0x22, r25	; 34
    1a94:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1a96:	f8 9a       	sbi	0x1f, 0	; 31
    1a98:	80 b5       	in	r24, 0x20	; 32
	volume = eeprom_read_byte((uint8_t *)EE_VOLUME); // reset
    1a9a:	80 93 d3 02 	sts	0x02D3, r24

	speaker_init();
    1a9e:	0e 94 7f 02 	call	0x4fe	; 0x4fe <speaker_init>
	displaymode = SHOW_TIME;
}

// we reset the watchdog timer 
void kickthedog(void) {
	wdt_reset();
    1aa2:	a8 95       	wdr

	speaker_init();

	kickthedog();

	setalarmstate();
    1aa4:	0e 94 b3 0c 	call	0x1966	; 0x1966 <setalarmstate>

	// wake up sound
	beep(880, 1);
    1aa8:	80 e7       	ldi	r24, 0x70	; 112
    1aaa:	93 e0       	ldi	r25, 0x03	; 3
    1aac:	61 e0       	ldi	r22, 0x01	; 1
    1aae:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <beep>
	beep(1760, 1);
    1ab2:	80 ee       	ldi	r24, 0xE0	; 224
    1ab4:	96 e0       	ldi	r25, 0x06	; 6
    1ab6:	61 e0       	ldi	r22, 0x01	; 1
    1ab8:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <beep>
	beep(3520, 1);
    1abc:	80 ec       	ldi	r24, 0xC0	; 192
    1abe:	9d e0       	ldi	r25, 0x0D	; 13
    1ac0:	61 e0       	ldi	r22, 0x01	; 1
    1ac2:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <beep>
	displaymode = SHOW_TIME;
}

// we reset the watchdog timer 
void kickthedog(void) {
	wdt_reset();
    1ac6:	a8 95       	wdr
    1ac8:	08 95       	ret

00001aca <__vector_23>:
	EIMSK = _BV(INT0);  //And reenable it before exiting.
}



SIGNAL(SIG_COMPARATOR) {
    1aca:	1f 92       	push	r1
    1acc:	0f 92       	push	r0
    1ace:	0f b6       	in	r0, 0x3f	; 63
    1ad0:	0f 92       	push	r0
    1ad2:	11 24       	eor	r1, r1
    1ad4:	2f 93       	push	r18
    1ad6:	3f 93       	push	r19
    1ad8:	4f 93       	push	r20
    1ada:	5f 93       	push	r21
    1adc:	6f 93       	push	r22
    1ade:	7f 93       	push	r23
    1ae0:	8f 93       	push	r24
    1ae2:	9f 93       	push	r25
    1ae4:	af 93       	push	r26
    1ae6:	bf 93       	push	r27
    1ae8:	ef 93       	push	r30
    1aea:	ff 93       	push	r31
	//DEBUGP("COMP");
	if (ACSR & _BV(ACO)) {
    1aec:	00 b6       	in	r0, 0x30	; 48
    1aee:	05 fe       	sbrs	r0, 5
    1af0:	3b c0       	rjmp	.+118    	; 0x1b68 <__vector_23+0x9e>
		//DEBUGP("HIGH");
		if (!sleepmode) {
    1af2:	80 91 39 02 	lds	r24, 0x0239
    1af6:	88 23       	and	r24, r24
    1af8:	09 f0       	breq	.+2      	; 0x1afc <__vector_23+0x32>
    1afa:	66 c0       	rjmp	.+204    	; 0x1bc8 <__vector_23+0xfe>
			VFDSWITCH_PORT |= _BV(VFDSWITCH); // turn off display
    1afc:	5b 9a       	sbi	0x0b, 3	; 11
			VFDCLK_PORT &= ~_BV(VFDCLK) & ~_BV(VFDDATA); // no power to vfdchip
    1afe:	85 b1       	in	r24, 0x05	; 5
    1b00:	87 7d       	andi	r24, 0xD7	; 215
    1b02:	85 b9       	out	0x05, r24	; 5
			BOOST_PORT &= ~_BV(BOOST); // pull boost fet low
    1b04:	5e 98       	cbi	0x0b, 6	; 11
			SPCR  &= ~_BV(SPE); // turn off spi
    1b06:	8c b5       	in	r24, 0x2c	; 44
    1b08:	8f 7b       	andi	r24, 0xBF	; 191
    1b0a:	8c bd       	out	0x2c, r24	; 44
			if (restored) {
    1b0c:	80 91 3a 02 	lds	r24, 0x023A
    1b10:	88 23       	and	r24, r24
    1b12:	f1 f0       	breq	.+60     	; 0x1b50 <__vector_23+0x86>
				eeprom_write_byte((uint8_t *)EE_MIN, time_m);
    1b14:	20 91 de 02 	lds	r18, 0x02DE
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1b18:	f9 99       	sbic	0x1f, 1	; 31
    1b1a:	fe cf       	rjmp	.-4      	; 0x1b18 <__vector_23+0x4e>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1b1c:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1b1e:	85 e0       	ldi	r24, 0x05	; 5
    1b20:	90 e0       	ldi	r25, 0x00	; 0
    1b22:	92 bd       	out	0x22, r25	; 34
    1b24:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    1b26:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    1b28:	0f b6       	in	r0, 0x3f	; 63
    1b2a:	f8 94       	cli
    1b2c:	fa 9a       	sbi	0x1f, 2	; 31
    1b2e:	f9 9a       	sbi	0x1f, 1	; 31
    1b30:	0f be       	out	0x3f, r0	; 63
				eeprom_write_byte((uint8_t *)EE_SEC, time_s);
    1b32:	20 91 e5 02 	lds	r18, 0x02E5
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1b36:	f9 99       	sbic	0x1f, 1	; 31
    1b38:	fe cf       	rjmp	.-4      	; 0x1b36 <__vector_23+0x6c>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1b3a:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1b3c:	86 e0       	ldi	r24, 0x06	; 6
    1b3e:	90 e0       	ldi	r25, 0x00	; 0
    1b40:	92 bd       	out	0x22, r25	; 34
    1b42:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    1b44:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    1b46:	0f b6       	in	r0, 0x3f	; 63
    1b48:	f8 94       	cli
    1b4a:	fa 9a       	sbi	0x1f, 2	; 31
    1b4c:	f9 9a       	sbi	0x1f, 1	; 31
    1b4e:	0f be       	out	0x3f, r0	; 63
			}
			DEBUGP("z");
    1b50:	89 e8       	ldi	r24, 0x89	; 137
    1b52:	91 e0       	ldi	r25, 0x01	; 1
    1b54:	61 e0       	ldi	r22, 0x01	; 1
    1b56:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <ROM_putstring>
			TCCR0B = 0; // no boost
    1b5a:	15 bc       	out	0x25, r1	; 37
			volume = 0; // low power buzzer
    1b5c:	10 92 d3 02 	sts	0x02D3, r1
			PCICR = 0;  // ignore buttons
    1b60:	10 92 68 00 	sts	0x0068, r1
#ifdef FEATURE_AUTODIM
			DIMMER_POWER_PORT &= ~_BV(DIMMER_POWER_PIN); // no power to photoresistor
    1b64:	45 98       	cbi	0x08, 5	; 8
    1b66:	2b c0       	rjmp	.+86     	; 0x1bbe <__vector_23+0xf4>

			app_start();
		}
	} else {
		//DEBUGP("LOW");
		if (sleepmode) {
    1b68:	80 91 39 02 	lds	r24, 0x0239
    1b6c:	88 23       	and	r24, r24
    1b6e:	61 f1       	breq	.+88     	; 0x1bc8 <__vector_23+0xfe>
			if (restored) {
    1b70:	80 91 3a 02 	lds	r24, 0x023A
    1b74:	88 23       	and	r24, r24
    1b76:	f1 f0       	breq	.+60     	; 0x1bb4 <__vector_23+0xea>
				eeprom_write_byte((uint8_t *)EE_MIN, time_m);
    1b78:	20 91 de 02 	lds	r18, 0x02DE
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1b7c:	f9 99       	sbic	0x1f, 1	; 31
    1b7e:	fe cf       	rjmp	.-4      	; 0x1b7c <__vector_23+0xb2>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1b80:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1b82:	85 e0       	ldi	r24, 0x05	; 5
    1b84:	90 e0       	ldi	r25, 0x00	; 0
    1b86:	92 bd       	out	0x22, r25	; 34
    1b88:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    1b8a:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    1b8c:	0f b6       	in	r0, 0x3f	; 63
    1b8e:	f8 94       	cli
    1b90:	fa 9a       	sbi	0x1f, 2	; 31
    1b92:	f9 9a       	sbi	0x1f, 1	; 31
    1b94:	0f be       	out	0x3f, r0	; 63
				eeprom_write_byte((uint8_t *)EE_SEC, time_s);
    1b96:	20 91 e5 02 	lds	r18, 0x02E5
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1b9a:	f9 99       	sbic	0x1f, 1	; 31
    1b9c:	fe cf       	rjmp	.-4      	; 0x1b9a <__vector_23+0xd0>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1b9e:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1ba0:	86 e0       	ldi	r24, 0x06	; 6
    1ba2:	90 e0       	ldi	r25, 0x00	; 0
    1ba4:	92 bd       	out	0x22, r25	; 34
    1ba6:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    1ba8:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    1baa:	0f b6       	in	r0, 0x3f	; 63
    1bac:	f8 94       	cli
    1bae:	fa 9a       	sbi	0x1f, 2	; 31
    1bb0:	f9 9a       	sbi	0x1f, 1	; 31
    1bb2:	0f be       	out	0x3f, r0	; 63
			}
			DEBUGP("WAKERESET"); 
    1bb4:	8f e7       	ldi	r24, 0x7F	; 127
    1bb6:	91 e0       	ldi	r25, 0x01	; 1
    1bb8:	61 e0       	ldi	r22, 0x01	; 1
    1bba:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <ROM_putstring>
			app_start();
    1bbe:	e0 91 36 02 	lds	r30, 0x0236
    1bc2:	f0 91 37 02 	lds	r31, 0x0237
    1bc6:	09 95       	icall
		}
	}
}
    1bc8:	ff 91       	pop	r31
    1bca:	ef 91       	pop	r30
    1bcc:	bf 91       	pop	r27
    1bce:	af 91       	pop	r26
    1bd0:	9f 91       	pop	r25
    1bd2:	8f 91       	pop	r24
    1bd4:	7f 91       	pop	r23
    1bd6:	6f 91       	pop	r22
    1bd8:	5f 91       	pop	r21
    1bda:	4f 91       	pop	r20
    1bdc:	3f 91       	pop	r19
    1bde:	2f 91       	pop	r18
    1be0:	0f 90       	pop	r0
    1be2:	0f be       	out	0x3f, r0	; 63
    1be4:	0f 90       	pop	r0
    1be6:	1f 90       	pop	r1
    1be8:	18 95       	reti

00001bea <setsnooze>:
// this sets the snoozetimer off in MAXSNOOZE seconds - which turns on
// the alarm again
void setsnooze(void) {
	//snoozetimer = eeprom_read_byte((uint8_t *)EE_SNOOZE);
	//snoozetimer *= 60; // convert minutes to seconds
	snoozetimer = MAXSNOOZE;
    1bea:	88 e5       	ldi	r24, 0x58	; 88
    1bec:	92 e0       	ldi	r25, 0x02	; 2
    1bee:	90 93 44 02 	sts	0x0244, r25
    1bf2:	80 93 43 02 	sts	0x0243, r24
	DEBUGP("snooze");
    1bf6:	84 e9       	ldi	r24, 0x94	; 148
    1bf8:	91 e0       	ldi	r25, 0x01	; 1
    1bfa:	61 e0       	ldi	r22, 0x01	; 1
    1bfc:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <ROM_putstring>
	display_str("snoozing");
    1c00:	8b ea       	ldi	r24, 0xAB	; 171
    1c02:	91 e0       	ldi	r25, 0x01	; 1
    1c04:	0e 94 2d 06 	call	0xc5a	; 0xc5a <display_str>
	displaymode = SHOW_SNOOZE;
    1c08:	89 e0       	ldi	r24, 0x09	; 9
    1c0a:	80 93 e3 02 	sts	0x02E3, r24

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    1c0e:	78 94       	sei

	milliseconds = 0;
    1c10:	10 92 46 02 	sts	0x0246, r1
    1c14:	10 92 45 02 	sts	0x0245, r1
	while (milliseconds < ms);
    1c18:	80 91 45 02 	lds	r24, 0x0245
    1c1c:	90 91 46 02 	lds	r25, 0x0246
    1c20:	88 5e       	subi	r24, 0xE8	; 232
    1c22:	93 40       	sbci	r25, 0x03	; 3
    1c24:	c8 f3       	brcs	.-14     	; 0x1c18 <setsnooze+0x2e>
	snoozetimer = MAXSNOOZE;
	DEBUGP("snooze");
	display_str("snoozing");
	displaymode = SHOW_SNOOZE;
	delayms(1000);
	displaymode = SHOW_TIME;
    1c26:	10 92 e3 02 	sts	0x02E3, r1
}
    1c2a:	08 95       	ret

00001c2c <__vector_3>:
	}
	PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
}

// Just button #2
SIGNAL(SIG_PIN_CHANGE0) {
    1c2c:	1f 92       	push	r1
    1c2e:	0f 92       	push	r0
    1c30:	0f b6       	in	r0, 0x3f	; 63
    1c32:	0f 92       	push	r0
    1c34:	11 24       	eor	r1, r1
    1c36:	2f 93       	push	r18
    1c38:	3f 93       	push	r19
    1c3a:	4f 93       	push	r20
    1c3c:	5f 93       	push	r21
    1c3e:	6f 93       	push	r22
    1c40:	7f 93       	push	r23
    1c42:	8f 93       	push	r24
    1c44:	9f 93       	push	r25
    1c46:	af 93       	push	r26
    1c48:	bf 93       	push	r27
    1c4a:	ef 93       	push	r30
    1c4c:	ff 93       	push	r31
	PCMSK0 = 0;
    1c4e:	10 92 6b 00 	sts	0x006B, r1
	sei();
    1c52:	78 94       	sei
	if (! (PINB & _BV(BUTTON2))) {
    1c54:	18 99       	sbic	0x03, 0	; 3
    1c56:	2a c0       	rjmp	.+84     	; 0x1cac <__vector_3+0x80>
		// button2 is pressed
		if (! (last_buttonstate & 0x2)) { // was not pressed before
    1c58:	80 91 47 02 	lds	r24, 0x0247
    1c5c:	81 fd       	sbrc	r24, 1
    1c5e:	2b c0       	rjmp	.+86     	; 0x1cb6 <__vector_3+0x8a>

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    1c60:	78 94       	sei

	milliseconds = 0;
    1c62:	10 92 46 02 	sts	0x0246, r1
    1c66:	10 92 45 02 	sts	0x0245, r1
	while (milliseconds < ms);
    1c6a:	80 91 45 02 	lds	r24, 0x0245
    1c6e:	90 91 46 02 	lds	r25, 0x0246
    1c72:	0a 97       	sbiw	r24, 0x0a	; 10
    1c74:	d0 f3       	brcs	.-12     	; 0x1c6a <__vector_3+0x3e>
	sei();
	if (! (PINB & _BV(BUTTON2))) {
		// button2 is pressed
		if (! (last_buttonstate & 0x2)) { // was not pressed before
			delayms(10);                    // debounce
			if (PINB & _BV(BUTTON2))        // filter out bounces
    1c76:	18 99       	sbic	0x03, 0	; 3
    1c78:	1e c0       	rjmp	.+60     	; 0x1cb6 <__vector_3+0x8a>
			{
				PCMSK0 = _BV(PCINT0);
				return;
			}
			tick();                         // make a noise
    1c7a:	0e 94 b4 02 	call	0x568	; 0x568 <tick>
			// check if we will snag this button press for snoozing
			if (alarming) {
    1c7e:	80 91 e2 02 	lds	r24, 0x02E2
    1c82:	88 23       	and	r24, r24
    1c84:	19 f0       	breq	.+6      	; 0x1c8c <__vector_3+0x60>
				setsnooze(); 	// turn on snooze
    1c86:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <setsnooze>
    1c8a:	15 c0       	rjmp	.+42     	; 0x1cb6 <__vector_3+0x8a>
				PCMSK0 = _BV(PCINT0);
				return;
			}
			last_buttonstate |= 0x2;
    1c8c:	80 91 47 02 	lds	r24, 0x0247
    1c90:	82 60       	ori	r24, 0x02	; 2
    1c92:	80 93 47 02 	sts	0x0247, r24
			just_pressed |= 0x2;
    1c96:	80 91 48 02 	lds	r24, 0x0248
    1c9a:	82 60       	ori	r24, 0x02	; 2
    1c9c:	80 93 48 02 	sts	0x0248, r24
			DEBUGP("b2");
    1ca0:	8b e8       	ldi	r24, 0x8B	; 139
    1ca2:	91 e0       	ldi	r25, 0x01	; 1
    1ca4:	61 e0       	ldi	r22, 0x01	; 1
    1ca6:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <ROM_putstring>
    1caa:	05 c0       	rjmp	.+10     	; 0x1cb6 <__vector_3+0x8a>
		}
	} else {
		last_buttonstate &= ~0x2;
    1cac:	80 91 47 02 	lds	r24, 0x0247
    1cb0:	8d 7f       	andi	r24, 0xFD	; 253
    1cb2:	80 93 47 02 	sts	0x0247, r24
	}
	PCMSK0 = _BV(PCINT0);
    1cb6:	81 e0       	ldi	r24, 0x01	; 1
    1cb8:	80 93 6b 00 	sts	0x006B, r24
}
    1cbc:	ff 91       	pop	r31
    1cbe:	ef 91       	pop	r30
    1cc0:	bf 91       	pop	r27
    1cc2:	af 91       	pop	r26
    1cc4:	9f 91       	pop	r25
    1cc6:	8f 91       	pop	r24
    1cc8:	7f 91       	pop	r23
    1cca:	6f 91       	pop	r22
    1ccc:	5f 91       	pop	r21
    1cce:	4f 91       	pop	r20
    1cd0:	3f 91       	pop	r19
    1cd2:	2f 91       	pop	r18
    1cd4:	0f 90       	pop	r0
    1cd6:	0f be       	out	0x3f, r0	; 63
    1cd8:	0f 90       	pop	r0
    1cda:	1f 90       	pop	r1
    1cdc:	18 95       	reti

00001cde <__vector_5>:
// This allows for 'high speed incrementing' when setting the time
volatile uint8_t last_buttonstate = 0, just_pressed = 0, pressed = 0;
volatile uint8_t buttonholdcounter = 0;

// This interrupt detects switches 1 and 3
SIGNAL(SIG_PIN_CHANGE2) {
    1cde:	1f 92       	push	r1
    1ce0:	0f 92       	push	r0
    1ce2:	0f b6       	in	r0, 0x3f	; 63
    1ce4:	0f 92       	push	r0
    1ce6:	11 24       	eor	r1, r1
    1ce8:	2f 93       	push	r18
    1cea:	3f 93       	push	r19
    1cec:	4f 93       	push	r20
    1cee:	5f 93       	push	r21
    1cf0:	6f 93       	push	r22
    1cf2:	7f 93       	push	r23
    1cf4:	8f 93       	push	r24
    1cf6:	9f 93       	push	r25
    1cf8:	af 93       	push	r26
    1cfa:	bf 93       	push	r27
    1cfc:	ef 93       	push	r30
    1cfe:	ff 93       	push	r31
	// allow interrupts while we're doing this
	PCMSK2 = 0;
    1d00:	10 92 6d 00 	sts	0x006D, r1
	sei();
    1d04:	78 94       	sei
	displaymode = SHOW_TIME;
}

// we reset the watchdog timer 
void kickthedog(void) {
	wdt_reset();
    1d06:	a8 95       	wdr
	PCMSK2 = 0;
	sei();
	// kick the dog
	kickthedog();

	if (! (PIND & _BV(BUTTON1))) {
    1d08:	4d 99       	sbic	0x09, 5	; 9
    1d0a:	27 c0       	rjmp	.+78     	; 0x1d5a <__vector_5+0x7c>
		// button1 is pressed
		if (! (last_buttonstate & 0x1)) { // was not pressed before
    1d0c:	80 91 47 02 	lds	r24, 0x0247
    1d10:	80 fd       	sbrc	r24, 0
    1d12:	28 c0       	rjmp	.+80     	; 0x1d64 <__vector_5+0x86>

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    1d14:	78 94       	sei

	milliseconds = 0;
    1d16:	10 92 46 02 	sts	0x0246, r1
    1d1a:	10 92 45 02 	sts	0x0245, r1
	while (milliseconds < ms);
    1d1e:	80 91 45 02 	lds	r24, 0x0245
    1d22:	90 91 46 02 	lds	r25, 0x0246
    1d26:	0a 97       	sbiw	r24, 0x0a	; 10
    1d28:	d0 f3       	brcs	.-12     	; 0x1d1e <__vector_5+0x40>

	if (! (PIND & _BV(BUTTON1))) {
		// button1 is pressed
		if (! (last_buttonstate & 0x1)) { // was not pressed before
			delayms(10);                    // debounce
			if (PIND & _BV(BUTTON1))        // filter out bounces
    1d2a:	4d 99       	sbic	0x09, 5	; 9
    1d2c:	63 c0       	rjmp	.+198    	; 0x1df4 <__vector_5+0x116>
			{
				PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
				return;
			}
			tick();                         // make a noise
    1d2e:	0e 94 b4 02 	call	0x568	; 0x568 <tick>
			// check if we will snag this button press for snoozing
			if (alarming) {
    1d32:	80 91 e2 02 	lds	r24, 0x02E2
    1d36:	88 23       	and	r24, r24
    1d38:	c9 f5       	brne	.+114    	; 0x1dac <__vector_5+0xce>
				// turn on snooze
				setsnooze();
				PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
				return;
			}
			last_buttonstate |= 0x1;
    1d3a:	80 91 47 02 	lds	r24, 0x0247
    1d3e:	81 60       	ori	r24, 0x01	; 1
    1d40:	80 93 47 02 	sts	0x0247, r24
			just_pressed |= 0x1;
    1d44:	80 91 48 02 	lds	r24, 0x0248
    1d48:	81 60       	ori	r24, 0x01	; 1
    1d4a:	80 93 48 02 	sts	0x0248, r24
			DEBUGP("b1");
    1d4e:	81 e9       	ldi	r24, 0x91	; 145
    1d50:	91 e0       	ldi	r25, 0x01	; 1
    1d52:	61 e0       	ldi	r22, 0x01	; 1
    1d54:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <ROM_putstring>
    1d58:	05 c0       	rjmp	.+10     	; 0x1d64 <__vector_5+0x86>
		}
	} else {
		last_buttonstate &= ~0x1;
    1d5a:	80 91 47 02 	lds	r24, 0x0247
    1d5e:	8e 7f       	andi	r24, 0xFE	; 254
    1d60:	80 93 47 02 	sts	0x0247, r24
	}

	if (! (PIND & _BV(BUTTON3))) {
    1d64:	4c 99       	sbic	0x09, 4	; 9
    1d66:	3f c0       	rjmp	.+126    	; 0x1de6 <__vector_5+0x108>
		// button3 is pressed
		if (! (last_buttonstate & 0x4)) { // was not pressed before
    1d68:	80 91 47 02 	lds	r24, 0x0247
    1d6c:	82 fd       	sbrc	r24, 2
    1d6e:	42 c0       	rjmp	.+132    	; 0x1df4 <__vector_5+0x116>

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    1d70:	78 94       	sei

	milliseconds = 0;
    1d72:	10 92 46 02 	sts	0x0246, r1
    1d76:	10 92 45 02 	sts	0x0245, r1
	while (milliseconds < ms);
    1d7a:	80 91 45 02 	lds	r24, 0x0245
    1d7e:	90 91 46 02 	lds	r25, 0x0246
    1d82:	0a 97       	sbiw	r24, 0x0a	; 10
    1d84:	d0 f3       	brcs	.-12     	; 0x1d7a <__vector_5+0x9c>

	if (! (PIND & _BV(BUTTON3))) {
		// button3 is pressed
		if (! (last_buttonstate & 0x4)) { // was not pressed before
			delayms(10);                    // debounce
			if (PIND & _BV(BUTTON3))        // filter out bounces
    1d86:	4c 99       	sbic	0x09, 4	; 9
    1d88:	35 c0       	rjmp	.+106    	; 0x1df4 <__vector_5+0x116>
			{
				PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
				return;
			}
			buttonholdcounter = 2;          // see if we're press-and-holding
    1d8a:	82 e0       	ldi	r24, 0x02	; 2
    1d8c:	80 93 4a 02 	sts	0x024A, r24
    1d90:	1b c0       	rjmp	.+54     	; 0x1dc8 <__vector_5+0xea>
			while (buttonholdcounter) {
				if (PIND & _BV(BUTTON3)) {        // released
    1d92:	4c 9b       	sbis	0x09, 4	; 9
    1d94:	19 c0       	rjmp	.+50     	; 0x1dc8 <__vector_5+0xea>
					tick();                         // make a noise
    1d96:	0e 94 b4 02 	call	0x568	; 0x568 <tick>
					last_buttonstate &= ~0x4;
    1d9a:	80 91 47 02 	lds	r24, 0x0247
    1d9e:	8b 7f       	andi	r24, 0xFB	; 251
    1da0:	80 93 47 02 	sts	0x0247, r24
					// check if we will snag this button press for snoozing
					if (alarming) {
    1da4:	80 91 e2 02 	lds	r24, 0x02E2
    1da8:	88 23       	and	r24, r24
    1daa:	19 f0       	breq	.+6      	; 0x1db2 <__vector_5+0xd4>
						// turn on snooze
						setsnooze();
    1dac:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <setsnooze>
    1db0:	21 c0       	rjmp	.+66     	; 0x1df4 <__vector_5+0x116>
						PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
						return;
					}
					DEBUGP("b3");
    1db2:	8e e8       	ldi	r24, 0x8E	; 142
    1db4:	91 e0       	ldi	r25, 0x01	; 1
    1db6:	61 e0       	ldi	r22, 0x01	; 1
    1db8:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <ROM_putstring>
					just_pressed |= 0x4;
    1dbc:	80 91 48 02 	lds	r24, 0x0248
    1dc0:	84 60       	ori	r24, 0x04	; 4
    1dc2:	80 93 48 02 	sts	0x0248, r24
    1dc6:	16 c0       	rjmp	.+44     	; 0x1df4 <__vector_5+0x116>
			{
				PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
				return;
			}
			buttonholdcounter = 2;          // see if we're press-and-holding
			while (buttonholdcounter) {
    1dc8:	80 91 4a 02 	lds	r24, 0x024A
    1dcc:	88 23       	and	r24, r24
    1dce:	09 f7       	brne	.-62     	; 0x1d92 <__vector_5+0xb4>
					just_pressed |= 0x4;
					PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
					return;
				}
			}
			last_buttonstate |= 0x4;
    1dd0:	80 91 47 02 	lds	r24, 0x0247
    1dd4:	84 60       	ori	r24, 0x04	; 4
    1dd6:	80 93 47 02 	sts	0x0247, r24
			pressed |= 0x4;                 // held down
    1dda:	80 91 49 02 	lds	r24, 0x0249
    1dde:	84 60       	ori	r24, 0x04	; 4
    1de0:	80 93 49 02 	sts	0x0249, r24
    1de4:	07 c0       	rjmp	.+14     	; 0x1df4 <__vector_5+0x116>
		}
	} else {
		pressed = 0;                      // button released
    1de6:	10 92 49 02 	sts	0x0249, r1
		last_buttonstate &= ~0x4;
    1dea:	80 91 47 02 	lds	r24, 0x0247
    1dee:	8b 7f       	andi	r24, 0xFB	; 251
    1df0:	80 93 47 02 	sts	0x0247, r24
	}
	PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
    1df4:	80 e3       	ldi	r24, 0x30	; 48
    1df6:	80 93 6d 00 	sts	0x006D, r24
}
    1dfa:	ff 91       	pop	r31
    1dfc:	ef 91       	pop	r30
    1dfe:	bf 91       	pop	r27
    1e00:	af 91       	pop	r26
    1e02:	9f 91       	pop	r25
    1e04:	8f 91       	pop	r24
    1e06:	7f 91       	pop	r23
    1e08:	6f 91       	pop	r22
    1e0a:	5f 91       	pop	r21
    1e0c:	4f 91       	pop	r20
    1e0e:	3f 91       	pop	r19
    1e10:	2f 91       	pop	r18
    1e12:	0f 90       	pop	r0
    1e14:	0f be       	out	0x3f, r0	; 63
    1e16:	0f 90       	pop	r0
    1e18:	1f 90       	pop	r1
    1e1a:	18 95       	reti

00001e1c <set_timezone>:
		}
	}
}

//Function to set the time zone
void set_timezone(void) {
    1e1c:	cf 92       	push	r12
    1e1e:	df 92       	push	r13
    1e20:	ef 92       	push	r14
    1e22:	ff 92       	push	r15
    1e24:	0f 93       	push	r16
    1e26:	1f 93       	push	r17
    1e28:	cf 93       	push	r28
    1e2a:	df 93       	push	r29
	int8_t hour = intTimeZoneHour;
    1e2c:	10 91 34 02 	lds	r17, 0x0234
	uint8_t min = intTimeZoneMin;
    1e30:	00 91 3c 02 	lds	r16, 0x023C
	uint8_t mode = SHOW_MENU;
	timeoutcounter = INACTIVITYTIMEOUT;
    1e34:	8a e0       	ldi	r24, 0x0A	; 10
    1e36:	80 93 4b 02 	sts	0x024B, r24
    1e3a:	ff 24       	eor	r15, r15
	while (1) {
		if (just_pressed & 0x1) { // mode change
			return;
		}
		if (just_pressed || pressed) {
			timeoutcounter = INACTIVITYTIMEOUT;  
    1e3c:	9a e0       	ldi	r25, 0x0A	; 10
    1e3e:	e9 2e       	mov	r14, r25
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1e40:	8e e0       	ldi	r24, 0x0E	; 14
    1e42:	c8 2e       	mov	r12, r24
    1e44:	d1 2c       	mov	r13, r1
	uint8_t min = intTimeZoneMin;
	uint8_t mode = SHOW_MENU;
	timeoutcounter = INACTIVITYTIMEOUT;

	while (1) {
		if (just_pressed & 0x1) { // mode change
    1e46:	cd e0       	ldi	r28, 0x0D	; 13
    1e48:	d0 e0       	ldi	r29, 0x00	; 0
    1e4a:	80 91 48 02 	lds	r24, 0x0248
    1e4e:	80 fd       	sbrc	r24, 0
    1e50:	b4 c0       	rjmp	.+360    	; 0x1fba <set_timezone+0x19e>
			return;
		}
		if (just_pressed || pressed) {
    1e52:	80 91 48 02 	lds	r24, 0x0248
    1e56:	88 23       	and	r24, r24
    1e58:	21 f4       	brne	.+8      	; 0x1e62 <set_timezone+0x46>
    1e5a:	80 91 49 02 	lds	r24, 0x0249
    1e5e:	88 23       	and	r24, r24
    1e60:	19 f0       	breq	.+6      	; 0x1e68 <set_timezone+0x4c>
			timeoutcounter = INACTIVITYTIMEOUT;  
    1e62:	e0 92 4b 02 	sts	0x024B, r14
    1e66:	04 c0       	rjmp	.+8      	; 0x1e70 <set_timezone+0x54>
			// timeout w/no buttons pressed after 3 seconds?
		} else if (!timeoutcounter) {
    1e68:	80 91 4b 02 	lds	r24, 0x024B
    1e6c:	88 23       	and	r24, r24
    1e6e:	69 f1       	breq	.+90     	; 0x1eca <set_timezone+0xae>
			//timed out!
			displaymode = SHOW_TIME;     
			return;
		}
		if (just_pressed & 0x2) {
    1e70:	80 91 48 02 	lds	r24, 0x0248
    1e74:	81 ff       	sbrs	r24, 1
    1e76:	2c c0       	rjmp	.+88     	; 0x1ed0 <set_timezone+0xb4>
			just_pressed = 0;
    1e78:	10 92 48 02 	sts	0x0248, r1
			if (mode == SHOW_MENU) {
    1e7c:	ff 20       	and	r15, r15
    1e7e:	89 f4       	brne	.+34     	; 0x1ea2 <set_timezone+0x86>
				// ok now its selected
				mode = SET_HOUR;
				display_timezone(hour, min);
    1e80:	81 2f       	mov	r24, r17
    1e82:	60 2f       	mov	r22, r16
    1e84:	0e 94 dc 05 	call	0xbb8	; 0xbb8 <display_timezone>
				display[1] |= 0x1;
    1e88:	80 91 d6 02 	lds	r24, 0x02D6
    1e8c:	81 60       	ori	r24, 0x01	; 1
    1e8e:	80 93 d6 02 	sts	0x02D6, r24
				display[2] |= 0x1;	
    1e92:	80 91 d7 02 	lds	r24, 0x02D7
    1e96:	81 60       	ori	r24, 0x01	; 1
    1e98:	80 93 d7 02 	sts	0x02D7, r24
    1e9c:	ff 24       	eor	r15, r15
    1e9e:	f3 94       	inc	r15
    1ea0:	17 c0       	rjmp	.+46     	; 0x1ed0 <set_timezone+0xb4>
			} else if (mode == SET_HOUR) {
    1ea2:	81 e0       	ldi	r24, 0x01	; 1
    1ea4:	f8 16       	cp	r15, r24
    1ea6:	89 f4       	brne	.+34     	; 0x1eca <set_timezone+0xae>
				mode = SET_MIN;
				display_timezone(hour, min);
    1ea8:	81 2f       	mov	r24, r17
    1eaa:	60 2f       	mov	r22, r16
    1eac:	0e 94 dc 05 	call	0xbb8	; 0xbb8 <display_timezone>
				display[4] |= 0x1;
    1eb0:	80 91 d9 02 	lds	r24, 0x02D9
    1eb4:	81 60       	ori	r24, 0x01	; 1
    1eb6:	80 93 d9 02 	sts	0x02D9, r24
				display[5] |= 0x1;
    1eba:	80 91 da 02 	lds	r24, 0x02DA
    1ebe:	81 60       	ori	r24, 0x01	; 1
    1ec0:	80 93 da 02 	sts	0x02DA, r24
    1ec4:	b2 e0       	ldi	r27, 0x02	; 2
    1ec6:	fb 2e       	mov	r15, r27
    1ec8:	03 c0       	rjmp	.+6      	; 0x1ed0 <set_timezone+0xb4>
			} else {
				// done!
				displaymode = SHOW_TIME;
    1eca:	10 92 e3 02 	sts	0x02E3, r1
    1ece:	75 c0       	rjmp	.+234    	; 0x1fba <set_timezone+0x19e>
				return;
			}
		}
		if ((just_pressed & 0x4) || (pressed & 0x4)) {
    1ed0:	80 91 48 02 	lds	r24, 0x0248
    1ed4:	82 fd       	sbrc	r24, 2
    1ed6:	04 c0       	rjmp	.+8      	; 0x1ee0 <set_timezone+0xc4>
    1ed8:	80 91 49 02 	lds	r24, 0x0249
    1edc:	82 ff       	sbrs	r24, 2
    1ede:	b5 cf       	rjmp	.-150    	; 0x1e4a <set_timezone+0x2e>
			just_pressed = 0;
    1ee0:	10 92 48 02 	sts	0x0248, r1

			if (mode == SET_HOUR) {
    1ee4:	81 e0       	ldi	r24, 0x01	; 1
    1ee6:	f8 16       	cp	r15, r24
    1ee8:	89 f5       	brne	.+98     	; 0x1f4c <set_timezone+0x130>
				hour = ( ( hour + 1 + 12 ) % 25 ) - 12;
    1eea:	81 2f       	mov	r24, r17
    1eec:	99 27       	eor	r25, r25
    1eee:	87 fd       	sbrc	r24, 7
    1ef0:	90 95       	com	r25
    1ef2:	0d 96       	adiw	r24, 0x0d	; 13
    1ef4:	69 e1       	ldi	r22, 0x19	; 25
    1ef6:	70 e0       	ldi	r23, 0x00	; 0
    1ef8:	0e 94 48 1b 	call	0x3690	; 0x3690 <__divmodhi4>
    1efc:	18 2f       	mov	r17, r24
    1efe:	1c 50       	subi	r17, 0x0C	; 12
				display_timezone(hour, min);
    1f00:	81 2f       	mov	r24, r17
    1f02:	60 2f       	mov	r22, r16
    1f04:	0e 94 dc 05 	call	0xbb8	; 0xbb8 <display_timezone>
				display[1] |= 0x1;
    1f08:	80 91 d6 02 	lds	r24, 0x02D6
    1f0c:	81 60       	ori	r24, 0x01	; 1
    1f0e:	80 93 d6 02 	sts	0x02D6, r24
				display[2] |= 0x1;
    1f12:	80 91 d7 02 	lds	r24, 0x02D7
    1f16:	81 60       	ori	r24, 0x01	; 1
    1f18:	80 93 d7 02 	sts	0x02D7, r24
				intTimeZoneHour = hour;
    1f1c:	10 93 34 02 	sts	0x0234, r17
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1f20:	f9 99       	sbic	0x1f, 1	; 31
    1f22:	fe cf       	rjmp	.-4      	; 0x1f20 <set_timezone+0x104>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1f24:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1f26:	d2 bd       	out	0x22, r29	; 34
    1f28:	c1 bd       	out	0x21, r28	; 33
#endif
    EEDR = __value;
    1f2a:	10 bd       	out	0x20, r17	; 32

    __asm__ __volatile__ (
    1f2c:	0f b6       	in	r0, 0x3f	; 63
    1f2e:	f8 94       	cli
    1f30:	fa 9a       	sbi	0x1f, 2	; 31
    1f32:	f9 9a       	sbi	0x1f, 1	; 31
    1f34:	0f be       	out	0x3f, r0	; 63
				eeprom_write_byte((uint8_t *)EE_ZONE_HOUR, hour);
				//Debugging:
				uart_puts("\n\rTimezone offset hour:\t");
    1f36:	84 eb       	ldi	r24, 0xB4	; 180
    1f38:	91 e0       	ldi	r25, 0x01	; 1
    1f3a:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <uart_puts>
				uart_putw_dec(hour);
    1f3e:	81 2f       	mov	r24, r17
    1f40:	99 27       	eor	r25, r25
    1f42:	87 fd       	sbrc	r24, 7
    1f44:	90 95       	com	r25
    1f46:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <uart_putw_dec>
    1f4a:	26 c0       	rjmp	.+76     	; 0x1f98 <set_timezone+0x17c>
			}
			if (mode == SET_MIN) {
    1f4c:	82 e0       	ldi	r24, 0x02	; 2
    1f4e:	f8 16       	cp	r15, r24
    1f50:	19 f5       	brne	.+70     	; 0x1f98 <set_timezone+0x17c>
				min = ( min + 1 ) % 60;
    1f52:	80 2f       	mov	r24, r16
    1f54:	90 e0       	ldi	r25, 0x00	; 0
    1f56:	01 96       	adiw	r24, 0x01	; 1
    1f58:	6c e3       	ldi	r22, 0x3C	; 60
    1f5a:	70 e0       	ldi	r23, 0x00	; 0
    1f5c:	0e 94 48 1b 	call	0x3690	; 0x3690 <__divmodhi4>
    1f60:	08 2f       	mov	r16, r24
				display_timezone(hour, min);
    1f62:	81 2f       	mov	r24, r17
    1f64:	60 2f       	mov	r22, r16
    1f66:	0e 94 dc 05 	call	0xbb8	; 0xbb8 <display_timezone>
				display[4] |= 0x1;
    1f6a:	80 91 d9 02 	lds	r24, 0x02D9
    1f6e:	81 60       	ori	r24, 0x01	; 1
    1f70:	80 93 d9 02 	sts	0x02D9, r24
				display[5] |= 0x1;
    1f74:	80 91 da 02 	lds	r24, 0x02DA
    1f78:	81 60       	ori	r24, 0x01	; 1
    1f7a:	80 93 da 02 	sts	0x02DA, r24
				intTimeZoneMin = min;
    1f7e:	00 93 3c 02 	sts	0x023C, r16
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1f82:	f9 99       	sbic	0x1f, 1	; 31
    1f84:	fe cf       	rjmp	.-4      	; 0x1f82 <set_timezone+0x166>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1f86:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1f88:	d2 bc       	out	0x22, r13	; 34
    1f8a:	c1 bc       	out	0x21, r12	; 33
#endif
    EEDR = __value;
    1f8c:	00 bd       	out	0x20, r16	; 32

    __asm__ __volatile__ (
    1f8e:	0f b6       	in	r0, 0x3f	; 63
    1f90:	f8 94       	cli
    1f92:	fa 9a       	sbi	0x1f, 2	; 31
    1f94:	f9 9a       	sbi	0x1f, 1	; 31
    1f96:	0f be       	out	0x3f, r0	; 63
				eeprom_write_byte((uint8_t *)EE_ZONE_MIN, min);
			}

			if (pressed & 0x4)
    1f98:	80 91 49 02 	lds	r24, 0x0249
    1f9c:	82 ff       	sbrs	r24, 2
    1f9e:	55 cf       	rjmp	.-342    	; 0x1e4a <set_timezone+0x2e>

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    1fa0:	78 94       	sei

	milliseconds = 0;
    1fa2:	10 92 46 02 	sts	0x0246, r1
    1fa6:	10 92 45 02 	sts	0x0245, r1
	while (milliseconds < ms);
    1faa:	80 91 45 02 	lds	r24, 0x0245
    1fae:	90 91 46 02 	lds	r25, 0x0246
    1fb2:	8b 34       	cpi	r24, 0x4B	; 75
    1fb4:	91 05       	cpc	r25, r1
    1fb6:	c8 f3       	brcs	.-14     	; 0x1faa <set_timezone+0x18e>
    1fb8:	48 cf       	rjmp	.-368    	; 0x1e4a <set_timezone+0x2e>

			if (pressed & 0x4)
				delayms(75);
		}
	}
}
    1fba:	df 91       	pop	r29
    1fbc:	cf 91       	pop	r28
    1fbe:	1f 91       	pop	r17
    1fc0:	0f 91       	pop	r16
    1fc2:	ff 90       	pop	r15
    1fc4:	ef 90       	pop	r14
    1fc6:	df 90       	pop	r13
    1fc8:	cf 90       	pop	r12
    1fca:	08 95       	ret

00001fcc <__vector_1>:
		else
			display[0] &= ~0x2;
	}
}

SIGNAL(SIG_INTERRUPT0) {
    1fcc:	1f 92       	push	r1
    1fce:	0f 92       	push	r0
    1fd0:	0f b6       	in	r0, 0x3f	; 63
    1fd2:	0f 92       	push	r0
    1fd4:	11 24       	eor	r1, r1
    1fd6:	2f 93       	push	r18
    1fd8:	3f 93       	push	r19
    1fda:	4f 93       	push	r20
    1fdc:	5f 93       	push	r21
    1fde:	6f 93       	push	r22
    1fe0:	7f 93       	push	r23
    1fe2:	8f 93       	push	r24
    1fe4:	9f 93       	push	r25
    1fe6:	af 93       	push	r26
    1fe8:	bf 93       	push	r27
    1fea:	ef 93       	push	r30
    1fec:	ff 93       	push	r31
	EIMSK = 0;  //Disable this interrupt while we are processing it.
    1fee:	1d ba       	out	0x1d, r1	; 29
	uart_putchar('i');
    1ff0:	89 e6       	ldi	r24, 0x69	; 105
    1ff2:	0e 94 28 17 	call	0x2e50	; 0x2e50 <uart_putchar>
	uint8_t x = ALARM_PIN & _BV(ALARM);
    1ff6:	29 b1       	in	r18, 0x09	; 9
	sei();
    1ff8:	78 94       	sei

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    1ffa:	78 94       	sei

	milliseconds = 0;
    1ffc:	10 92 46 02 	sts	0x0246, r1
    2000:	10 92 45 02 	sts	0x0245, r1
	while (milliseconds < ms);
    2004:	80 91 45 02 	lds	r24, 0x0245
    2008:	90 91 46 02 	lds	r25, 0x0246
    200c:	0a 97       	sbiw	r24, 0x0a	; 10
    200e:	d0 f3       	brcs	.-12     	; 0x2004 <__vector_1+0x38>
	EIMSK = 0;  //Disable this interrupt while we are processing it.
	uart_putchar('i');
	uint8_t x = ALARM_PIN & _BV(ALARM);
	sei();
	delayms(10); // wait for debouncing
	if (x != (ALARM_PIN & _BV(ALARM)))
    2010:	89 b1       	in	r24, 0x09	; 9
    2012:	24 70       	andi	r18, 0x04	; 4
    2014:	30 e0       	ldi	r19, 0x00	; 0
    2016:	90 e0       	ldi	r25, 0x00	; 0
    2018:	84 70       	andi	r24, 0x04	; 4
    201a:	90 70       	andi	r25, 0x00	; 0
    201c:	28 17       	cp	r18, r24
    201e:	39 07       	cpc	r19, r25
    2020:	11 f4       	brne	.+4      	; 0x2026 <__vector_1+0x5a>
	{
		EIMSK = _BV(INT0);
		return;
	}
	setalarmstate();
    2022:	0e 94 b3 0c 	call	0x1966	; 0x1966 <setalarmstate>
	EIMSK = _BV(INT0);  //And reenable it before exiting.
    2026:	81 e0       	ldi	r24, 0x01	; 1
    2028:	8d bb       	out	0x1d, r24	; 29
}
    202a:	ff 91       	pop	r31
    202c:	ef 91       	pop	r30
    202e:	bf 91       	pop	r27
    2030:	af 91       	pop	r26
    2032:	9f 91       	pop	r25
    2034:	8f 91       	pop	r24
    2036:	7f 91       	pop	r23
    2038:	6f 91       	pop	r22
    203a:	5f 91       	pop	r21
    203c:	4f 91       	pop	r20
    203e:	3f 91       	pop	r19
    2040:	2f 91       	pop	r18
    2042:	0f 90       	pop	r0
    2044:	0f be       	out	0x3f, r0	; 63
    2046:	0f 90       	pop	r0
    2048:	1f 90       	pop	r1
    204a:	18 95       	reti

0000204c <twiError>:
** Generate error message that shows expected and received status
*/
char twi_fmt[] PROGMEM = "twi %02x:%02x\r\n";

void twiError (uint8_t expected, uint8_t received)
{
    204c:	0f 93       	push	r16
    204e:	1f 93       	push	r17
    2050:	df 93       	push	r29
    2052:	cf 93       	push	r28
    2054:	cd b7       	in	r28, 0x3d	; 61
    2056:	de b7       	in	r29, 0x3e	; 62
    2058:	2c 97       	sbiw	r28, 0x0c	; 12
    205a:	0f b6       	in	r0, 0x3f	; 63
    205c:	f8 94       	cli
    205e:	de bf       	out	0x3e, r29	; 62
    2060:	0f be       	out	0x3f, r0	; 63
    2062:	cd bf       	out	0x3d, r28	; 61
    2064:	48 2f       	mov	r20, r24
    2066:	26 2f       	mov	r18, r22
#if DEBUG
	char d[12];
	
	sprintf_P (d, twi_fmt, expected, received);
    2068:	8e 01       	movw	r16, r28
    206a:	0f 5f       	subi	r16, 0xFF	; 255
    206c:	1f 4f       	sbci	r17, 0xFF	; 255
    206e:	c8 01       	movw	r24, r16
    2070:	60 e9       	ldi	r22, 0x90	; 144
    2072:	70 e0       	ldi	r23, 0x00	; 0
    2074:	50 e0       	ldi	r21, 0x00	; 0
    2076:	30 e0       	ldi	r19, 0x00	; 0
    2078:	0e 94 5b 18 	call	0x30b6	; 0x30b6 <sprintf_P>
	uart_puts (d);
    207c:	c8 01       	movw	r24, r16
    207e:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <uart_puts>
#endif
}
    2082:	2c 96       	adiw	r28, 0x0c	; 12
    2084:	0f b6       	in	r0, 0x3f	; 63
    2086:	f8 94       	cli
    2088:	de bf       	out	0x3e, r29	; 62
    208a:	0f be       	out	0x3f, r0	; 63
    208c:	cd bf       	out	0x3d, r28	; 61
    208e:	cf 91       	pop	r28
    2090:	df 91       	pop	r29
    2092:	1f 91       	pop	r17
    2094:	0f 91       	pop	r16
    2096:	08 95       	ret

00002098 <twiStart>:
*/
static uint8_t twiStart (void)
{
	uint8_t stat;
	
	TWCR = _BV(TWINT) | _BV(TWEN) | _BV(TWSTA);
    2098:	84 ea       	ldi	r24, 0xA4	; 164
    209a:	80 93 bc 00 	sts	0x00BC, r24
	twiWait();
    209e:	80 91 bc 00 	lds	r24, 0x00BC
    20a2:	87 ff       	sbrs	r24, 7
    20a4:	fc cf       	rjmp	.-8      	; 0x209e <twiStart+0x6>
	stat = TWSR & 0xf8;
    20a6:	60 91 b9 00 	lds	r22, 0x00B9
    20aa:	68 7f       	andi	r22, 0xF8	; 248
	if ((stat == SR_START) || (stat == SR_RSTART))
    20ac:	68 30       	cpi	r22, 0x08	; 8
    20ae:	39 f0       	breq	.+14     	; 0x20be <twiStart+0x26>
    20b0:	60 31       	cpi	r22, 0x10	; 16
    20b2:	29 f0       	breq	.+10     	; 0x20be <twiStart+0x26>
		return 0;
	twiError (SR_START, stat);
    20b4:	88 e0       	ldi	r24, 0x08	; 8
    20b6:	0e 94 26 10 	call	0x204c	; 0x204c <twiError>
    20ba:	81 e0       	ldi	r24, 0x01	; 1
    20bc:	08 95       	ret
	return 1;
    20be:	80 e0       	ldi	r24, 0x00	; 0
}
    20c0:	08 95       	ret

000020c2 <twiReadRegN>:
** Read N sequential bytes of data starting at register <reg>
**
** Note pdata must point to a buffer of sufficient size.
*/
int twiReadRegN(const uint8_t addr, const uint8_t reg, uint8_t n, void *pdata)
{
    20c2:	ff 92       	push	r15
    20c4:	0f 93       	push	r16
    20c6:	1f 93       	push	r17
    20c8:	cf 93       	push	r28
    20ca:	df 93       	push	r29
    20cc:	18 2f       	mov	r17, r24
    20ce:	f6 2e       	mov	r15, r22
    20d0:	04 2f       	mov	r16, r20
    20d2:	e9 01       	movw	r28, r18
	if (twiStart() == 0) {
    20d4:	0e 94 4c 10 	call	0x2098	; 0x2098 <twiStart>
    20d8:	88 23       	and	r24, r24
    20da:	09 f0       	breq	.+2      	; 0x20de <twiReadRegN+0x1c>
    20dc:	6a c0       	rjmp	.+212    	; 0x21b2 <twiReadRegN+0xf0>
		twiWrite((addr & 0xfe) | W);
    20de:	81 2f       	mov	r24, r17
    20e0:	8e 7f       	andi	r24, 0xFE	; 254
/*
** Write one byte of data
*/
static inline void twiWrite(const uint8_t data)
{
	TWDR = data;
    20e2:	80 93 bb 00 	sts	0x00BB, r24
	TWCR = _BV(TWINT) | _BV(TWEN);
    20e6:	84 e8       	ldi	r24, 0x84	; 132
    20e8:	80 93 bc 00 	sts	0x00BC, r24
	twiWait();
    20ec:	80 91 bc 00 	lds	r24, 0x00BC
    20f0:	87 ff       	sbrs	r24, 7
    20f2:	fc cf       	rjmp	.-8      	; 0x20ec <twiReadRegN+0x2a>
*/
int twiReadRegN(const uint8_t addr, const uint8_t reg, uint8_t n, void *pdata)
{
	if (twiStart() == 0) {
		twiWrite((addr & 0xfe) | W);
		if (TWSR != SR_SLA_WA)
    20f4:	80 91 b9 00 	lds	r24, 0x00B9
    20f8:	88 31       	cpi	r24, 0x18	; 24
    20fa:	21 f0       	breq	.+8      	; 0x2104 <twiReadRegN+0x42>
			twiError(SR_SLA_WA, TWSR);
    20fc:	60 91 b9 00 	lds	r22, 0x00B9
    2100:	88 e1       	ldi	r24, 0x18	; 24
    2102:	27 c0       	rjmp	.+78     	; 0x2152 <twiReadRegN+0x90>
/*
** Write one byte of data
*/
static inline void twiWrite(const uint8_t data)
{
	TWDR = data;
    2104:	f0 92 bb 00 	sts	0x00BB, r15
	TWCR = _BV(TWINT) | _BV(TWEN);
    2108:	84 e8       	ldi	r24, 0x84	; 132
    210a:	80 93 bc 00 	sts	0x00BC, r24
	twiWait();
    210e:	80 91 bc 00 	lds	r24, 0x00BC
    2112:	87 ff       	sbrs	r24, 7
    2114:	fc cf       	rjmp	.-8      	; 0x210e <twiReadRegN+0x4c>
		twiWrite((addr & 0xfe) | W);
		if (TWSR != SR_SLA_WA)
			twiError(SR_SLA_WA, TWSR);
		else {
			twiWrite(reg);
			if (TWSR != SR_DTA_A)
    2116:	80 91 b9 00 	lds	r24, 0x00B9
    211a:	88 32       	cpi	r24, 0x28	; 40
    211c:	21 f0       	breq	.+8      	; 0x2126 <twiReadRegN+0x64>
				twiError(SR_DTA_A, TWSR);
    211e:	60 91 b9 00 	lds	r22, 0x00B9
    2122:	88 e2       	ldi	r24, 0x28	; 40
    2124:	16 c0       	rjmp	.+44     	; 0x2152 <twiReadRegN+0x90>
			else if (twiStart() == 0) {
    2126:	0e 94 4c 10 	call	0x2098	; 0x2098 <twiStart>
    212a:	88 23       	and	r24, r24
    212c:	09 f0       	breq	.+2      	; 0x2130 <twiReadRegN+0x6e>
    212e:	41 c0       	rjmp	.+130    	; 0x21b2 <twiReadRegN+0xf0>
				twiWrite((addr & 0xfe) | R);
    2130:	11 60       	ori	r17, 0x01	; 1
/*
** Write one byte of data
*/
static inline void twiWrite(const uint8_t data)
{
	TWDR = data;
    2132:	10 93 bb 00 	sts	0x00BB, r17
	TWCR = _BV(TWINT) | _BV(TWEN);
    2136:	84 e8       	ldi	r24, 0x84	; 132
    2138:	80 93 bc 00 	sts	0x00BC, r24
	twiWait();
    213c:	80 91 bc 00 	lds	r24, 0x00BC
    2140:	87 ff       	sbrs	r24, 7
    2142:	fc cf       	rjmp	.-8      	; 0x213c <twiReadRegN+0x7a>
			twiWrite(reg);
			if (TWSR != SR_DTA_A)
				twiError(SR_DTA_A, TWSR);
			else if (twiStart() == 0) {
				twiWrite((addr & 0xfe) | R);
				if (TWSR != SR_SLA_RA)
    2144:	80 91 b9 00 	lds	r24, 0x00B9
    2148:	80 34       	cpi	r24, 0x40	; 64
    214a:	49 f1       	breq	.+82     	; 0x219e <twiReadRegN+0xdc>
					twiError(SR_SLA_RA, TWSR);
    214c:	60 91 b9 00 	lds	r22, 0x00B9
    2150:	80 e4       	ldi	r24, 0x40	; 64
    2152:	0e 94 26 10 	call	0x204c	; 0x204c <twiError>
    2156:	2d c0       	rjmp	.+90     	; 0x21b2 <twiReadRegN+0xf0>
				else {
					while (n > 0) {
						if (n == 1) {
    2158:	01 30       	cpi	r16, 0x01	; 1
    215a:	71 f4       	brne	.+28     	; 0x2178 <twiReadRegN+0xb6>
/*
** Read one byte without ACK
*/
static inline void twiReadNack(void)
{
	TWCR = _BV(TWINT) | _BV(TWEN);
    215c:	90 93 bc 00 	sts	0x00BC, r25
	twiWait();
    2160:	80 91 bc 00 	lds	r24, 0x00BC
    2164:	87 ff       	sbrs	r24, 7
    2166:	fc cf       	rjmp	.-8      	; 0x2160 <twiReadRegN+0x9e>
					twiError(SR_SLA_RA, TWSR);
				else {
					while (n > 0) {
						if (n == 1) {
							twiReadNack();	/* Last byte */
							if (TWSR != SR_DTR) {
    2168:	80 91 b9 00 	lds	r24, 0x00B9
    216c:	88 35       	cpi	r24, 0x58	; 88
    216e:	91 f0       	breq	.+36     	; 0x2194 <twiReadRegN+0xd2>
								twiError(SR_DTR, TWSR);
    2170:	60 91 b9 00 	lds	r22, 0x00B9
    2174:	88 e5       	ldi	r24, 0x58	; 88
    2176:	ed cf       	rjmp	.-38     	; 0x2152 <twiReadRegN+0x90>
/*
** Read one byte of data
*/
static inline void twiRead(void)
{
	TWCR = _BV(TWINT) | _BV(TWEN) | _BV(TWEA);
    2178:	20 93 bc 00 	sts	0x00BC, r18
	twiWait();
    217c:	80 91 bc 00 	lds	r24, 0x00BC
    2180:	87 ff       	sbrs	r24, 7
    2182:	fc cf       	rjmp	.-8      	; 0x217c <twiReadRegN+0xba>
								TWCR = 0;		/* Disable TWI */
								return -1;
							}
						} else {
							twiRead();
							if (TWSR != SR_DTR_A) {
    2184:	80 91 b9 00 	lds	r24, 0x00B9
    2188:	80 35       	cpi	r24, 0x50	; 80
    218a:	21 f0       	breq	.+8      	; 0x2194 <twiReadRegN+0xd2>
								twiError(SR_DTR_A, TWSR);
    218c:	60 91 b9 00 	lds	r22, 0x00B9
    2190:	80 e5       	ldi	r24, 0x50	; 80
    2192:	df cf       	rjmp	.-66     	; 0x2152 <twiReadRegN+0x90>
								TWCR = 0;		/* Disable TWI */
								return -1;
							}
						}
						*(uint8_t *)pdata++ = TWDR;
    2194:	80 91 bb 00 	lds	r24, 0x00BB
    2198:	89 93       	st	Y+, r24
						n--;
    219a:	01 50       	subi	r16, 0x01	; 1
    219c:	02 c0       	rjmp	.+4      	; 0x21a2 <twiReadRegN+0xe0>
/*
** Read one byte of data
*/
static inline void twiRead(void)
{
	TWCR = _BV(TWINT) | _BV(TWEN) | _BV(TWEA);
    219e:	24 ec       	ldi	r18, 0xC4	; 196
/*
** Read one byte without ACK
*/
static inline void twiReadNack(void)
{
	TWCR = _BV(TWINT) | _BV(TWEN);
    21a0:	94 e8       	ldi	r25, 0x84	; 132
			else if (twiStart() == 0) {
				twiWrite((addr & 0xfe) | R);
				if (TWSR != SR_SLA_RA)
					twiError(SR_SLA_RA, TWSR);
				else {
					while (n > 0) {
    21a2:	00 23       	and	r16, r16
    21a4:	c9 f6       	brne	.-78     	; 0x2158 <twiReadRegN+0x96>
/*
** Issue STOP condition on TWI bus
*/
static inline void twiStop (void)
{
	TWCR = _BV(TWINT) | _BV(TWEN) | _BV(TWSTO);
    21a6:	84 e9       	ldi	r24, 0x94	; 148
    21a8:	80 93 bc 00 	sts	0x00BC, r24
    21ac:	20 e0       	ldi	r18, 0x00	; 0
    21ae:	30 e0       	ldi	r19, 0x00	; 0
    21b0:	04 c0       	rjmp	.+8      	; 0x21ba <twiReadRegN+0xf8>
					return 0;
				}
			}
		}
	}
	TWCR = 0;		/* Disable TWI */
    21b2:	10 92 bc 00 	sts	0x00BC, r1
    21b6:	2f ef       	ldi	r18, 0xFF	; 255
    21b8:	3f ef       	ldi	r19, 0xFF	; 255
	return -1;
}
    21ba:	c9 01       	movw	r24, r18
    21bc:	df 91       	pop	r29
    21be:	cf 91       	pop	r28
    21c0:	1f 91       	pop	r17
    21c2:	0f 91       	pop	r16
    21c4:	ff 90       	pop	r15
    21c6:	08 95       	ret

000021c8 <twiReadReg>:

/*
** Read register <reg> from device at address <addr>
*/
int twiReadReg(const uint8_t addr, const uint8_t reg)
{
    21c8:	0f 93       	push	r16
    21ca:	1f 93       	push	r17
    21cc:	18 2f       	mov	r17, r24
    21ce:	06 2f       	mov	r16, r22
	uint8_t dr;
	
	if (twiStart() == 0) {
    21d0:	0e 94 4c 10 	call	0x2098	; 0x2098 <twiStart>
    21d4:	88 23       	and	r24, r24
    21d6:	09 f0       	breq	.+2      	; 0x21da <twiReadReg+0x12>
    21d8:	53 c0       	rjmp	.+166    	; 0x2280 <twiReadReg+0xb8>
		twiWrite((addr & 0xfe) | W);
    21da:	81 2f       	mov	r24, r17
    21dc:	8e 7f       	andi	r24, 0xFE	; 254
/*
** Write one byte of data
*/
static inline void twiWrite(const uint8_t data)
{
	TWDR = data;
    21de:	80 93 bb 00 	sts	0x00BB, r24
	TWCR = _BV(TWINT) | _BV(TWEN);
    21e2:	84 e8       	ldi	r24, 0x84	; 132
    21e4:	80 93 bc 00 	sts	0x00BC, r24
	twiWait();
    21e8:	80 91 bc 00 	lds	r24, 0x00BC
    21ec:	87 ff       	sbrs	r24, 7
    21ee:	fc cf       	rjmp	.-8      	; 0x21e8 <twiReadReg+0x20>
{
	uint8_t dr;
	
	if (twiStart() == 0) {
		twiWrite((addr & 0xfe) | W);
		if (TWSR != SR_SLA_WA)
    21f0:	80 91 b9 00 	lds	r24, 0x00B9
    21f4:	88 31       	cpi	r24, 0x18	; 24
    21f6:	21 f0       	breq	.+8      	; 0x2200 <twiReadReg+0x38>
			twiError(SR_SLA_WA, TWSR);
    21f8:	60 91 b9 00 	lds	r22, 0x00B9
    21fc:	88 e1       	ldi	r24, 0x18	; 24
    21fe:	35 c0       	rjmp	.+106    	; 0x226a <twiReadReg+0xa2>
/*
** Write one byte of data
*/
static inline void twiWrite(const uint8_t data)
{
	TWDR = data;
    2200:	00 93 bb 00 	sts	0x00BB, r16
	TWCR = _BV(TWINT) | _BV(TWEN);
    2204:	84 e8       	ldi	r24, 0x84	; 132
    2206:	80 93 bc 00 	sts	0x00BC, r24
	twiWait();
    220a:	80 91 bc 00 	lds	r24, 0x00BC
    220e:	87 ff       	sbrs	r24, 7
    2210:	fc cf       	rjmp	.-8      	; 0x220a <twiReadReg+0x42>
		twiWrite((addr & 0xfe) | W);
		if (TWSR != SR_SLA_WA)
			twiError(SR_SLA_WA, TWSR);
		else {
			twiWrite(reg);
			if (TWSR != SR_DTA_A)
    2212:	80 91 b9 00 	lds	r24, 0x00B9
    2216:	88 32       	cpi	r24, 0x28	; 40
    2218:	21 f0       	breq	.+8      	; 0x2222 <twiReadReg+0x5a>
				twiError(SR_DTA_A, TWSR);
    221a:	60 91 b9 00 	lds	r22, 0x00B9
    221e:	88 e2       	ldi	r24, 0x28	; 40
    2220:	24 c0       	rjmp	.+72     	; 0x226a <twiReadReg+0xa2>
			else if (twiStart() == 0) {
    2222:	0e 94 4c 10 	call	0x2098	; 0x2098 <twiStart>
    2226:	88 23       	and	r24, r24
    2228:	59 f5       	brne	.+86     	; 0x2280 <twiReadReg+0xb8>
				twiWrite((addr & 0xfe) | R);
    222a:	11 60       	ori	r17, 0x01	; 1
/*
** Write one byte of data
*/
static inline void twiWrite(const uint8_t data)
{
	TWDR = data;
    222c:	10 93 bb 00 	sts	0x00BB, r17
	TWCR = _BV(TWINT) | _BV(TWEN);
    2230:	84 e8       	ldi	r24, 0x84	; 132
    2232:	80 93 bc 00 	sts	0x00BC, r24
	twiWait();
    2236:	80 91 bc 00 	lds	r24, 0x00BC
    223a:	87 ff       	sbrs	r24, 7
    223c:	fc cf       	rjmp	.-8      	; 0x2236 <twiReadReg+0x6e>
			twiWrite(reg);
			if (TWSR != SR_DTA_A)
				twiError(SR_DTA_A, TWSR);
			else if (twiStart() == 0) {
				twiWrite((addr & 0xfe) | R);
				if (TWSR != SR_SLA_RA)
    223e:	80 91 b9 00 	lds	r24, 0x00B9
    2242:	80 34       	cpi	r24, 0x40	; 64
    2244:	21 f0       	breq	.+8      	; 0x224e <twiReadReg+0x86>
					twiError(SR_SLA_RA, TWSR);
    2246:	60 91 b9 00 	lds	r22, 0x00B9
    224a:	80 e4       	ldi	r24, 0x40	; 64
    224c:	0e c0       	rjmp	.+28     	; 0x226a <twiReadReg+0xa2>
/*
** Read one byte without ACK
*/
static inline void twiReadNack(void)
{
	TWCR = _BV(TWINT) | _BV(TWEN);
    224e:	84 e8       	ldi	r24, 0x84	; 132
    2250:	80 93 bc 00 	sts	0x00BC, r24
	twiWait();
    2254:	80 91 bc 00 	lds	r24, 0x00BC
    2258:	87 ff       	sbrs	r24, 7
    225a:	fc cf       	rjmp	.-8      	; 0x2254 <twiReadReg+0x8c>
				twiWrite((addr & 0xfe) | R);
				if (TWSR != SR_SLA_RA)
					twiError(SR_SLA_RA, TWSR);
				else {
					twiReadNack();
					if (TWSR != SR_DTR)
    225c:	80 91 b9 00 	lds	r24, 0x00B9
    2260:	88 35       	cpi	r24, 0x58	; 88
    2262:	31 f0       	breq	.+12     	; 0x2270 <twiReadReg+0xa8>
						twiError(SR_DTR, TWSR);
    2264:	60 91 b9 00 	lds	r22, 0x00B9
    2268:	88 e5       	ldi	r24, 0x58	; 88
    226a:	0e 94 26 10 	call	0x204c	; 0x204c <twiError>
    226e:	08 c0       	rjmp	.+16     	; 0x2280 <twiReadReg+0xb8>
					else {
						dr = TWDR;
    2270:	90 91 bb 00 	lds	r25, 0x00BB
/*
** Issue STOP condition on TWI bus
*/
static inline void twiStop (void)
{
	TWCR = _BV(TWINT) | _BV(TWEN) | _BV(TWSTO);
    2274:	84 e9       	ldi	r24, 0x94	; 148
    2276:	80 93 bc 00 	sts	0x00BC, r24
					if (TWSR != SR_DTR)
						twiError(SR_DTR, TWSR);
					else {
						dr = TWDR;
						twiStop();
						return (dr);
    227a:	29 2f       	mov	r18, r25
    227c:	30 e0       	ldi	r19, 0x00	; 0
    227e:	04 c0       	rjmp	.+8      	; 0x2288 <twiReadReg+0xc0>
					}
				}
			}
		}
	}
	TWCR = 0;		/* Disable TWI */
    2280:	10 92 bc 00 	sts	0x00BC, r1
    2284:	2f ef       	ldi	r18, 0xFF	; 255
    2286:	3f ef       	ldi	r19, 0xFF	; 255
	return -1;
}
    2288:	c9 01       	movw	r24, r18
    228a:	1f 91       	pop	r17
    228c:	0f 91       	pop	r16
    228e:	08 95       	ret

00002290 <clock_init>:
	}
}

/**************************** RTC & ALARM *****************************/

void clock_init(void) {
    2290:	0f 93       	push	r16
    2292:	1f 93       	push	r17
    2294:	df 93       	push	r29
    2296:	cf 93       	push	r28
    2298:	cd b7       	in	r28, 0x3d	; 61
    229a:	de b7       	in	r29, 0x3e	; 62
    229c:	27 97       	sbiw	r28, 0x07	; 7
    229e:	0f b6       	in	r0, 0x3f	; 63
    22a0:	f8 94       	cli
    22a2:	de bf       	out	0x3e, r29	; 62
    22a4:	0f be       	out	0x3f, r0	; 63
    22a6:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    22a8:	f9 99       	sbic	0x1f, 1	; 31
    22aa:	fe cf       	rjmp	.-4      	; 0x22a8 <clock_init+0x18>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    22ac:	8f e0       	ldi	r24, 0x0F	; 15
    22ae:	90 e0       	ldi	r25, 0x00	; 0
    22b0:	92 bd       	out	0x22, r25	; 34
    22b2:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    22b4:	f8 9a       	sbi	0x1f, 0	; 31
    22b6:	80 b5       	in	r24, 0x20	; 32
	uint8_t dt[7];
	uint8_t i;
	
	// Initialize Daylight Saving Time enable
	if (eeprom_read_byte ((uint8_t *)EE_DST))
    22b8:	88 23       	and	r24, r24
    22ba:	21 f0       	breq	.+8      	; 0x22c4 <clock_init+0x34>
		set_flag(f_dst_enable);
    22bc:	80 91 e6 02 	lds	r24, 0x02E6
    22c0:	84 60       	ori	r24, 0x04	; 4
    22c2:	03 c0       	rjmp	.+6      	; 0x22ca <clock_init+0x3a>
	else
		clr_flag(f_dst_enable);
    22c4:	80 91 e6 02 	lds	r24, 0x02E6
    22c8:	8b 7f       	andi	r24, 0xFB	; 251
    22ca:	80 93 e6 02 	sts	0x02E6, r24
	
	// Read check values from ChronoDot alarm fields
	twiReadRegN(0xd0, 0x07, 7, dt);
    22ce:	80 ed       	ldi	r24, 0xD0	; 208
    22d0:	67 e0       	ldi	r22, 0x07	; 7
    22d2:	47 e0       	ldi	r20, 0x07	; 7
    22d4:	8e 01       	movw	r16, r28
    22d6:	0f 5f       	subi	r16, 0xFF	; 255
    22d8:	1f 4f       	sbci	r17, 0xFF	; 255
    22da:	98 01       	movw	r18, r16
    22dc:	0e 94 61 10 	call	0x20c2	; 0x20c2 <twiReadRegN>
    22e0:	f8 01       	movw	r30, r16
    22e2:	21 e0       	ldi	r18, 0x01	; 1
    22e4:	30 e0       	ldi	r19, 0x00	; 0
	for (i = 0; i < 7; i++)
		if (dt[i] != i+1) break;
    22e6:	80 81       	ld	r24, Z
    22e8:	90 e0       	ldi	r25, 0x00	; 0
    22ea:	82 17       	cp	r24, r18
    22ec:	93 07       	cpc	r25, r19
    22ee:	49 f4       	brne	.+18     	; 0x2302 <clock_init+0x72>
    22f0:	82 2f       	mov	r24, r18
    22f2:	31 96       	adiw	r30, 0x01	; 1
    22f4:	2f 5f       	subi	r18, 0xFF	; 255
    22f6:	3f 4f       	sbci	r19, 0xFF	; 255
	else
		clr_flag(f_dst_enable);
	
	// Read check values from ChronoDot alarm fields
	twiReadRegN(0xd0, 0x07, 7, dt);
	for (i = 0; i < 7; i++)
    22f8:	28 30       	cpi	r18, 0x08	; 8
    22fa:	31 05       	cpc	r19, r1
    22fc:	a1 f7       	brne	.-24     	; 0x22e6 <clock_init+0x56>
		if (dt[i] != i+1) break;
	if (i != 7) {
    22fe:	87 30       	cpi	r24, 0x07	; 7
    2300:	49 f0       	breq	.+18     	; 0x2314 <clock_init+0x84>
		DEBUGP("ChronoDot check failed!");
    2302:	83 ee       	ldi	r24, 0xE3	; 227
    2304:	90 e0       	ldi	r25, 0x00	; 0
    2306:	61 e0       	ldi	r22, 0x01	; 1
    2308:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <ROM_putstring>
		set_flag (f_timeunknown);	// let customer know time needs setting
    230c:	80 91 e6 02 	lds	r24, 0x02E6
    2310:	82 60       	ori	r24, 0x02	; 2
    2312:	80 c0       	rjmp	.+256    	; 0x2414 <clock_init+0x184>
	} else {
		// Sync to start of ChronoDot second
		cli();
    2314:	f8 94       	cli
		
		time_s = twiReadReg(0xd0, 0x00);
    2316:	80 ed       	ldi	r24, 0xD0	; 208
    2318:	60 e0       	ldi	r22, 0x00	; 0
    231a:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <twiReadReg>
    231e:	80 93 e5 02 	sts	0x02E5, r24
		do twiReadRegN(0xd0, 0x00, 7, dt); while (dt[0] == time_s);
    2322:	8e 01       	movw	r16, r28
    2324:	0f 5f       	subi	r16, 0xFF	; 255
    2326:	1f 4f       	sbci	r17, 0xFF	; 255
    2328:	80 ed       	ldi	r24, 0xD0	; 208
    232a:	60 e0       	ldi	r22, 0x00	; 0
    232c:	47 e0       	ldi	r20, 0x07	; 7
    232e:	98 01       	movw	r18, r16
    2330:	0e 94 61 10 	call	0x20c2	; 0x20c2 <twiReadRegN>
    2334:	49 81       	ldd	r20, Y+1	; 0x01
    2336:	80 91 e5 02 	lds	r24, 0x02E5
    233a:	24 2f       	mov	r18, r20
    233c:	30 e0       	ldi	r19, 0x00	; 0
    233e:	99 27       	eor	r25, r25
    2340:	87 fd       	sbrc	r24, 7
    2342:	90 95       	com	r25
    2344:	28 17       	cp	r18, r24
    2346:	39 07       	cpc	r19, r25
    2348:	79 f3       	breq	.-34     	; 0x2328 <clock_init+0x98>

		// Zero T/C2 to sync AVR to start of seconds
		GTCCR |= _BV(PSRASY) | _BV(TSM);
    234a:	83 b5       	in	r24, 0x23	; 35
    234c:	82 68       	ori	r24, 0x82	; 130
    234e:	83 bd       	out	0x23, r24	; 35
		TCNT2 = 0;		
    2350:	10 92 b2 00 	sts	0x00B2, r1
		GTCCR &= ~_BV(TSM);
    2354:	83 b5       	in	r24, 0x23	; 35
    2356:	8f 77       	andi	r24, 0x7F	; 127
    2358:	83 bd       	out	0x23, r24	; 35
		
		time_s = bcd2b (dt[0]);		// BCD to binary decode
    235a:	84 2f       	mov	r24, r20
    235c:	82 95       	swap	r24
    235e:	8f 70       	andi	r24, 0x0F	; 15
    2360:	3a e0       	ldi	r19, 0x0A	; 10
    2362:	83 9f       	mul	r24, r19
    2364:	c0 01       	movw	r24, r0
    2366:	11 24       	eor	r1, r1
    2368:	4f 70       	andi	r20, 0x0F	; 15
    236a:	48 0f       	add	r20, r24
    236c:	40 93 e5 02 	sts	0x02E5, r20
		time_m = bcd2b (dt[1]);
    2370:	2a 81       	ldd	r18, Y+2	; 0x02
    2372:	82 2f       	mov	r24, r18
    2374:	82 95       	swap	r24
    2376:	8f 70       	andi	r24, 0x0F	; 15
    2378:	83 9f       	mul	r24, r19
    237a:	c0 01       	movw	r24, r0
    237c:	11 24       	eor	r1, r1
    237e:	2f 70       	andi	r18, 0x0F	; 15
    2380:	28 0f       	add	r18, r24
    2382:	20 93 de 02 	sts	0x02DE, r18
		time_h = bcd2b (dt[2] & 0x3f);
    2386:	2b 81       	ldd	r18, Y+3	; 0x03
    2388:	82 2f       	mov	r24, r18
    238a:	8f 73       	andi	r24, 0x3F	; 63
    238c:	82 95       	swap	r24
    238e:	8f 70       	andi	r24, 0x0F	; 15
    2390:	83 9f       	mul	r24, r19
    2392:	c0 01       	movw	r24, r0
    2394:	11 24       	eor	r1, r1
    2396:	2f 70       	andi	r18, 0x0F	; 15
    2398:	28 0f       	add	r18, r24
    239a:	20 93 50 02 	sts	0x0250, r18

		date_d = bcd2b (dt[4]);
    239e:	2d 81       	ldd	r18, Y+5	; 0x05
    23a0:	82 2f       	mov	r24, r18
    23a2:	82 95       	swap	r24
    23a4:	8f 70       	andi	r24, 0x0F	; 15
    23a6:	83 9f       	mul	r24, r19
    23a8:	c0 01       	movw	r24, r0
    23aa:	11 24       	eor	r1, r1
    23ac:	2f 70       	andi	r18, 0x0F	; 15
    23ae:	28 0f       	add	r18, r24
    23b0:	20 93 d4 02 	sts	0x02D4, r18
		date_m = bcd2b (dt[5] & 0x1f);
    23b4:	2e 81       	ldd	r18, Y+6	; 0x06
    23b6:	82 2f       	mov	r24, r18
    23b8:	8f 71       	andi	r24, 0x1F	; 31
    23ba:	82 95       	swap	r24
    23bc:	8f 70       	andi	r24, 0x0F	; 15
    23be:	83 9f       	mul	r24, r19
    23c0:	c0 01       	movw	r24, r0
    23c2:	11 24       	eor	r1, r1
    23c4:	2f 70       	andi	r18, 0x0F	; 15
    23c6:	28 0f       	add	r18, r24
    23c8:	20 93 e4 02 	sts	0x02E4, r18
		date_y = bcd2b (dt[6]);
    23cc:	2f 81       	ldd	r18, Y+7	; 0x07
    23ce:	82 2f       	mov	r24, r18
    23d0:	82 95       	swap	r24
    23d2:	8f 70       	andi	r24, 0x0F	; 15
    23d4:	83 9f       	mul	r24, r19
    23d6:	c0 01       	movw	r24, r0
    23d8:	11 24       	eor	r1, r1
    23da:	2f 70       	andi	r18, 0x0F	; 15
    23dc:	28 0f       	add	r18, r24
    23de:	20 93 d1 02 	sts	0x02D1, r18
		
		sei();
    23e2:	78 94       	sei

		clr_flag (f_timeunknown);
    23e4:	80 91 e6 02 	lds	r24, 0x02E6
    23e8:	8d 7f       	andi	r24, 0xFD	; 253
    23ea:	80 93 e6 02 	sts	0x02E6, r24
		
		// Initialize DST now since it is only done at top of hour
		set_dst_offset (date_y, date_m, date_d, time_h);
    23ee:	80 91 d1 02 	lds	r24, 0x02D1
    23f2:	60 91 e4 02 	lds	r22, 0x02E4
    23f6:	40 91 d4 02 	lds	r20, 0x02D4
    23fa:	20 91 50 02 	lds	r18, 0x0250
#define flag(n) (flags & _BV(n))
#define set_flag(n) flags |= _BV(n)
#define clr_flag(n) flags &= ~_BV(n)

inline void set_dst_offset (uint8_t y, uint8_t m, uint8_t d, uint8_t h) {
	if (dst (y, m, d, h))
    23fe:	0e 94 2f 02 	call	0x45e	; 0x45e <dst>
    2402:	88 23       	and	r24, r24
    2404:	21 f0       	breq	.+8      	; 0x240e <clock_init+0x17e>
		set_flag (f_dst_offset);
    2406:	80 91 e6 02 	lds	r24, 0x02E6
    240a:	81 60       	ori	r24, 0x01	; 1
    240c:	03 c0       	rjmp	.+6      	; 0x2414 <clock_init+0x184>
	else
		clr_flag (f_dst_offset);
    240e:	80 91 e6 02 	lds	r24, 0x02E6
    2412:	8e 7f       	andi	r24, 0xFE	; 254
    2414:	80 93 e6 02 	sts	0x02E6, r24
		
		// Initialize DST now since it is only done at top of hour
		set_dst_offset (date_y, date_m, date_d, time_h);

	}
}
    2418:	27 96       	adiw	r28, 0x07	; 7
    241a:	0f b6       	in	r0, 0x3f	; 63
    241c:	f8 94       	cli
    241e:	de bf       	out	0x3e, r29	; 62
    2420:	0f be       	out	0x3f, r0	; 63
    2422:	cd bf       	out	0x3d, r28	; 61
    2424:	cf 91       	pop	r28
    2426:	df 91       	pop	r29
    2428:	1f 91       	pop	r17
    242a:	0f 91       	pop	r16
    242c:	08 95       	ret

0000242e <twiWriteRegN>:

/*
** Write N sequential bytes of data starting at register <reg>
*/
int twiWriteRegN(const uint8_t addr, const uint8_t reg, uint8_t n, void *pdata)
{
    242e:	ff 92       	push	r15
    2430:	0f 93       	push	r16
    2432:	1f 93       	push	r17
    2434:	cf 93       	push	r28
    2436:	df 93       	push	r29
    2438:	18 2f       	mov	r17, r24
    243a:	f6 2e       	mov	r15, r22
    243c:	04 2f       	mov	r16, r20
    243e:	e9 01       	movw	r28, r18
	if (twiStart() == 0) {
    2440:	0e 94 4c 10 	call	0x2098	; 0x2098 <twiStart>
    2444:	88 23       	and	r24, r24
    2446:	f1 f5       	brne	.+124    	; 0x24c4 <twiWriteRegN+0x96>
		twiWrite((addr & 0xfe) | W);
    2448:	1e 7f       	andi	r17, 0xFE	; 254
/*
** Write one byte of data
*/
static inline void twiWrite(const uint8_t data)
{
	TWDR = data;
    244a:	10 93 bb 00 	sts	0x00BB, r17
	TWCR = _BV(TWINT) | _BV(TWEN);
    244e:	84 e8       	ldi	r24, 0x84	; 132
    2450:	80 93 bc 00 	sts	0x00BC, r24
	twiWait();
    2454:	80 91 bc 00 	lds	r24, 0x00BC
    2458:	87 ff       	sbrs	r24, 7
    245a:	fc cf       	rjmp	.-8      	; 0x2454 <twiWriteRegN+0x26>
*/
int twiWriteRegN(const uint8_t addr, const uint8_t reg, uint8_t n, void *pdata)
{
	if (twiStart() == 0) {
		twiWrite((addr & 0xfe) | W);
		if (TWSR != SR_SLA_WA)
    245c:	80 91 b9 00 	lds	r24, 0x00B9
    2460:	88 31       	cpi	r24, 0x18	; 24
    2462:	21 f0       	breq	.+8      	; 0x246c <twiWriteRegN+0x3e>
			twiError(SR_SLA_WA, TWSR);
    2464:	60 91 b9 00 	lds	r22, 0x00B9
    2468:	88 e1       	ldi	r24, 0x18	; 24
    246a:	10 c0       	rjmp	.+32     	; 0x248c <twiWriteRegN+0x5e>
/*
** Write one byte of data
*/
static inline void twiWrite(const uint8_t data)
{
	TWDR = data;
    246c:	f0 92 bb 00 	sts	0x00BB, r15
	TWCR = _BV(TWINT) | _BV(TWEN);
    2470:	84 e8       	ldi	r24, 0x84	; 132
    2472:	80 93 bc 00 	sts	0x00BC, r24
	twiWait();
    2476:	80 91 bc 00 	lds	r24, 0x00BC
    247a:	87 ff       	sbrs	r24, 7
    247c:	fc cf       	rjmp	.-8      	; 0x2476 <twiWriteRegN+0x48>
		twiWrite((addr & 0xfe) | W);
		if (TWSR != SR_SLA_WA)
			twiError(SR_SLA_WA, TWSR);
		else {
			twiWrite(reg);
			if (TWSR != SR_DTA_A)
    247e:	80 91 b9 00 	lds	r24, 0x00B9
    2482:	88 32       	cpi	r24, 0x28	; 40
    2484:	b1 f0       	breq	.+44     	; 0x24b2 <twiWriteRegN+0x84>
				twiError(SR_DTA_A, TWSR);
    2486:	60 91 b9 00 	lds	r22, 0x00B9
    248a:	88 e2       	ldi	r24, 0x28	; 40
    248c:	0e 94 26 10 	call	0x204c	; 0x204c <twiError>
    2490:	19 c0       	rjmp	.+50     	; 0x24c4 <twiWriteRegN+0x96>
			else {
				while (n > 0) {
					twiWrite(*(uint8_t *)pdata++);
    2492:	88 81       	ld	r24, Y
/*
** Write one byte of data
*/
static inline void twiWrite(const uint8_t data)
{
	TWDR = data;
    2494:	80 93 bb 00 	sts	0x00BB, r24
	TWCR = _BV(TWINT) | _BV(TWEN);
    2498:	90 93 bc 00 	sts	0x00BC, r25
	twiWait();
    249c:	80 91 bc 00 	lds	r24, 0x00BC
    24a0:	87 ff       	sbrs	r24, 7
    24a2:	fc cf       	rjmp	.-8      	; 0x249c <twiWriteRegN+0x6e>
			if (TWSR != SR_DTA_A)
				twiError(SR_DTA_A, TWSR);
			else {
				while (n > 0) {
					twiWrite(*(uint8_t *)pdata++);
					if (TWSR != SR_DTA_A) {
    24a4:	80 91 b9 00 	lds	r24, 0x00B9
    24a8:	88 32       	cpi	r24, 0x28	; 40
    24aa:	69 f7       	brne	.-38     	; 0x2486 <twiWriteRegN+0x58>
			twiWrite(reg);
			if (TWSR != SR_DTA_A)
				twiError(SR_DTA_A, TWSR);
			else {
				while (n > 0) {
					twiWrite(*(uint8_t *)pdata++);
    24ac:	21 96       	adiw	r28, 0x01	; 1
					if (TWSR != SR_DTA_A) {
						twiError(SR_DTA_A, TWSR);
						TWCR = 0;
						return -1;
					}
					n--;
    24ae:	01 50       	subi	r16, 0x01	; 1
    24b0:	01 c0       	rjmp	.+2      	; 0x24b4 <twiWriteRegN+0x86>
** Write one byte of data
*/
static inline void twiWrite(const uint8_t data)
{
	TWDR = data;
	TWCR = _BV(TWINT) | _BV(TWEN);
    24b2:	94 e8       	ldi	r25, 0x84	; 132
		else {
			twiWrite(reg);
			if (TWSR != SR_DTA_A)
				twiError(SR_DTA_A, TWSR);
			else {
				while (n > 0) {
    24b4:	00 23       	and	r16, r16
    24b6:	69 f7       	brne	.-38     	; 0x2492 <twiWriteRegN+0x64>
/*
** Issue STOP condition on TWI bus
*/
static inline void twiStop (void)
{
	TWCR = _BV(TWINT) | _BV(TWEN) | _BV(TWSTO);
    24b8:	84 e9       	ldi	r24, 0x94	; 148
    24ba:	80 93 bc 00 	sts	0x00BC, r24
    24be:	20 e0       	ldi	r18, 0x00	; 0
    24c0:	30 e0       	ldi	r19, 0x00	; 0
    24c2:	04 c0       	rjmp	.+8      	; 0x24cc <twiWriteRegN+0x9e>
				twiStop();
				return 0;				
			}
		}
	}
	TWCR = 0;		/* Disable TWI */
    24c4:	10 92 bc 00 	sts	0x00BC, r1
    24c8:	2f ef       	ldi	r18, 0xFF	; 255
    24ca:	3f ef       	ldi	r19, 0xFF	; 255
	return -1;
}
    24cc:	c9 01       	movw	r24, r18
    24ce:	df 91       	pop	r29
    24d0:	cf 91       	pop	r28
    24d2:	1f 91       	pop	r17
    24d4:	0f 91       	pop	r16
    24d6:	ff 90       	pop	r15
    24d8:	08 95       	ret

000024da <set_date>:
	}
}



void set_date(void) {
    24da:	9f 92       	push	r9
    24dc:	af 92       	push	r10
    24de:	bf 92       	push	r11
    24e0:	cf 92       	push	r12
    24e2:	df 92       	push	r13
    24e4:	ef 92       	push	r14
    24e6:	ff 92       	push	r15
    24e8:	0f 93       	push	r16
    24ea:	1f 93       	push	r17
    24ec:	df 93       	push	r29
    24ee:	cf 93       	push	r28
    24f0:	00 d0       	rcall	.+0      	; 0x24f2 <set_date+0x18>
    24f2:	00 d0       	rcall	.+0      	; 0x24f4 <set_date+0x1a>
    24f4:	cd b7       	in	r28, 0x3d	; 61
    24f6:	de b7       	in	r29, 0x3e	; 62
	uint8_t mode = SHOW_MENU;
	uint8_t m, d, y;
	uint8_t dt[4];

	timeoutcounter = INACTIVITYTIMEOUT;;  
    24f8:	8a e0       	ldi	r24, 0x0A	; 10
    24fa:	80 93 4b 02 	sts	0x024B, r24
    24fe:	10 e0       	ldi	r17, 0x00	; 0

	while (1) {
		if (just_pressed || pressed) {
			timeoutcounter = INACTIVITYTIMEOUT;;  
    2500:	0a e0       	ldi	r16, 0x0A	; 10
				display_date(DATE);
				display[1] |= 0x1;
				display[2] |= 0x1;
			} else if (((mode == SET_MONTH) && (region == REGION_US)) ||
					((mode == SET_DAY) && (region == REGION_EU))) {
				if (region == REGION_US)
    2502:	99 24       	eor	r9, r9
    2504:	93 94       	inc	r9
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    2506:	41 e0       	ldi	r20, 0x01	; 1
    2508:	c4 2e       	mov	r12, r20
    250a:	d1 2c       	mov	r13, r1
	uint8_t dt[4];

	timeoutcounter = INACTIVITYTIMEOUT;;  

	while (1) {
		if (just_pressed || pressed) {
    250c:	33 e0       	ldi	r19, 0x03	; 3
    250e:	a3 2e       	mov	r10, r19
    2510:	b1 2c       	mov	r11, r1
    2512:	22 e0       	ldi	r18, 0x02	; 2
    2514:	e2 2e       	mov	r14, r18
    2516:	f1 2c       	mov	r15, r1
    2518:	80 91 48 02 	lds	r24, 0x0248
    251c:	88 23       	and	r24, r24
    251e:	21 f4       	brne	.+8      	; 0x2528 <set_date+0x4e>
    2520:	80 91 49 02 	lds	r24, 0x0249
    2524:	88 23       	and	r24, r24
    2526:	19 f0       	breq	.+6      	; 0x252e <set_date+0x54>
			timeoutcounter = INACTIVITYTIMEOUT;;  
    2528:	00 93 4b 02 	sts	0x024B, r16
    252c:	05 c0       	rjmp	.+10     	; 0x2538 <set_date+0x5e>
			// timeout w/no buttons pressed after 3 seconds?
		} else if (!timeoutcounter) {
    252e:	80 91 4b 02 	lds	r24, 0x024B
    2532:	88 23       	and	r24, r24
    2534:	09 f4       	brne	.+2      	; 0x2538 <set_date+0x5e>
    2536:	96 c0       	rjmp	.+300    	; 0x2664 <set_date+0x18a>
			//timed out!
			displaymode = SHOW_TIME;     
			return;
		}
		if (just_pressed & 0x1) { // mode change
    2538:	80 91 48 02 	lds	r24, 0x0248
    253c:	80 fd       	sbrc	r24, 0
    253e:	39 c1       	rjmp	.+626    	; 0x27b2 <set_date+0x2d8>
			return;
		}
		if (just_pressed & 0x2) {
    2540:	80 91 48 02 	lds	r24, 0x0248
    2544:	81 ff       	sbrs	r24, 1
    2546:	91 c0       	rjmp	.+290    	; 0x266a <set_date+0x190>

			just_pressed = 0;
    2548:	10 92 48 02 	sts	0x0248, r1
			if (mode == SHOW_MENU) {
    254c:	11 23       	and	r17, r17
    254e:	d1 f4       	brne	.+52     	; 0x2584 <set_date+0xaa>
				// start!
				if (region == REGION_US) {
    2550:	80 91 38 02 	lds	r24, 0x0238
    2554:	88 23       	and	r24, r24
    2556:	11 f4       	brne	.+4      	; 0x255c <set_date+0x82>
    2558:	11 e0       	ldi	r17, 0x01	; 1
    255a:	06 c0       	rjmp	.+12     	; 0x2568 <set_date+0x8e>
					mode = SET_MONTH;
				}
				else {
					DEBUGP("Set day");
    255c:	8b ef       	ldi	r24, 0xFB	; 251
    255e:	90 e0       	ldi	r25, 0x00	; 0
    2560:	61 e0       	ldi	r22, 0x01	; 1
    2562:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <ROM_putstring>
    2566:	12 e0       	ldi	r17, 0x02	; 2
					mode = SET_DAY;
				}
				display_date(DATE);
    2568:	80 e0       	ldi	r24, 0x00	; 0
    256a:	0e 94 54 06 	call	0xca8	; 0xca8 <display_date>
				display[1] |= 0x1;
    256e:	80 91 d6 02 	lds	r24, 0x02D6
    2572:	81 60       	ori	r24, 0x01	; 1
    2574:	80 93 d6 02 	sts	0x02D6, r24
				display[2] |= 0x1;
    2578:	80 91 d7 02 	lds	r24, 0x02D7
    257c:	81 60       	ori	r24, 0x01	; 1
    257e:	80 93 d7 02 	sts	0x02D7, r24
    2582:	73 c0       	rjmp	.+230    	; 0x266a <set_date+0x190>
			} else if (((mode == SET_MONTH) && (region == REGION_US)) ||
    2584:	11 30       	cpi	r17, 0x01	; 1
    2586:	29 f4       	brne	.+10     	; 0x2592 <set_date+0xb8>
    2588:	80 91 38 02 	lds	r24, 0x0238
    258c:	88 23       	and	r24, r24
    258e:	39 f0       	breq	.+14     	; 0x259e <set_date+0xc4>
    2590:	20 c0       	rjmp	.+64     	; 0x25d2 <set_date+0xf8>
    2592:	12 30       	cpi	r17, 0x02	; 2
    2594:	e1 f4       	brne	.+56     	; 0x25ce <set_date+0xf4>
    2596:	80 91 38 02 	lds	r24, 0x0238
    259a:	81 30       	cpi	r24, 0x01	; 1
    259c:	a9 f4       	brne	.+42     	; 0x25c8 <set_date+0xee>
					((mode == SET_DAY) && (region == REGION_EU))) {
				if (region == REGION_US)
    259e:	80 91 38 02 	lds	r24, 0x0238
    25a2:	88 23       	and	r24, r24
    25a4:	11 f0       	breq	.+4      	; 0x25aa <set_date+0xd0>
    25a6:	11 e0       	ldi	r17, 0x01	; 1
    25a8:	01 c0       	rjmp	.+2      	; 0x25ac <set_date+0xd2>
    25aa:	12 e0       	ldi	r17, 0x02	; 2
					mode = SET_DAY;
				else
					mode = SET_MONTH;
				display_date(DATE);
    25ac:	80 e0       	ldi	r24, 0x00	; 0
    25ae:	0e 94 54 06 	call	0xca8	; 0xca8 <display_date>
				display[4] |= 0x1;
    25b2:	80 91 d9 02 	lds	r24, 0x02D9
    25b6:	81 60       	ori	r24, 0x01	; 1
    25b8:	80 93 d9 02 	sts	0x02D9, r24
				display[5] |= 0x1;
    25bc:	80 91 da 02 	lds	r24, 0x02DA
    25c0:	81 60       	ori	r24, 0x01	; 1
    25c2:	80 93 da 02 	sts	0x02DA, r24
    25c6:	51 c0       	rjmp	.+162    	; 0x266a <set_date+0x190>
			} else if (((mode == SET_DAY) && (region == REGION_US)) ||
    25c8:	88 23       	and	r24, r24
    25ca:	39 f0       	breq	.+14     	; 0x25da <set_date+0x100>
    25cc:	15 c0       	rjmp	.+42     	; 0x25f8 <set_date+0x11e>
    25ce:	11 30       	cpi	r17, 0x01	; 1
    25d0:	99 f4       	brne	.+38     	; 0x25f8 <set_date+0x11e>
    25d2:	80 91 38 02 	lds	r24, 0x0238
    25d6:	81 30       	cpi	r24, 0x01	; 1
    25d8:	79 f4       	brne	.+30     	; 0x25f8 <set_date+0x11e>
					((mode == SET_MONTH) && (region == REGION_EU))) {
				mode = SET_YEAR;
				display_date(DATE);
    25da:	80 e0       	ldi	r24, 0x00	; 0
    25dc:	0e 94 54 06 	call	0xca8	; 0xca8 <display_date>
				display[7] |= 0x1;
    25e0:	80 91 dc 02 	lds	r24, 0x02DC
    25e4:	81 60       	ori	r24, 0x01	; 1
    25e6:	80 93 dc 02 	sts	0x02DC, r24
				display[8] |= 0x1;
    25ea:	80 91 dd 02 	lds	r24, 0x02DD
    25ee:	81 60       	ori	r24, 0x01	; 1
    25f0:	80 93 dd 02 	sts	0x02DD, r24
    25f4:	13 e0       	ldi	r17, 0x03	; 3
    25f6:	39 c0       	rjmp	.+114    	; 0x266a <set_date+0x190>
			} else {
				displaymode = NONE;
    25f8:	83 e6       	ldi	r24, 0x63	; 99
    25fa:	80 93 e3 02 	sts	0x02E3, r24
				display_date(DATE);
    25fe:	80 e0       	ldi	r24, 0x00	; 0
    2600:	0e 94 54 06 	call	0xca8	; 0xca8 <display_date>

				d=date_d;
    2604:	10 91 d4 02 	lds	r17, 0x02D4
				m=date_m;
    2608:	00 91 e4 02 	lds	r16, 0x02E4
				y=date_y;
    260c:	f0 90 d1 02 	lds	r15, 0x02D1
				
				sei();
    2610:	78 94       	sei
				
				dt[0] = dow (y, m, d);
    2612:	8f 2d       	mov	r24, r15
    2614:	60 2f       	mov	r22, r16
    2616:	41 2f       	mov	r20, r17
    2618:	0e 94 ca 01 	call	0x394	; 0x394 <dow>
    261c:	89 83       	std	Y+1, r24	; 0x01
				dt[1] = b2bcd(d);
    261e:	81 2f       	mov	r24, r17
    2620:	0e 94 43 01 	call	0x286	; 0x286 <b2bcd>
    2624:	8a 83       	std	Y+2, r24	; 0x02
				dt[2] = b2bcd(m);
    2626:	80 2f       	mov	r24, r16
    2628:	0e 94 43 01 	call	0x286	; 0x286 <b2bcd>
    262c:	8b 83       	std	Y+3, r24	; 0x03
				dt[3] = b2bcd(y);
    262e:	8f 2d       	mov	r24, r15
    2630:	0e 94 43 01 	call	0x286	; 0x286 <b2bcd>
    2634:	8c 83       	std	Y+4, r24	; 0x04
				twiWriteRegN(0xd0, 0x3, 4, dt);		// Update ChronoDot
    2636:	80 ed       	ldi	r24, 0xD0	; 208
    2638:	63 e0       	ldi	r22, 0x03	; 3
    263a:	44 e0       	ldi	r20, 0x04	; 4
    263c:	9e 01       	movw	r18, r28
    263e:	2f 5f       	subi	r18, 0xFF	; 255
    2640:	3f 4f       	sbci	r19, 0xFF	; 255
    2642:	0e 94 17 12 	call	0x242e	; 0x242e <twiWriteRegN>
				
				//set_dst_offset (date_y, date_m, date_d, time_h);
				display_date (DATE);
    2646:	80 e0       	ldi	r24, 0x00	; 0
    2648:	0e 94 54 06 	call	0xca8	; 0xca8 <display_date>

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    264c:	78 94       	sei

	milliseconds = 0;
    264e:	10 92 46 02 	sts	0x0246, r1
    2652:	10 92 45 02 	sts	0x0245, r1
	while (milliseconds < ms);
    2656:	80 91 45 02 	lds	r24, 0x0245
    265a:	90 91 46 02 	lds	r25, 0x0246
    265e:	8c 5d       	subi	r24, 0xDC	; 220
    2660:	95 40       	sbci	r25, 0x05	; 5
    2662:	c8 f3       	brcs	.-14     	; 0x2656 <set_date+0x17c>
				twiWriteRegN(0xd0, 0x3, 4, dt);		// Update ChronoDot
				
				//set_dst_offset (date_y, date_m, date_d, time_h);
				display_date (DATE);
				delayms(1500);
				displaymode = SHOW_TIME;
    2664:	10 92 e3 02 	sts	0x02E3, r1
    2668:	a4 c0       	rjmp	.+328    	; 0x27b2 <set_date+0x2d8>
				return;
			}
		}
		if ((just_pressed & 0x4) || (pressed & 0x4)) {
    266a:	80 91 48 02 	lds	r24, 0x0248
    266e:	82 fd       	sbrc	r24, 2
    2670:	04 c0       	rjmp	.+8      	; 0x267a <set_date+0x1a0>
    2672:	80 91 49 02 	lds	r24, 0x0249
    2676:	82 ff       	sbrs	r24, 2
    2678:	4f cf       	rjmp	.-354    	; 0x2518 <set_date+0x3e>
			just_pressed = 0;
    267a:	10 92 48 02 	sts	0x0248, r1
			if (mode == SET_MONTH) {
    267e:	11 30       	cpi	r17, 0x01	; 1
    2680:	79 f5       	brne	.+94     	; 0x26e0 <set_date+0x206>
				date_m++;
    2682:	80 91 e4 02 	lds	r24, 0x02E4
    2686:	8f 5f       	subi	r24, 0xFF	; 255
    2688:	80 93 e4 02 	sts	0x02E4, r24
				if (date_m >= 13)
    268c:	80 91 e4 02 	lds	r24, 0x02E4
    2690:	8d 30       	cpi	r24, 0x0D	; 13
    2692:	14 f0       	brlt	.+4      	; 0x2698 <set_date+0x1be>
					date_m = 1;
    2694:	10 93 e4 02 	sts	0x02E4, r17
				display_date(DATE);
    2698:	80 e0       	ldi	r24, 0x00	; 0
    269a:	0e 94 54 06 	call	0xca8	; 0xca8 <display_date>
				if (region == REGION_US) {
    269e:	80 91 38 02 	lds	r24, 0x0238
    26a2:	88 23       	and	r24, r24
    26a4:	59 f4       	brne	.+22     	; 0x26bc <set_date+0x1e2>
					display[1] |= 0x1;
    26a6:	80 91 d6 02 	lds	r24, 0x02D6
    26aa:	81 60       	ori	r24, 0x01	; 1
    26ac:	80 93 d6 02 	sts	0x02D6, r24
					display[2] |= 0x1;
    26b0:	80 91 d7 02 	lds	r24, 0x02D7
    26b4:	81 60       	ori	r24, 0x01	; 1
    26b6:	80 93 d7 02 	sts	0x02D7, r24
    26ba:	0a c0       	rjmp	.+20     	; 0x26d0 <set_date+0x1f6>
				} else {
					display[4] |= 0x1;
    26bc:	80 91 d9 02 	lds	r24, 0x02D9
    26c0:	81 60       	ori	r24, 0x01	; 1
    26c2:	80 93 d9 02 	sts	0x02D9, r24
					display[5] |= 0x1;
    26c6:	80 91 da 02 	lds	r24, 0x02DA
    26ca:	81 60       	ori	r24, 0x01	; 1
    26cc:	80 93 da 02 	sts	0x02DA, r24
				}
				eeprom_write_byte((uint8_t *)EE_MONTH, date_m);    
    26d0:	80 91 e4 02 	lds	r24, 0x02E4
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    26d4:	f9 99       	sbic	0x1f, 1	; 31
    26d6:	fe cf       	rjmp	.-4      	; 0x26d4 <set_date+0x1fa>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    26d8:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    26da:	f2 bc       	out	0x22, r15	; 34
    26dc:	e1 bc       	out	0x21, r14	; 33
    26de:	53 c0       	rjmp	.+166    	; 0x2786 <set_date+0x2ac>
			}
			if (mode == SET_DAY) {
    26e0:	12 30       	cpi	r17, 0x02	; 2
    26e2:	79 f5       	brne	.+94     	; 0x2742 <set_date+0x268>
				date_d++;
    26e4:	80 91 d4 02 	lds	r24, 0x02D4
    26e8:	8f 5f       	subi	r24, 0xFF	; 255
    26ea:	80 93 d4 02 	sts	0x02D4, r24
				if (date_d > 31)
    26ee:	80 91 d4 02 	lds	r24, 0x02D4
    26f2:	80 32       	cpi	r24, 0x20	; 32
    26f4:	14 f0       	brlt	.+4      	; 0x26fa <set_date+0x220>
					date_d = 1;
    26f6:	90 92 d4 02 	sts	0x02D4, r9
				display_date(DATE);
    26fa:	80 e0       	ldi	r24, 0x00	; 0
    26fc:	0e 94 54 06 	call	0xca8	; 0xca8 <display_date>

				if (region == REGION_EU) {
    2700:	80 91 38 02 	lds	r24, 0x0238
    2704:	81 30       	cpi	r24, 0x01	; 1
    2706:	59 f4       	brne	.+22     	; 0x271e <set_date+0x244>
					display[1] |= 0x1;
    2708:	80 91 d6 02 	lds	r24, 0x02D6
    270c:	81 60       	ori	r24, 0x01	; 1
    270e:	80 93 d6 02 	sts	0x02D6, r24
					display[2] |= 0x1;
    2712:	80 91 d7 02 	lds	r24, 0x02D7
    2716:	81 60       	ori	r24, 0x01	; 1
    2718:	80 93 d7 02 	sts	0x02D7, r24
    271c:	0a c0       	rjmp	.+20     	; 0x2732 <set_date+0x258>
				} else {
					display[4] |= 0x1;
    271e:	80 91 d9 02 	lds	r24, 0x02D9
    2722:	81 60       	ori	r24, 0x01	; 1
    2724:	80 93 d9 02 	sts	0x02D9, r24
					display[5] |= 0x1;
    2728:	80 91 da 02 	lds	r24, 0x02DA
    272c:	81 60       	ori	r24, 0x01	; 1
    272e:	80 93 da 02 	sts	0x02DA, r24
				}
				eeprom_write_byte((uint8_t *)EE_DAY, date_d);    
    2732:	80 91 d4 02 	lds	r24, 0x02D4
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2736:	f9 99       	sbic	0x1f, 1	; 31
    2738:	fe cf       	rjmp	.-4      	; 0x2736 <set_date+0x25c>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    273a:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    273c:	b2 bc       	out	0x22, r11	; 34
    273e:	a1 bc       	out	0x21, r10	; 33
    2740:	22 c0       	rjmp	.+68     	; 0x2786 <set_date+0x2ac>
			}
			if (mode == SET_YEAR) {
    2742:	13 30       	cpi	r17, 0x03	; 3
    2744:	31 f5       	brne	.+76     	; 0x2792 <set_date+0x2b8>
				date_y++;
    2746:	80 91 d1 02 	lds	r24, 0x02D1
    274a:	8f 5f       	subi	r24, 0xFF	; 255
    274c:	80 93 d1 02 	sts	0x02D1, r24
				date_y %= 100;
    2750:	80 91 d1 02 	lds	r24, 0x02D1
    2754:	64 e6       	ldi	r22, 0x64	; 100
    2756:	0e 94 27 1b 	call	0x364e	; 0x364e <__divmodqi4>
    275a:	90 93 d1 02 	sts	0x02D1, r25
				display_date(DATE);
    275e:	80 e0       	ldi	r24, 0x00	; 0
    2760:	0e 94 54 06 	call	0xca8	; 0xca8 <display_date>
				display[7] |= 0x1;
    2764:	80 91 dc 02 	lds	r24, 0x02DC
    2768:	81 60       	ori	r24, 0x01	; 1
    276a:	80 93 dc 02 	sts	0x02DC, r24
				display[8] |= 0x1;
    276e:	80 91 dd 02 	lds	r24, 0x02DD
    2772:	81 60       	ori	r24, 0x01	; 1
    2774:	80 93 dd 02 	sts	0x02DD, r24
				eeprom_write_byte((uint8_t *)EE_YEAR, date_y);    
    2778:	80 91 d1 02 	lds	r24, 0x02D1
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    277c:	f9 99       	sbic	0x1f, 1	; 31
    277e:	fe cf       	rjmp	.-4      	; 0x277c <set_date+0x2a2>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    2780:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    2782:	d2 bc       	out	0x22, r13	; 34
    2784:	c1 bc       	out	0x21, r12	; 33
#endif
    EEDR = __value;
    2786:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
    2788:	0f b6       	in	r0, 0x3f	; 63
    278a:	f8 94       	cli
    278c:	fa 9a       	sbi	0x1f, 2	; 31
    278e:	f9 9a       	sbi	0x1f, 1	; 31
    2790:	0f be       	out	0x3f, r0	; 63
			}

			if (pressed & 0x4)
    2792:	80 91 49 02 	lds	r24, 0x0249
    2796:	82 ff       	sbrs	r24, 2
    2798:	bf ce       	rjmp	.-642    	; 0x2518 <set_date+0x3e>

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    279a:	78 94       	sei

	milliseconds = 0;
    279c:	10 92 46 02 	sts	0x0246, r1
    27a0:	10 92 45 02 	sts	0x0245, r1
	while (milliseconds < ms);
    27a4:	80 91 45 02 	lds	r24, 0x0245
    27a8:	90 91 46 02 	lds	r25, 0x0246
    27ac:	cc 97       	sbiw	r24, 0x3c	; 60
    27ae:	d0 f3       	brcs	.-12     	; 0x27a4 <set_date+0x2ca>
    27b0:	b3 ce       	rjmp	.-666    	; 0x2518 <set_date+0x3e>

			if (pressed & 0x4)
				delayms(60);
		}
	}
}
    27b2:	0f 90       	pop	r0
    27b4:	0f 90       	pop	r0
    27b6:	0f 90       	pop	r0
    27b8:	0f 90       	pop	r0
    27ba:	cf 91       	pop	r28
    27bc:	df 91       	pop	r29
    27be:	1f 91       	pop	r17
    27c0:	0f 91       	pop	r16
    27c2:	ff 90       	pop	r15
    27c4:	ef 90       	pop	r14
    27c6:	df 90       	pop	r13
    27c8:	cf 90       	pop	r12
    27ca:	bf 90       	pop	r11
    27cc:	af 90       	pop	r10
    27ce:	9f 90       	pop	r9
    27d0:	08 95       	ret

000027d2 <twiWriteReg>:

/*
** Write <data> into register <reg> of device at address <addr>
*/
int twiWriteReg(const uint8_t addr, const uint8_t reg, const uint8_t data)
{
    27d2:	ff 92       	push	r15
    27d4:	0f 93       	push	r16
    27d6:	1f 93       	push	r17
    27d8:	18 2f       	mov	r17, r24
    27da:	06 2f       	mov	r16, r22
    27dc:	f4 2e       	mov	r15, r20
	if (twiStart() == 0) {
    27de:	0e 94 4c 10 	call	0x2098	; 0x2098 <twiStart>
    27e2:	88 23       	and	r24, r24
    27e4:	c1 f5       	brne	.+112    	; 0x2856 <twiWriteReg+0x84>
		twiWrite((addr & 0xfe) | W);
    27e6:	1e 7f       	andi	r17, 0xFE	; 254
/*
** Write one byte of data
*/
static inline void twiWrite(const uint8_t data)
{
	TWDR = data;
    27e8:	10 93 bb 00 	sts	0x00BB, r17
	TWCR = _BV(TWINT) | _BV(TWEN);
    27ec:	84 e8       	ldi	r24, 0x84	; 132
    27ee:	80 93 bc 00 	sts	0x00BC, r24
	twiWait();
    27f2:	80 91 bc 00 	lds	r24, 0x00BC
    27f6:	87 ff       	sbrs	r24, 7
    27f8:	fc cf       	rjmp	.-8      	; 0x27f2 <twiWriteReg+0x20>
*/
int twiWriteReg(const uint8_t addr, const uint8_t reg, const uint8_t data)
{
	if (twiStart() == 0) {
		twiWrite((addr & 0xfe) | W);
		if (TWSR != SR_SLA_WA)
    27fa:	80 91 b9 00 	lds	r24, 0x00B9
    27fe:	88 31       	cpi	r24, 0x18	; 24
    2800:	21 f0       	breq	.+8      	; 0x280a <twiWriteReg+0x38>
			twiError(SR_SLA_WA, TWSR);
    2802:	60 91 b9 00 	lds	r22, 0x00B9
    2806:	88 e1       	ldi	r24, 0x18	; 24
    2808:	1d c0       	rjmp	.+58     	; 0x2844 <twiWriteReg+0x72>
/*
** Write one byte of data
*/
static inline void twiWrite(const uint8_t data)
{
	TWDR = data;
    280a:	00 93 bb 00 	sts	0x00BB, r16
	TWCR = _BV(TWINT) | _BV(TWEN);
    280e:	84 e8       	ldi	r24, 0x84	; 132
    2810:	80 93 bc 00 	sts	0x00BC, r24
	twiWait();
    2814:	80 91 bc 00 	lds	r24, 0x00BC
    2818:	87 ff       	sbrs	r24, 7
    281a:	fc cf       	rjmp	.-8      	; 0x2814 <twiWriteReg+0x42>
		twiWrite((addr & 0xfe) | W);
		if (TWSR != SR_SLA_WA)
			twiError(SR_SLA_WA, TWSR);
		else {
			twiWrite(reg);
			if (TWSR != SR_DTA_A)
    281c:	80 91 b9 00 	lds	r24, 0x00B9
    2820:	88 32       	cpi	r24, 0x28	; 40
    2822:	69 f4       	brne	.+26     	; 0x283e <twiWriteReg+0x6c>
/*
** Write one byte of data
*/
static inline void twiWrite(const uint8_t data)
{
	TWDR = data;
    2824:	f0 92 bb 00 	sts	0x00BB, r15
	TWCR = _BV(TWINT) | _BV(TWEN);
    2828:	84 e8       	ldi	r24, 0x84	; 132
    282a:	80 93 bc 00 	sts	0x00BC, r24
	twiWait();
    282e:	80 91 bc 00 	lds	r24, 0x00BC
    2832:	87 ff       	sbrs	r24, 7
    2834:	fc cf       	rjmp	.-8      	; 0x282e <twiWriteReg+0x5c>
			twiWrite(reg);
			if (TWSR != SR_DTA_A)
				twiError(SR_DTA_A, TWSR);
			else {
				twiWrite(data);
				if (TWSR != SR_DTA_A)
    2836:	80 91 b9 00 	lds	r24, 0x00B9
    283a:	88 32       	cpi	r24, 0x28	; 40
    283c:	31 f0       	breq	.+12     	; 0x284a <twiWriteReg+0x78>
					twiError(SR_DTA_A, TWSR);
    283e:	60 91 b9 00 	lds	r22, 0x00B9
    2842:	88 e2       	ldi	r24, 0x28	; 40
    2844:	0e 94 26 10 	call	0x204c	; 0x204c <twiError>
    2848:	06 c0       	rjmp	.+12     	; 0x2856 <twiWriteReg+0x84>
/*
** Issue STOP condition on TWI bus
*/
static inline void twiStop (void)
{
	TWCR = _BV(TWINT) | _BV(TWEN) | _BV(TWSTO);
    284a:	84 e9       	ldi	r24, 0x94	; 148
    284c:	80 93 bc 00 	sts	0x00BC, r24
    2850:	20 e0       	ldi	r18, 0x00	; 0
    2852:	30 e0       	ldi	r19, 0x00	; 0
    2854:	04 c0       	rjmp	.+8      	; 0x285e <twiWriteReg+0x8c>
					return 0;
				}
			}
		}
	}
	TWCR = 0;		/* Disable TWI */
    2856:	10 92 bc 00 	sts	0x00BC, r1
    285a:	2f ef       	ldi	r18, 0xFF	; 255
    285c:	3f ef       	ldi	r19, 0xFF	; 255
	return -1;
}
    285e:	c9 01       	movw	r24, r18
    2860:	1f 91       	pop	r17
    2862:	0f 91       	pop	r16
    2864:	ff 90       	pop	r15
    2866:	08 95       	ret

00002868 <set_time>:
	return (bcd & 0x0f) + (bcd >> 4) * 10;
}


void set_time(void) 
{
    2868:	9f 92       	push	r9
    286a:	af 92       	push	r10
    286c:	bf 92       	push	r11
    286e:	cf 92       	push	r12
    2870:	df 92       	push	r13
    2872:	ef 92       	push	r14
    2874:	ff 92       	push	r15
    2876:	0f 93       	push	r16
    2878:	1f 93       	push	r17
    287a:	df 93       	push	r29
    287c:	cf 93       	push	r28
    287e:	00 d0       	rcall	.+0      	; 0x2880 <set_time+0x18>
    2880:	0f 92       	push	r0
    2882:	cd b7       	in	r28, 0x3d	; 61
    2884:	de b7       	in	r29, 0x3e	; 62
	uint8_t mode;
	uint8_t hour, min, sec;

	hour = time_h;
    2886:	f0 90 50 02 	lds	r15, 0x0250
	min = time_m;
    288a:	00 91 de 02 	lds	r16, 0x02DE
	sec = time_s;
    288e:	e0 90 e5 02 	lds	r14, 0x02E5
	mode = SHOW_MENU;

	timeoutcounter = INACTIVITYTIMEOUT;
    2892:	8a e0       	ldi	r24, 0x0A	; 10
    2894:	80 93 4b 02 	sts	0x024B, r24
    2898:	10 e0       	ldi	r17, 0x00	; 0
	while (1) {
		if (just_pressed & 0x1) { // mode change
			return;
		}
		if (just_pressed || pressed) {
			timeoutcounter = INACTIVITYTIMEOUT;  
    289a:	7a e0       	ldi	r23, 0x0A	; 10
    289c:	97 2e       	mov	r9, r23
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    289e:	65 e0       	ldi	r22, 0x05	; 5
    28a0:	a6 2e       	mov	r10, r22
    28a2:	b1 2c       	mov	r11, r1
	mode = SHOW_MENU;

	timeoutcounter = INACTIVITYTIMEOUT;

	while (1) {
		if (just_pressed & 0x1) { // mode change
    28a4:	54 e0       	ldi	r21, 0x04	; 4
    28a6:	c5 2e       	mov	r12, r21
    28a8:	d1 2c       	mov	r13, r1
    28aa:	80 91 48 02 	lds	r24, 0x0248
    28ae:	80 fd       	sbrc	r24, 0
    28b0:	07 c1       	rjmp	.+526    	; 0x2ac0 <set_time+0x258>
			return;
		}
		if (just_pressed || pressed) {
    28b2:	80 91 48 02 	lds	r24, 0x0248
    28b6:	88 23       	and	r24, r24
    28b8:	21 f4       	brne	.+8      	; 0x28c2 <set_time+0x5a>
    28ba:	80 91 49 02 	lds	r24, 0x0249
    28be:	88 23       	and	r24, r24
    28c0:	19 f0       	breq	.+6      	; 0x28c8 <set_time+0x60>
			timeoutcounter = INACTIVITYTIMEOUT;  
    28c2:	90 92 4b 02 	sts	0x024B, r9
    28c6:	05 c0       	rjmp	.+10     	; 0x28d2 <set_time+0x6a>
			// timeout w/no buttons pressed after 3 seconds?
		} else if (!timeoutcounter) {
    28c8:	80 91 4b 02 	lds	r24, 0x024B
    28cc:	88 23       	and	r24, r24
    28ce:	09 f4       	brne	.+2      	; 0x28d2 <set_time+0x6a>
    28d0:	6d c0       	rjmp	.+218    	; 0x29ac <set_time+0x144>
			//timed out!
			displaymode = SHOW_TIME;     
			return;
		}
		if (just_pressed & 0x2) {
    28d2:	80 91 48 02 	lds	r24, 0x0248
    28d6:	81 ff       	sbrs	r24, 1
    28d8:	6c c0       	rjmp	.+216    	; 0x29b2 <set_time+0x14a>
			just_pressed = 0;
    28da:	10 92 48 02 	sts	0x0248, r1
			if (mode == SHOW_MENU) {
    28de:	11 23       	and	r17, r17
    28e0:	b9 f4       	brne	.+46     	; 0x2910 <set_time+0xa8>
				hour = time_h;
    28e2:	f0 90 50 02 	lds	r15, 0x0250
				min = time_m;
    28e6:	00 91 de 02 	lds	r16, 0x02DE
				sec = time_s;
    28ea:	e0 90 e5 02 	lds	r14, 0x02E5

				// ok now its selected
				mode = SET_HOUR;
				display_time(hour, min, sec);
    28ee:	8f 2d       	mov	r24, r15
    28f0:	60 2f       	mov	r22, r16
    28f2:	4e 2d       	mov	r20, r14
    28f4:	0e 94 ca 03 	call	0x794	; 0x794 <display_time>
				display[1] |= 0x1;
    28f8:	80 91 d6 02 	lds	r24, 0x02D6
    28fc:	81 60       	ori	r24, 0x01	; 1
    28fe:	80 93 d6 02 	sts	0x02D6, r24
				display[2] |= 0x1;	
    2902:	80 91 d7 02 	lds	r24, 0x02D7
    2906:	81 60       	ori	r24, 0x01	; 1
    2908:	80 93 d7 02 	sts	0x02D7, r24
    290c:	11 e0       	ldi	r17, 0x01	; 1
    290e:	51 c0       	rjmp	.+162    	; 0x29b2 <set_time+0x14a>
			} else if (mode == SET_HOUR) {
    2910:	11 30       	cpi	r17, 0x01	; 1
    2912:	89 f4       	brne	.+34     	; 0x2936 <set_time+0xce>
				mode = SET_MIN;
				display_time(hour, min, sec);
    2914:	8f 2d       	mov	r24, r15
    2916:	60 2f       	mov	r22, r16
    2918:	4e 2d       	mov	r20, r14
    291a:	0e 94 ca 03 	call	0x794	; 0x794 <display_time>
				display[4] |= 0x1;
    291e:	80 91 d9 02 	lds	r24, 0x02D9
    2922:	81 60       	ori	r24, 0x01	; 1
    2924:	80 93 d9 02 	sts	0x02D9, r24
				display[5] |= 0x1;
    2928:	80 91 da 02 	lds	r24, 0x02DA
    292c:	81 60       	ori	r24, 0x01	; 1
    292e:	80 93 da 02 	sts	0x02DA, r24
    2932:	12 e0       	ldi	r17, 0x02	; 2
    2934:	3e c0       	rjmp	.+124    	; 0x29b2 <set_time+0x14a>
			} else if (mode == SET_MIN) {
    2936:	12 30       	cpi	r17, 0x02	; 2
    2938:	11 f0       	breq	.+4      	; 0x293e <set_time+0xd6>
    293a:	10 e0       	ldi	r17, 0x00	; 0
    293c:	11 c0       	rjmp	.+34     	; 0x2960 <set_time+0xf8>
				mode = SET_SEC;
				display_time(hour, min, sec);
    293e:	8f 2d       	mov	r24, r15
    2940:	60 2f       	mov	r22, r16
    2942:	4e 2d       	mov	r20, r14
    2944:	0e 94 ca 03 	call	0x794	; 0x794 <display_time>
				display[7] |= 0x1;
    2948:	80 91 dc 02 	lds	r24, 0x02DC
    294c:	81 60       	ori	r24, 0x01	; 1
    294e:	80 93 dc 02 	sts	0x02DC, r24
				display[8] |= 0x1;
    2952:	80 91 dd 02 	lds	r24, 0x02DD
    2956:	81 60       	ori	r24, 0x01	; 1
    2958:	80 93 dd 02 	sts	0x02DD, r24
    295c:	13 e0       	ldi	r17, 0x03	; 3
    295e:	29 c0       	rjmp	.+82     	; 0x29b2 <set_time+0x14a>
    2960:	61 2f       	mov	r22, r17
    2962:	69 5f       	subi	r22, 0xF9	; 249
				// done!
				uint8_t dt[3];
				uint8_t i;
				
				for (i = 0; i < 7; i++)
					twiWriteReg(0xd0, 0x07+i, i+1);		// Write check values into alarm fields
    2964:	1f 5f       	subi	r17, 0xFF	; 255
    2966:	80 ed       	ldi	r24, 0xD0	; 208
    2968:	41 2f       	mov	r20, r17
    296a:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <twiWriteReg>
			} else {
				// done!
				uint8_t dt[3];
				uint8_t i;
				
				for (i = 0; i < 7; i++)
    296e:	17 30       	cpi	r17, 0x07	; 7
    2970:	b9 f7       	brne	.-18     	; 0x2960 <set_time+0xf8>
					twiWriteReg(0xd0, 0x07+i, i+1);		// Write check values into alarm fields
				
				time_h = hour;
    2972:	f0 92 50 02 	sts	0x0250, r15
				time_m = min;
    2976:	00 93 de 02 	sts	0x02DE, r16
				time_s = sec;
    297a:	e0 92 e5 02 	sts	0x02E5, r14
				
				TCNT2 = 0;		// Sync AVR to start of seconds
    297e:	10 92 b2 00 	sts	0x00B2, r1
				
				// Update ChronoDot
				dt[1] = b2bcd(sec);
				dt[1] = b2bcd(min);
    2982:	80 2f       	mov	r24, r16
    2984:	0e 94 43 01 	call	0x286	; 0x286 <b2bcd>
    2988:	8a 83       	std	Y+2, r24	; 0x02
				dt[2] = b2bcd(hour);
    298a:	8f 2d       	mov	r24, r15
    298c:	0e 94 43 01 	call	0x286	; 0x286 <b2bcd>
    2990:	8b 83       	std	Y+3, r24	; 0x03
				twiWriteRegN(0xd0, 0x00, 3, dt);
    2992:	80 ed       	ldi	r24, 0xD0	; 208
    2994:	60 e0       	ldi	r22, 0x00	; 0
    2996:	43 e0       	ldi	r20, 0x03	; 3
    2998:	9e 01       	movw	r18, r28
    299a:	2f 5f       	subi	r18, 0xFF	; 255
    299c:	3f 4f       	sbci	r19, 0xFF	; 255
    299e:	0e 94 17 12 	call	0x242e	; 0x242e <twiWriteRegN>
				
				DEBUGP ("ChronoDot set!");
    29a2:	83 e0       	ldi	r24, 0x03	; 3
    29a4:	91 e0       	ldi	r25, 0x01	; 1
    29a6:	61 e0       	ldi	r22, 0x01	; 1
    29a8:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <ROM_putstring>
				
				displaymode = SHOW_TIME;
    29ac:	10 92 e3 02 	sts	0x02E3, r1
    29b0:	87 c0       	rjmp	.+270    	; 0x2ac0 <set_time+0x258>
				return;
			}
		}
		if ((just_pressed & 0x4) || (pressed & 0x4)) {
    29b2:	80 91 48 02 	lds	r24, 0x0248
    29b6:	82 fd       	sbrc	r24, 2
    29b8:	04 c0       	rjmp	.+8      	; 0x29c2 <set_time+0x15a>
    29ba:	80 91 49 02 	lds	r24, 0x0249
    29be:	82 ff       	sbrs	r24, 2
    29c0:	74 cf       	rjmp	.-280    	; 0x28aa <set_time+0x42>
			just_pressed = 0;
    29c2:	10 92 48 02 	sts	0x0248, r1

			if (mode == SET_HOUR) {
    29c6:	11 30       	cpi	r17, 0x01	; 1
    29c8:	31 f5       	brne	.+76     	; 0x2a16 <set_time+0x1ae>
				hour = (hour+1) % 24;
    29ca:	8f 2d       	mov	r24, r15
    29cc:	90 e0       	ldi	r25, 0x00	; 0
    29ce:	01 96       	adiw	r24, 0x01	; 1
    29d0:	68 e1       	ldi	r22, 0x18	; 24
    29d2:	70 e0       	ldi	r23, 0x00	; 0
    29d4:	0e 94 48 1b 	call	0x3690	; 0x3690 <__divmodhi4>
    29d8:	f8 2e       	mov	r15, r24
				display_time(hour, min, sec);
    29da:	60 2f       	mov	r22, r16
    29dc:	4e 2d       	mov	r20, r14
    29de:	0e 94 ca 03 	call	0x794	; 0x794 <display_time>
				display[1] |= 0x1;
    29e2:	80 91 d6 02 	lds	r24, 0x02D6
    29e6:	81 60       	ori	r24, 0x01	; 1
    29e8:	80 93 d6 02 	sts	0x02D6, r24
				display[2] |= 0x1;
    29ec:	80 91 d7 02 	lds	r24, 0x02D7
    29f0:	81 60       	ori	r24, 0x01	; 1
    29f2:	80 93 d7 02 	sts	0x02D7, r24
				time_h = hour;
    29f6:	f0 92 50 02 	sts	0x0250, r15
				eeprom_write_byte((uint8_t *)EE_HOUR, time_h);    
    29fa:	80 91 50 02 	lds	r24, 0x0250
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    29fe:	f9 99       	sbic	0x1f, 1	; 31
    2a00:	fe cf       	rjmp	.-4      	; 0x29fe <set_time+0x196>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    2a02:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    2a04:	d2 bc       	out	0x22, r13	; 34
    2a06:	c1 bc       	out	0x21, r12	; 33
#endif
    EEDR = __value;
    2a08:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
    2a0a:	0f b6       	in	r0, 0x3f	; 63
    2a0c:	f8 94       	cli
    2a0e:	fa 9a       	sbi	0x1f, 2	; 31
    2a10:	f9 9a       	sbi	0x1f, 1	; 31
    2a12:	0f be       	out	0x3f, r0	; 63
    2a14:	44 c0       	rjmp	.+136    	; 0x2a9e <set_time+0x236>
			}
			if (mode == SET_MIN) {
    2a16:	12 30       	cpi	r17, 0x02	; 2
    2a18:	39 f5       	brne	.+78     	; 0x2a68 <set_time+0x200>
				min = (min+1) % 60;
    2a1a:	80 2f       	mov	r24, r16
    2a1c:	90 e0       	ldi	r25, 0x00	; 0
    2a1e:	01 96       	adiw	r24, 0x01	; 1
    2a20:	6c e3       	ldi	r22, 0x3C	; 60
    2a22:	70 e0       	ldi	r23, 0x00	; 0
    2a24:	0e 94 48 1b 	call	0x3690	; 0x3690 <__divmodhi4>
    2a28:	08 2f       	mov	r16, r24
				display_time(hour, min, sec);
    2a2a:	8f 2d       	mov	r24, r15
    2a2c:	60 2f       	mov	r22, r16
    2a2e:	4e 2d       	mov	r20, r14
    2a30:	0e 94 ca 03 	call	0x794	; 0x794 <display_time>
				display[4] |= 0x1;
    2a34:	80 91 d9 02 	lds	r24, 0x02D9
    2a38:	81 60       	ori	r24, 0x01	; 1
    2a3a:	80 93 d9 02 	sts	0x02D9, r24
				display[5] |= 0x1;
    2a3e:	80 91 da 02 	lds	r24, 0x02DA
    2a42:	81 60       	ori	r24, 0x01	; 1
    2a44:	80 93 da 02 	sts	0x02DA, r24
				eeprom_write_byte((uint8_t *)EE_MIN, time_m);
    2a48:	80 91 de 02 	lds	r24, 0x02DE
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2a4c:	f9 99       	sbic	0x1f, 1	; 31
    2a4e:	fe cf       	rjmp	.-4      	; 0x2a4c <set_time+0x1e4>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    2a50:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    2a52:	b2 bc       	out	0x22, r11	; 34
    2a54:	a1 bc       	out	0x21, r10	; 33
#endif
    EEDR = __value;
    2a56:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
    2a58:	0f b6       	in	r0, 0x3f	; 63
    2a5a:	f8 94       	cli
    2a5c:	fa 9a       	sbi	0x1f, 2	; 31
    2a5e:	f9 9a       	sbi	0x1f, 1	; 31
    2a60:	0f be       	out	0x3f, r0	; 63
				time_m = min;
    2a62:	00 93 de 02 	sts	0x02DE, r16
    2a66:	1b c0       	rjmp	.+54     	; 0x2a9e <set_time+0x236>
			}
			if ((mode == SET_SEC) ) {
    2a68:	13 30       	cpi	r17, 0x03	; 3
    2a6a:	c9 f4       	brne	.+50     	; 0x2a9e <set_time+0x236>
				sec = (sec+1) % 60;
    2a6c:	8e 2d       	mov	r24, r14
    2a6e:	90 e0       	ldi	r25, 0x00	; 0
    2a70:	01 96       	adiw	r24, 0x01	; 1
    2a72:	6c e3       	ldi	r22, 0x3C	; 60
    2a74:	70 e0       	ldi	r23, 0x00	; 0
    2a76:	0e 94 48 1b 	call	0x3690	; 0x3690 <__divmodhi4>
    2a7a:	e8 2e       	mov	r14, r24
				display_time(hour, min, sec);
    2a7c:	8f 2d       	mov	r24, r15
    2a7e:	60 2f       	mov	r22, r16
    2a80:	4e 2d       	mov	r20, r14
    2a82:	0e 94 ca 03 	call	0x794	; 0x794 <display_time>
				display[7] |= 0x1;
    2a86:	80 91 dc 02 	lds	r24, 0x02DC
    2a8a:	81 60       	ori	r24, 0x01	; 1
    2a8c:	80 93 dc 02 	sts	0x02DC, r24
				display[8] |= 0x1;
    2a90:	80 91 dd 02 	lds	r24, 0x02DD
    2a94:	81 60       	ori	r24, 0x01	; 1
    2a96:	80 93 dd 02 	sts	0x02DD, r24
				time_s = sec;
    2a9a:	e0 92 e5 02 	sts	0x02E5, r14
			}

			if (pressed & 0x4)
    2a9e:	80 91 49 02 	lds	r24, 0x0249
    2aa2:	82 ff       	sbrs	r24, 2
    2aa4:	02 cf       	rjmp	.-508    	; 0x28aa <set_time+0x42>

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    2aa6:	78 94       	sei

	milliseconds = 0;
    2aa8:	10 92 46 02 	sts	0x0246, r1
    2aac:	10 92 45 02 	sts	0x0245, r1
	while (milliseconds < ms);
    2ab0:	80 91 45 02 	lds	r24, 0x0245
    2ab4:	90 91 46 02 	lds	r25, 0x0246
    2ab8:	8b 34       	cpi	r24, 0x4B	; 75
    2aba:	91 05       	cpc	r25, r1
    2abc:	c8 f3       	brcs	.-14     	; 0x2ab0 <set_time+0x248>
    2abe:	f5 ce       	rjmp	.-534    	; 0x28aa <set_time+0x42>

			if (pressed & 0x4)
				delayms(75);
		}
	}
}
    2ac0:	0f 90       	pop	r0
    2ac2:	0f 90       	pop	r0
    2ac4:	0f 90       	pop	r0
    2ac6:	cf 91       	pop	r28
    2ac8:	df 91       	pop	r29
    2aca:	1f 91       	pop	r17
    2acc:	0f 91       	pop	r16
    2ace:	ff 90       	pop	r15
    2ad0:	ef 90       	pop	r14
    2ad2:	df 90       	pop	r13
    2ad4:	cf 90       	pop	r12
    2ad6:	bf 90       	pop	r11
    2ad8:	af 90       	pop	r10
    2ada:	9f 90       	pop	r9
    2adc:	08 95       	ret

00002ade <main>:
	PCMSK2 = _BV(PCINT21) | _BV(PCINT20);    
}



int main(void) {
    2ade:	9f 92       	push	r9
    2ae0:	af 92       	push	r10
    2ae2:	bf 92       	push	r11
    2ae4:	cf 92       	push	r12
    2ae6:	df 92       	push	r13
    2ae8:	ef 92       	push	r14
    2aea:	ff 92       	push	r15
    2aec:	0f 93       	push	r16
    2aee:	1f 93       	push	r17
	//  uint8_t i;
	uint8_t mcustate;

	// turn boost off
	TCCR0B = 0;
    2af0:	15 bc       	out	0x25, r1	; 37
	BOOST_DDR |= _BV(BOOST);
    2af2:	56 9a       	sbi	0x0a, 6	; 10
	BOOST_PORT &= ~_BV(BOOST); // pull boost fet low
    2af4:	5e 98       	cbi	0x0b, 6	; 11

	// check if we were reset
	mcustate = MCUSR;
    2af6:	84 b7       	in	r24, 0x34	; 52
	MCUSR = 0;
    2af8:	14 be       	out	0x34, r1	; 52

	uart_putw_hex(mcustate);
    2afa:	90 e0       	ldi	r25, 0x00	; 0
    2afc:	0e 94 94 17 	call	0x2f28	; 0x2f28 <uart_putw_hex>

	wdt_disable();
    2b00:	88 e1       	ldi	r24, 0x18	; 24
    2b02:	0f b6       	in	r0, 0x3f	; 63
    2b04:	f8 94       	cli
    2b06:	80 93 60 00 	sts	0x0060, r24
    2b0a:	10 92 60 00 	sts	0x0060, r1
    2b0e:	0f be       	out	0x3f, r0	; 63
	// now turn it back on... 2 second time out
	//WDTCSR |= _BV(WDP0) | _BV(WDP1) | _BV(WDP2);
	//WDTCSR = _BV(WDE);
	wdt_enable(WDTO_2S);
    2b10:	2f e0       	ldi	r18, 0x0F	; 15
    2b12:	88 e1       	ldi	r24, 0x18	; 24
    2b14:	90 e0       	ldi	r25, 0x00	; 0
    2b16:	0f b6       	in	r0, 0x3f	; 63
    2b18:	f8 94       	cli
    2b1a:	a8 95       	wdr
    2b1c:	80 93 60 00 	sts	0x0060, r24
    2b20:	0f be       	out	0x3f, r0	; 63
    2b22:	20 93 60 00 	sts	0x0060, r18
	displaymode = SHOW_TIME;
}

// we reset the watchdog timer 
void kickthedog(void) {
	wdt_reset();
    2b26:	a8 95       	wdr
	// we lost power at some point so lets alert the user
	// that the time may be wrong (the clock still works)
	//timeunknown = 1;

	// have we read the time & date from eeprom?
	restored = 0;
    2b28:	10 92 3a 02 	sts	0x023A, r1

	// setup uart
	uart_init(BRRL_4800);
    2b2c:	87 e6       	ldi	r24, 0x67	; 103
    2b2e:	90 e0       	ldi	r25, 0x00	; 0
    2b30:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <uart_init>

	//DEBUGP("VFD Clock");
	DEBUGP("!");
    2b34:	84 e7       	ldi	r24, 0x74	; 116
    2b36:	91 e0       	ldi	r25, 0x01	; 1
    2b38:	61 e0       	ldi	r22, 0x01	; 1
    2b3a:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <ROM_putstring>
	uart_puts("\n\rHello World!\n\r");
    2b3e:	8d ec       	ldi	r24, 0xCD	; 205
    2b40:	91 e0       	ldi	r25, 0x01	; 1
    2b42:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <uart_puts>
	uart_puts("\n\rBuffer size is:\t");
    2b46:	8e ed       	ldi	r24, 0xDE	; 222
    2b48:	91 e0       	ldi	r25, 0x01	; 1
    2b4a:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <uart_puts>
	uart_putw_dec(BUFFERSIZE);
    2b4e:	80 e8       	ldi	r24, 0x80	; 128
    2b50:	90 e0       	ldi	r25, 0x00	; 0
    2b52:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <uart_putw_dec>
	uart_puts("\n\r");
    2b56:	81 ef       	ldi	r24, 0xF1	; 241
    2b58:	91 e0       	ldi	r25, 0x01	; 1
    2b5a:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <uart_puts>
	kickthedog();
}


void initbuttons(void) {
	DDRB =  _BV(VFDCLK) | _BV(VFDDATA) | _BV(SPK1) | _BV(SPK2);
    2b5e:	8e e2       	ldi	r24, 0x2E	; 46
    2b60:	84 b9       	out	0x04, r24	; 4
	DDRD = _BV(BOOST) | _BV(VFDSWITCH);
    2b62:	88 e4       	ldi	r24, 0x48	; 72
    2b64:	8a b9       	out	0x0a, r24	; 10
	DDRC = _BV(VFDLOAD) | _BV(VFDBLANK);
    2b66:	89 e0       	ldi	r24, 0x09	; 9
    2b68:	87 b9       	out	0x07, r24	; 7
	PORTD = _BV(BUTTON1) | _BV(BUTTON3) | _BV(ALARM);
    2b6a:	84 e3       	ldi	r24, 0x34	; 52
    2b6c:	8b b9       	out	0x0b, r24	; 11
	PORTB = _BV(BUTTON2);
    2b6e:	11 e0       	ldi	r17, 0x01	; 1
    2b70:	15 b9       	out	0x05, r17	; 5

	PCICR = _BV(PCIE0) | _BV(PCIE2);
    2b72:	85 e0       	ldi	r24, 0x05	; 5
    2b74:	80 93 68 00 	sts	0x0068, r24
	PCMSK0 = _BV(PCINT0);
    2b78:	10 93 6b 00 	sts	0x006B, r17
	PCMSK2 = _BV(PCINT21) | _BV(PCINT20);    
    2b7c:	80 e3       	ldi	r24, 0x30	; 48
    2b7e:	80 93 6d 00 	sts	0x006D, r24
	// we aren't in low power mode so init stuff

	// init IOs
	initbuttons();

	VFDSWITCH_PORT &= ~_BV(VFDSWITCH);
    2b82:	5b 98       	cbi	0x0b, 3	; 11

	DEBUGP("turning on buttons");
    2b84:	81 e6       	ldi	r24, 0x61	; 97
    2b86:	91 e0       	ldi	r25, 0x01	; 1
    2b88:	61 e0       	ldi	r22, 0x01	; 1
    2b8a:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <ROM_putstring>
	// set up button interrupts
	DEBUGP("turning on alarmsw");
    2b8e:	8e e4       	ldi	r24, 0x4E	; 78
    2b90:	91 e0       	ldi	r25, 0x01	; 1
    2b92:	61 e0       	ldi	r22, 0x01	; 1
    2b94:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <ROM_putstring>
	// set off an interrupt if alarm is set or unset
	EICRA = _BV(ISC00);
    2b98:	10 93 69 00 	sts	0x0069, r17
	EIMSK = _BV(INT0);
    2b9c:	1d bb       	out	0x1d, r17	; 29

	displaymode = SHOW_TIME;
    2b9e:	10 92 e3 02 	sts	0x02E3, r1
	DEBUGP("vfd init");
    2ba2:	85 e4       	ldi	r24, 0x45	; 69
    2ba4:	91 e0       	ldi	r25, 0x01	; 1
    2ba6:	61 e0       	ldi	r22, 0x01	; 1
    2ba8:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <ROM_putstring>

/************************* LOW LEVEL DISPLAY ************************/

// Setup SPI
void vfd_init(void) {
	SPCR  = _BV(SPE) | _BV(MSTR) | _BV(SPR0);
    2bac:	81 e5       	ldi	r24, 0x51	; 81
    2bae:	8c bd       	out	0x2c, r24	; 44
	displaymode = SHOW_TIME;
	DEBUGP("vfd init");
	vfd_init();

#ifdef FEATURE_AUTODIM
	dimmer_init();
    2bb0:	0e 94 23 03 	call	0x646	; 0x646 <dimmer_init>
#endif

	DEBUGP("boost init");
    2bb4:	8a e3       	ldi	r24, 0x3A	; 58
    2bb6:	91 e0       	ldi	r25, 0x01	; 1
    2bb8:	61 e0       	ldi	r22, 0x01	; 1
    2bba:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <ROM_putstring>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2bbe:	f9 99       	sbic	0x1f, 1	; 31
    2bc0:	fe cf       	rjmp	.-4      	; 0x2bbe <main+0xe0>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    2bc2:	89 e0       	ldi	r24, 0x09	; 9
    2bc4:	90 e0       	ldi	r25, 0x00	; 0
    2bc6:	92 bd       	out	0x22, r25	; 34
    2bc8:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2bca:	f8 9a       	sbi	0x1f, 0	; 31
    2bcc:	80 b5       	in	r24, 0x20	; 32
	brightness_level = eeprom_read_byte((uint8_t *)EE_BRIGHT);
    2bce:	80 93 e1 02 	sts	0x02E1, r24
	boost_init(brightness_level);
    2bd2:	80 91 e1 02 	lds	r24, 0x02E1
    2bd6:	0e 94 a5 03 	call	0x74a	; 0x74a <boost_init>
	sei();
    2bda:	78 94       	sei
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2bdc:	f9 99       	sbic	0x1f, 1	; 31
    2bde:	fe cf       	rjmp	.-4      	; 0x2bdc <main+0xfe>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    2be0:	8d e0       	ldi	r24, 0x0D	; 13
    2be2:	90 e0       	ldi	r25, 0x00	; 0
    2be4:	92 bd       	out	0x22, r25	; 34
    2be6:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2be8:	f8 9a       	sbi	0x1f, 0	; 31
    2bea:	80 b5       	in	r24, 0x20	; 32

	//Load and check the timezone information
	intTimeZoneHour = eeprom_read_byte((uint8_t *)EE_ZONE_HOUR);
    2bec:	80 93 34 02 	sts	0x0234, r24
	if ( ( 12 < intTimeZoneHour ) || ( -12 > intTimeZoneHour ) )
    2bf0:	84 5f       	subi	r24, 0xF4	; 244
    2bf2:	89 31       	cpi	r24, 0x19	; 25
    2bf4:	10 f0       	brcs	.+4      	; 0x2bfa <main+0x11c>
		intTimeZoneHour = 0;
    2bf6:	10 92 34 02 	sts	0x0234, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2bfa:	f9 99       	sbic	0x1f, 1	; 31
    2bfc:	fe cf       	rjmp	.-4      	; 0x2bfa <main+0x11c>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    2bfe:	8e e0       	ldi	r24, 0x0E	; 14
    2c00:	90 e0       	ldi	r25, 0x00	; 0
    2c02:	92 bd       	out	0x22, r25	; 34
    2c04:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2c06:	f8 9a       	sbi	0x1f, 0	; 31
    2c08:	80 b5       	in	r24, 0x20	; 32

	intTimeZoneMin = eeprom_read_byte((uint8_t *)EE_ZONE_MIN);
    2c0a:	80 93 3c 02 	sts	0x023C, r24
	if ( ( 60 < intTimeZoneMin ) || ( 0 > intTimeZoneMin ) )
    2c0e:	8d 33       	cpi	r24, 0x3D	; 61
    2c10:	10 f0       	brcs	.+4      	; 0x2c16 <main+0x138>
		intTimeZoneMin = 0;
    2c12:	10 92 3c 02 	sts	0x023C, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2c16:	f9 99       	sbic	0x1f, 1	; 31
    2c18:	fe cf       	rjmp	.-4      	; 0x2c16 <main+0x138>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    2c1a:	8b e0       	ldi	r24, 0x0B	; 11
    2c1c:	90 e0       	ldi	r25, 0x00	; 0
    2c1e:	92 bd       	out	0x22, r25	; 34
    2c20:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2c22:	f8 9a       	sbi	0x1f, 0	; 31
    2c24:	80 b5       	in	r24, 0x20	; 32

	region = eeprom_read_byte((uint8_t *)EE_REGION);
    2c26:	80 93 38 02 	sts	0x0238, r24

	DEBUGP("speaker init");
    2c2a:	8d e2       	ldi	r24, 0x2D	; 45
    2c2c:	91 e0       	ldi	r25, 0x01	; 1
    2c2e:	61 e0       	ldi	r22, 0x01	; 1
    2c30:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <ROM_putstring>
	speaker_init();
    2c34:	0e 94 7f 02 	call	0x4fe	; 0x4fe <speaker_init>

	beep(4000, 1);
    2c38:	80 ea       	ldi	r24, 0xA0	; 160
    2c3a:	9f e0       	ldi	r25, 0x0F	; 15
    2c3c:	61 e0       	ldi	r22, 0x01	; 1
    2c3e:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <beep>

	DEBUGP("clock init");
    2c42:	82 e2       	ldi	r24, 0x22	; 34
    2c44:	91 e0       	ldi	r25, 0x01	; 1
    2c46:	61 e0       	ldi	r22, 0x01	; 1
    2c48:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <ROM_putstring>
}

// Turn on the RTC by selecting the external 32khz crystal
void rtc_init (void) {
	// 32.768 / 128 = 256 which is exactly an 8-bit timer overflow
	ASSR |= _BV(EXCLK);		// External clock (comment out if using xtal)
    2c4c:	80 91 b6 00 	lds	r24, 0x00B6
    2c50:	80 64       	ori	r24, 0x40	; 64
    2c52:	80 93 b6 00 	sts	0x00B6, r24
	ASSR |= _BV(AS2); // use crystal
    2c56:	80 91 b6 00 	lds	r24, 0x00B6
    2c5a:	80 62       	ori	r24, 0x20	; 32
    2c5c:	80 93 b6 00 	sts	0x00B6, r24
	TCCR2A = 0;
    2c60:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = _BV(CS22) | _BV(CS20); // div by 128
    2c64:	85 e0       	ldi	r24, 0x05	; 5
    2c66:	80 93 b1 00 	sts	0x00B1, r24
	// We will overflow once a second, and call an interrupt

	CLKPR = _BV(CLKPCE);	// CPU clock division factor to 1
    2c6a:	80 e8       	ldi	r24, 0x80	; 128
    2c6c:	80 93 61 00 	sts	0x0061, r24
	CLKPR = 0;
    2c70:	10 92 61 00 	sts	0x0061, r1

	// enable interrupt on overflow
	TIMSK2 = _BV(TOIE2);
    2c74:	81 e0       	ldi	r24, 0x01	; 1
    2c76:	80 93 70 00 	sts	0x0070, r24

	beep(4000, 1);

	DEBUGP("clock init");
	rtc_init();
	clock_init();  
    2c7a:	0e 94 48 11 	call	0x2290	; 0x2290 <clock_init>

	sei();
    2c7e:	78 94       	sei

	DEBUGP("alarm init");
    2c80:	87 e1       	ldi	r24, 0x17	; 23
    2c82:	91 e0       	ldi	r25, 0x01	; 1
    2c84:	61 e0       	ldi	r22, 0x01	; 1
    2c86:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <ROM_putstring>
	alarm_init();
    2c8a:	0e 94 af 01 	call	0x35e	; 0x35e <alarm_init>

	DEBUGP("done");
    2c8e:	82 e1       	ldi	r24, 0x12	; 18
    2c90:	91 e0       	ldi	r25, 0x01	; 1
    2c92:	61 e0       	ldi	r22, 0x01	; 1
    2c94:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <ROM_putstring>
				default:
					displaymode = SHOW_TIME;
			}
		} else if ((just_pressed & 0x2) || (just_pressed & 0x4)) {
			just_pressed = 0;
			displaymode = NONE;
    2c98:	83 e6       	ldi	r24, 0x63	; 99
    2c9a:	98 2e       	mov	r9, r24
					break;
				case (SET_DATE):
					//displaymode = SET_BRIGHTNESS;
					//display_str("set brit");
					//set_brightness();
					displaymode = SET_ZONE;
    2c9c:	0b e0       	ldi	r16, 0x0B	; 11
    2c9e:	b0 2e       	mov	r11, r16
					displaymode = SET_VOLUME;
					display_str("set vol ");
					set_volume();
					break;
				case (SET_VOLUME):
					displaymode = SET_REGION;
    2ca0:	18 e0       	ldi	r17, 0x08	; 8
    2ca2:	a1 2e       	mov	r10, r17
					displaymode = SET_BRIGHTNESS;
					display_str("set brit");
					set_brightness();
					break;
				case (SET_BRIGHTNESS):
					displaymode = SET_VOLUME;
    2ca4:	b7 e0       	ldi	r27, 0x07	; 7
    2ca6:	cb 2e       	mov	r12, r27
					displaymode = SET_ZONE;
					display_str("set zone");
					set_timezone();
					break;
				case (SET_ZONE):
					displaymode = SET_BRIGHTNESS;
    2ca8:	a6 e0       	ldi	r26, 0x06	; 6
    2caa:	da 2e       	mov	r13, r26
					display_str("set time");
					set_time();
					//timeunknown = 0;
					break;
				case (SET_TIME):
					displaymode = SET_DATE;
    2cac:	f5 e0       	ldi	r31, 0x05	; 5
    2cae:	ef 2e       	mov	r14, r31
					displaymode = SET_ALARM;
					display_str("set alarm");
					set_alarm();
					break;
				case (SET_ALARM):
					displaymode = SET_TIME;
    2cb0:	e3 e0       	ldi	r30, 0x03	; 3
    2cb2:	fe 2e       	mov	r15, r30
		//DEBUGP(".");
		if (just_pressed & 0x1) {
			just_pressed = 0;
			switch(displaymode) {
				case (SHOW_TIME):
					displaymode = SET_ALARM;
    2cb4:	04 e0       	ldi	r16, 0x04	; 4
	displaymode = SHOW_TIME;
}

// we reset the watchdog timer 
void kickthedog(void) {
	wdt_reset();
    2cb6:	a8 95       	wdr
	DEBUGP("done");
	while (1) {
		//_delay_ms(100);
		kickthedog();
		//uart_putc_hex(ACSR);
		if (ACSR & _BV(ACO)) {
    2cb8:	00 b6       	in	r0, 0x30	; 48
    2cba:	05 fe       	sbrs	r0, 5
    2cbc:	03 c0       	rjmp	.+6      	; 0x2cc4 <main+0x1e6>
			// DEBUGP("SLEEPYTIME");
			gotosleep();
    2cbe:	0e 94 03 01 	call	0x206	; 0x206 <gotosleep>
    2cc2:	f9 cf       	rjmp	.-14     	; 0x2cb6 <main+0x1d8>
			continue;
		}
		//DEBUGP(".");
		if (just_pressed & 0x1) {
    2cc4:	80 91 48 02 	lds	r24, 0x0248
    2cc8:	80 ff       	sbrs	r24, 0
    2cca:	56 c0       	rjmp	.+172    	; 0x2d78 <main+0x29a>
			just_pressed = 0;
    2ccc:	10 92 48 02 	sts	0x0248, r1
			switch(displaymode) {
    2cd0:	80 91 e3 02 	lds	r24, 0x02E3
    2cd4:	85 30       	cpi	r24, 0x05	; 5
    2cd6:	61 f1       	breq	.+88     	; 0x2d30 <main+0x252>
    2cd8:	86 30       	cpi	r24, 0x06	; 6
    2cda:	38 f4       	brcc	.+14     	; 0x2cea <main+0x20c>
    2cdc:	83 30       	cpi	r24, 0x03	; 3
    2cde:	f9 f0       	breq	.+62     	; 0x2d1e <main+0x240>
    2ce0:	84 30       	cpi	r24, 0x04	; 4
    2ce2:	a0 f4       	brcc	.+40     	; 0x2d0c <main+0x22e>
    2ce4:	88 23       	and	r24, r24
    2ce6:	49 f0       	breq	.+18     	; 0x2cfa <main+0x21c>
    2ce8:	64 c0       	rjmp	.+200    	; 0x2db2 <main+0x2d4>
    2cea:	87 30       	cpi	r24, 0x07	; 7
    2cec:	e1 f1       	breq	.+120    	; 0x2d66 <main+0x288>
    2cee:	87 30       	cpi	r24, 0x07	; 7
    2cf0:	88 f1       	brcs	.+98     	; 0x2d54 <main+0x276>
    2cf2:	8b 30       	cpi	r24, 0x0B	; 11
    2cf4:	09 f0       	breq	.+2      	; 0x2cf8 <main+0x21a>
    2cf6:	5d c0       	rjmp	.+186    	; 0x2db2 <main+0x2d4>
    2cf8:	24 c0       	rjmp	.+72     	; 0x2d42 <main+0x264>
				case (SHOW_TIME):
					displaymode = SET_ALARM;
    2cfa:	00 93 e3 02 	sts	0x02E3, r16
					display_str("set alarm");
    2cfe:	84 ef       	ldi	r24, 0xF4	; 244
    2d00:	91 e0       	ldi	r25, 0x01	; 1
    2d02:	0e 94 2d 06 	call	0xc5a	; 0xc5a <display_str>
					set_alarm();
    2d06:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <set_alarm>
    2d0a:	55 c0       	rjmp	.+170    	; 0x2db6 <main+0x2d8>
					break;
				case (SET_ALARM):
					displaymode = SET_TIME;
    2d0c:	f0 92 e3 02 	sts	0x02E3, r15
					display_str("set time");
    2d10:	8e ef       	ldi	r24, 0xFE	; 254
    2d12:	91 e0       	ldi	r25, 0x01	; 1
    2d14:	0e 94 2d 06 	call	0xc5a	; 0xc5a <display_str>
					set_time();
    2d18:	0e 94 34 14 	call	0x2868	; 0x2868 <set_time>
    2d1c:	4c c0       	rjmp	.+152    	; 0x2db6 <main+0x2d8>
					//timeunknown = 0;
					break;
				case (SET_TIME):
					displaymode = SET_DATE;
    2d1e:	e0 92 e3 02 	sts	0x02E3, r14
					display_str("set date");
    2d22:	87 e0       	ldi	r24, 0x07	; 7
    2d24:	92 e0       	ldi	r25, 0x02	; 2
    2d26:	0e 94 2d 06 	call	0xc5a	; 0xc5a <display_str>
					set_date();
    2d2a:	0e 94 6d 12 	call	0x24da	; 0x24da <set_date>
    2d2e:	43 c0       	rjmp	.+134    	; 0x2db6 <main+0x2d8>
					break;
				case (SET_DATE):
					//displaymode = SET_BRIGHTNESS;
					//display_str("set brit");
					//set_brightness();
					displaymode = SET_ZONE;
    2d30:	b0 92 e3 02 	sts	0x02E3, r11
					display_str("set zone");
    2d34:	80 e1       	ldi	r24, 0x10	; 16
    2d36:	92 e0       	ldi	r25, 0x02	; 2
    2d38:	0e 94 2d 06 	call	0xc5a	; 0xc5a <display_str>
					set_timezone();
    2d3c:	0e 94 0e 0f 	call	0x1e1c	; 0x1e1c <set_timezone>
    2d40:	3a c0       	rjmp	.+116    	; 0x2db6 <main+0x2d8>
					break;
				case (SET_ZONE):
					displaymode = SET_BRIGHTNESS;
    2d42:	d0 92 e3 02 	sts	0x02E3, r13
					display_str("set brit");
    2d46:	89 e1       	ldi	r24, 0x19	; 25
    2d48:	92 e0       	ldi	r25, 0x02	; 2
    2d4a:	0e 94 2d 06 	call	0xc5a	; 0xc5a <display_str>
					set_brightness();
    2d4e:	0e 94 ee 08 	call	0x11dc	; 0x11dc <set_brightness>
    2d52:	31 c0       	rjmp	.+98     	; 0x2db6 <main+0x2d8>
					break;
				case (SET_BRIGHTNESS):
					displaymode = SET_VOLUME;
    2d54:	c0 92 e3 02 	sts	0x02E3, r12
					display_str("set vol ");
    2d58:	82 e2       	ldi	r24, 0x22	; 34
    2d5a:	92 e0       	ldi	r25, 0x02	; 2
    2d5c:	0e 94 2d 06 	call	0xc5a	; 0xc5a <display_str>
					set_volume();
    2d60:	0e 94 50 08 	call	0x10a0	; 0x10a0 <set_volume>
    2d64:	28 c0       	rjmp	.+80     	; 0x2db6 <main+0x2d8>
					break;
				case (SET_VOLUME):
					displaymode = SET_REGION;
    2d66:	a0 92 e3 02 	sts	0x02E3, r10
					display_str("set regn");
    2d6a:	8b e2       	ldi	r24, 0x2B	; 43
    2d6c:	92 e0       	ldi	r25, 0x02	; 2
    2d6e:	0e 94 2d 06 	call	0xc5a	; 0xc5a <display_str>
					set_region();
    2d72:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <set_region>
    2d76:	1f c0       	rjmp	.+62     	; 0x2db6 <main+0x2d8>
					   break;
					   */
				default:
					displaymode = SHOW_TIME;
			}
		} else if ((just_pressed & 0x2) || (just_pressed & 0x4)) {
    2d78:	80 91 48 02 	lds	r24, 0x0248
    2d7c:	81 fd       	sbrc	r24, 1
    2d7e:	04 c0       	rjmp	.+8      	; 0x2d88 <main+0x2aa>
    2d80:	80 91 48 02 	lds	r24, 0x0248
    2d84:	82 ff       	sbrs	r24, 2
    2d86:	17 c0       	rjmp	.+46     	; 0x2db6 <main+0x2d8>
			just_pressed = 0;
    2d88:	10 92 48 02 	sts	0x0248, r1
			displaymode = NONE;
    2d8c:	90 92 e3 02 	sts	0x02E3, r9
			display_date(DAY);
    2d90:	81 e0       	ldi	r24, 0x01	; 1
    2d92:	0e 94 54 06 	call	0xca8	; 0xca8 <display_date>
	displaymode = SHOW_TIME;
}

// we reset the watchdog timer 
void kickthedog(void) {
	wdt_reset();
    2d96:	a8 95       	wdr

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    2d98:	78 94       	sei

	milliseconds = 0;
    2d9a:	10 92 46 02 	sts	0x0246, r1
    2d9e:	10 92 45 02 	sts	0x0245, r1
	while (milliseconds < ms);
    2da2:	80 91 45 02 	lds	r24, 0x0245
    2da6:	90 91 46 02 	lds	r25, 0x0246
    2daa:	8c 5d       	subi	r24, 0xDC	; 220
    2dac:	95 40       	sbci	r25, 0x05	; 5
    2dae:	c8 f3       	brcs	.-14     	; 0x2da2 <main+0x2c4>
	displaymode = SHOW_TIME;
}

// we reset the watchdog timer 
void kickthedog(void) {
	wdt_reset();
    2db0:	a8 95       	wdr

			kickthedog();
			delayms(1500);
			kickthedog();

			displaymode = SHOW_TIME;     
    2db2:	10 92 e3 02 	sts	0x02E3, r1
		}

		uint8_t h = (time_h + flag(f_dst_offset)) % 24;		// DST-adjusted hour
    2db6:	20 91 50 02 	lds	r18, 0x0250
    2dba:	80 91 e6 02 	lds	r24, 0x02E6
    2dbe:	90 e0       	ldi	r25, 0x00	; 0
    2dc0:	81 70       	andi	r24, 0x01	; 1
    2dc2:	90 70       	andi	r25, 0x00	; 0
    2dc4:	33 27       	eor	r19, r19
    2dc6:	27 fd       	sbrc	r18, 7
    2dc8:	30 95       	com	r19
    2dca:	82 0f       	add	r24, r18
    2dcc:	93 1f       	adc	r25, r19
    2dce:	68 e1       	ldi	r22, 0x18	; 24
    2dd0:	70 e0       	ldi	r23, 0x00	; 0
    2dd2:	0e 94 48 1b 	call	0x3690	; 0x3690 <__divmodhi4>
    2dd6:	18 2f       	mov	r17, r24
		//if (flag(f_timeunknown) && (time_s % 2))
			//display_clear();
		//else
		display_time(h, time_m, time_s);
    2dd8:	60 91 de 02 	lds	r22, 0x02DE
    2ddc:	40 91 e5 02 	lds	r20, 0x02E5
    2de0:	0e 94 ca 03 	call	0x794	; 0x794 <display_time>

		if (h == 2 && time_m == 30 && time_s == 0)
    2de4:	12 30       	cpi	r17, 0x02	; 2
    2de6:	09 f0       	breq	.+2      	; 0x2dea <main+0x30c>
    2de8:	66 cf       	rjmp	.-308    	; 0x2cb6 <main+0x1d8>
    2dea:	80 91 de 02 	lds	r24, 0x02DE
    2dee:	8e 31       	cpi	r24, 0x1E	; 30
    2df0:	09 f0       	breq	.+2      	; 0x2df4 <main+0x316>
    2df2:	61 cf       	rjmp	.-318    	; 0x2cb6 <main+0x1d8>
    2df4:	80 91 e5 02 	lds	r24, 0x02E5
    2df8:	88 23       	and	r24, r24
    2dfa:	09 f0       	breq	.+2      	; 0x2dfe <main+0x320>
    2dfc:	5c cf       	rjmp	.-328    	; 0x2cb6 <main+0x1d8>
			clock_init();	// Re-sync with ChronoDot once a day
    2dfe:	0e 94 48 11 	call	0x2290	; 0x2290 <clock_init>
    2e02:	59 cf       	rjmp	.-334    	; 0x2cb6 <main+0x1d8>

00002e04 <delay_10us>:
#include <util/delay.h>
#include <avr/pgmspace.h>
#include "util.h"

void delay_10us(uint8_t ns)
{
    2e04:	06 c0       	rjmp	.+12     	; 0x2e12 <delay_10us+0xe>
  uint8_t i;
  
  while (ns != 0) {
    2e06:	90 e0       	ldi	r25, 0x00	; 0
    ns--;
    for (i=0; i< 30; i++) {
      nop;
    2e08:	00 00       	nop
{
  uint8_t i;
  
  while (ns != 0) {
    ns--;
    for (i=0; i< 30; i++) {
    2e0a:	9f 5f       	subi	r25, 0xFF	; 255
    2e0c:	9e 31       	cpi	r25, 0x1E	; 30
    2e0e:	e1 f7       	brne	.-8      	; 0x2e08 <delay_10us+0x4>
void delay_10us(uint8_t ns)
{
  uint8_t i;
  
  while (ns != 0) {
    ns--;
    2e10:	81 50       	subi	r24, 0x01	; 1

void delay_10us(uint8_t ns)
{
  uint8_t i;
  
  while (ns != 0) {
    2e12:	88 23       	and	r24, r24
    2e14:	c1 f7       	brne	.-16     	; 0x2e06 <delay_10us+0x2>
    ns--;
    for (i=0; i< 30; i++) {
      nop;
    }
  }
}
    2e16:	08 95       	ret

00002e18 <delay_s>:
    2e18:	48 ec       	ldi	r20, 0xC8	; 200
    2e1a:	50 e0       	ldi	r21, 0x00	; 0
    2e1c:	09 c0       	rjmp	.+18     	; 0x2e30 <delay_s+0x18>

void delay_s(uint8_t s) {
  while (s--) {
    2e1e:	20 e1       	ldi	r18, 0x10	; 16
    2e20:	37 e2       	ldi	r19, 0x27	; 39
    2e22:	fa 01       	movw	r30, r20
    2e24:	31 97       	sbiw	r30, 0x01	; 1
    2e26:	f1 f7       	brne	.-4      	; 0x2e24 <delay_s+0xc>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2e28:	21 50       	subi	r18, 0x01	; 1
    2e2a:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2e2c:	d1 f7       	brne	.-12     	; 0x2e22 <delay_s+0xa>
    2e2e:	81 50       	subi	r24, 0x01	; 1
    2e30:	88 23       	and	r24, r24
    2e32:	a9 f7       	brne	.-22     	; 0x2e1e <delay_s+0x6>
    _delay_ms(1000);
  }
}
    2e34:	08 95       	ret

00002e36 <uart_init>:

void uart_init(uint16_t BRR) {
  /* setup the main UART */
  UBRR0 = BRR;               // set baudrate counter
    2e36:	90 93 c5 00 	sts	0x00C5, r25
    2e3a:	80 93 c4 00 	sts	0x00C4, r24

  UCSR0B = _BV(RXEN0) | _BV(TXEN0);
    2e3e:	88 e1       	ldi	r24, 0x18	; 24
    2e40:	80 93 c1 00 	sts	0x00C1, r24
  UCSR0C = _BV(USBS0) | (3<<UCSZ00);
    2e44:	8e e0       	ldi	r24, 0x0E	; 14
    2e46:	80 93 c2 00 	sts	0x00C2, r24
  DDRD |= _BV(PD1);
    2e4a:	51 9a       	sbi	0x0a, 1	; 10
  DDRD &= ~_BV(PD0);
    2e4c:	50 98       	cbi	0x0a, 0	; 10

}
    2e4e:	08 95       	ret

00002e50 <uart_putchar>:

int uart_putchar(char c)
{
    2e50:	98 2f       	mov	r25, r24
  loop_until_bit_is_set(UCSR0A, UDRE0);
    2e52:	80 91 c0 00 	lds	r24, 0x00C0
    2e56:	85 ff       	sbrs	r24, 5
    2e58:	fc cf       	rjmp	.-8      	; 0x2e52 <uart_putchar+0x2>
  UDR0 = c;
    2e5a:	90 93 c6 00 	sts	0x00C6, r25
  return 0;
}
    2e5e:	80 e0       	ldi	r24, 0x00	; 0
    2e60:	90 e0       	ldi	r25, 0x00	; 0
    2e62:	08 95       	ret

00002e64 <uart_getchar>:

char uart_getchar(void) {
	while (!(UCSR0A & _BV(RXC0)));
    2e64:	80 91 c0 00 	lds	r24, 0x00C0
    2e68:	87 ff       	sbrs	r24, 7
    2e6a:	fc cf       	rjmp	.-8      	; 0x2e64 <uart_getchar>
	return UDR0;
    2e6c:	80 91 c6 00 	lds	r24, 0x00C6
}
    2e70:	08 95       	ret

00002e72 <uart_getch>:

char uart_getch(void) {
	return (UCSR0A & _BV(RXC0));
    2e72:	80 91 c0 00 	lds	r24, 0x00C0
}
    2e76:	80 78       	andi	r24, 0x80	; 128
    2e78:	08 95       	ret

00002e7a <ROM_putstring>:

void ROM_putstring(const char *str, uint8_t nl) {
    2e7a:	ac 01       	movw	r20, r24
    2e7c:	20 e0       	ldi	r18, 0x00	; 0
    2e7e:	07 c0       	rjmp	.+14     	; 0x2e8e <ROM_putstring+0x14>

}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
    2e80:	80 91 c0 00 	lds	r24, 0x00C0
    2e84:	85 ff       	sbrs	r24, 5
    2e86:	fc cf       	rjmp	.-8      	; 0x2e80 <ROM_putstring+0x6>
  UDR0 = c;
    2e88:	30 93 c6 00 	sts	0x00C6, r19
}

void ROM_putstring(const char *str, uint8_t nl) {
    uint8_t i;

    for (i=0; pgm_read_byte(&str[i]); i++) {
    2e8c:	2f 5f       	subi	r18, 0xFF	; 255
    2e8e:	fa 01       	movw	r30, r20
    2e90:	e2 0f       	add	r30, r18
    2e92:	f1 1d       	adc	r31, r1
    2e94:	34 91       	lpm	r19, Z+
    2e96:	33 23       	and	r19, r19
    2e98:	99 f7       	brne	.-26     	; 0x2e80 <ROM_putstring+0x6>
        uart_putchar(pgm_read_byte(&str[i]));
  }
  if (nl) {
    2e9a:	66 23       	and	r22, r22
    2e9c:	71 f0       	breq	.+28     	; 0x2eba <ROM_putstring+0x40>

}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
    2e9e:	80 91 c0 00 	lds	r24, 0x00C0
    2ea2:	85 ff       	sbrs	r24, 5
    2ea4:	fc cf       	rjmp	.-8      	; 0x2e9e <ROM_putstring+0x24>
  UDR0 = c;
    2ea6:	8a e0       	ldi	r24, 0x0A	; 10
    2ea8:	80 93 c6 00 	sts	0x00C6, r24

}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
    2eac:	80 91 c0 00 	lds	r24, 0x00C0
    2eb0:	85 ff       	sbrs	r24, 5
    2eb2:	fc cf       	rjmp	.-8      	; 0x2eac <ROM_putstring+0x32>
  UDR0 = c;
    2eb4:	8d e0       	ldi	r24, 0x0D	; 13
    2eb6:	80 93 c6 00 	sts	0x00C6, r24
    2eba:	08 95       	ret

00002ebc <uart_puts>:
        uart_putchar('\n'); uart_putchar('\r');
  }
}

void uart_puts(const char* str)
{
    2ebc:	fc 01       	movw	r30, r24
    2ebe:	07 c0       	rjmp	.+14     	; 0x2ece <uart_puts+0x12>

}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
    2ec0:	80 91 c0 00 	lds	r24, 0x00C0
    2ec4:	85 ff       	sbrs	r24, 5
    2ec6:	fc cf       	rjmp	.-8      	; 0x2ec0 <uart_puts+0x4>
}

void uart_puts(const char* str)
{
    while(*str)
        uart_putc(*str++);
    2ec8:	31 96       	adiw	r30, 0x01	; 1
}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
  UDR0 = c;
    2eca:	90 93 c6 00 	sts	0x00C6, r25
  }
}

void uart_puts(const char* str)
{
    while(*str)
    2ece:	90 81       	ld	r25, Z
    2ed0:	99 23       	and	r25, r25
    2ed2:	b1 f7       	brne	.-20     	; 0x2ec0 <uart_puts+0x4>
        uart_putc(*str++);
}
    2ed4:	08 95       	ret

00002ed6 <uart_putc_hex>:


void uart_putc_hex(uint8_t b)
{
    2ed6:	28 2f       	mov	r18, r24
    /* upper nibble */
    if((b >> 4) < 0x0a)
    2ed8:	98 2f       	mov	r25, r24
    2eda:	92 95       	swap	r25
    2edc:	9f 70       	andi	r25, 0x0F	; 15
    2ede:	9a 30       	cpi	r25, 0x0A	; 10
    2ee0:	30 f4       	brcc	.+12     	; 0x2eee <uart_putc_hex+0x18>

}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
    2ee2:	80 91 c0 00 	lds	r24, 0x00C0
    2ee6:	85 ff       	sbrs	r24, 5
    2ee8:	fc cf       	rjmp	.-8      	; 0x2ee2 <uart_putc_hex+0xc>

void uart_putc_hex(uint8_t b)
{
    /* upper nibble */
    if((b >> 4) < 0x0a)
        uart_putc((b >> 4) + '0');
    2eea:	90 5d       	subi	r25, 0xD0	; 208
    2eec:	05 c0       	rjmp	.+10     	; 0x2ef8 <uart_putc_hex+0x22>

}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
    2eee:	80 91 c0 00 	lds	r24, 0x00C0
    2ef2:	85 ff       	sbrs	r24, 5
    2ef4:	fc cf       	rjmp	.-8      	; 0x2eee <uart_putc_hex+0x18>
{
    /* upper nibble */
    if((b >> 4) < 0x0a)
        uart_putc((b >> 4) + '0');
    else
        uart_putc((b >> 4) - 0x0a + 'a');
    2ef6:	99 5a       	subi	r25, 0xA9	; 169
}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
  UDR0 = c;
    2ef8:	90 93 c6 00 	sts	0x00C6, r25
        uart_putc((b >> 4) + '0');
    else
        uart_putc((b >> 4) - 0x0a + 'a');

    /* lower nibble */
    if((b & 0x0f) < 0x0a)
    2efc:	82 2f       	mov	r24, r18
    2efe:	90 e0       	ldi	r25, 0x00	; 0
    2f00:	8f 70       	andi	r24, 0x0F	; 15
    2f02:	90 70       	andi	r25, 0x00	; 0
    2f04:	0a 97       	sbiw	r24, 0x0a	; 10
    2f06:	3c f4       	brge	.+14     	; 0x2f16 <uart_putc_hex+0x40>

}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
    2f08:	80 91 c0 00 	lds	r24, 0x00C0
    2f0c:	85 ff       	sbrs	r24, 5
    2f0e:	fc cf       	rjmp	.-8      	; 0x2f08 <uart_putc_hex+0x32>
    else
        uart_putc((b >> 4) - 0x0a + 'a');

    /* lower nibble */
    if((b & 0x0f) < 0x0a)
        uart_putc((b & 0x0f) + '0');
    2f10:	2f 70       	andi	r18, 0x0F	; 15
    2f12:	20 5d       	subi	r18, 0xD0	; 208
    2f14:	06 c0       	rjmp	.+12     	; 0x2f22 <uart_putc_hex+0x4c>

}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
    2f16:	80 91 c0 00 	lds	r24, 0x00C0
    2f1a:	85 ff       	sbrs	r24, 5
    2f1c:	fc cf       	rjmp	.-8      	; 0x2f16 <uart_putc_hex+0x40>

    /* lower nibble */
    if((b & 0x0f) < 0x0a)
        uart_putc((b & 0x0f) + '0');
    else
        uart_putc((b & 0x0f) - 0x0a + 'a');
    2f1e:	2f 70       	andi	r18, 0x0F	; 15
    2f20:	29 5a       	subi	r18, 0xA9	; 169
}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
  UDR0 = c;
    2f22:	20 93 c6 00 	sts	0x00C6, r18
    2f26:	08 95       	ret

00002f28 <uart_putw_hex>:
    else
        uart_putc((b & 0x0f) - 0x0a + 'a');
}

void uart_putw_hex(uint16_t w)
{
    2f28:	1f 93       	push	r17
    2f2a:	18 2f       	mov	r17, r24
    uart_putc_hex((uint8_t) (w >> 8));
    2f2c:	89 2f       	mov	r24, r25
    2f2e:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <uart_putc_hex>
    uart_putc_hex((uint8_t) (w & 0xff));
    2f32:	81 2f       	mov	r24, r17
    2f34:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <uart_putc_hex>
}
    2f38:	1f 91       	pop	r17
    2f3a:	08 95       	ret

00002f3c <uart_putdw_hex>:

void uart_putdw_hex(uint32_t dw)
{
    2f3c:	ef 92       	push	r14
    2f3e:	ff 92       	push	r15
    2f40:	0f 93       	push	r16
    2f42:	1f 93       	push	r17
    2f44:	7b 01       	movw	r14, r22
    2f46:	8c 01       	movw	r16, r24
    uart_putw_hex((uint16_t) (dw >> 16));
    2f48:	c8 01       	movw	r24, r16
    2f4a:	aa 27       	eor	r26, r26
    2f4c:	bb 27       	eor	r27, r27
    2f4e:	0e 94 94 17 	call	0x2f28	; 0x2f28 <uart_putw_hex>
    uart_putw_hex((uint16_t) (dw & 0xffff));
    2f52:	c7 01       	movw	r24, r14
    2f54:	0e 94 94 17 	call	0x2f28	; 0x2f28 <uart_putw_hex>
}
    2f58:	1f 91       	pop	r17
    2f5a:	0f 91       	pop	r16
    2f5c:	ff 90       	pop	r15
    2f5e:	ef 90       	pop	r14
    2f60:	08 95       	ret

00002f62 <uart_putw_dec>:

void uart_putw_dec(uint16_t w)
{
    2f62:	0f 93       	push	r16
    2f64:	1f 93       	push	r17
    2f66:	cf 93       	push	r28
    2f68:	df 93       	push	r29
    2f6a:	8c 01       	movw	r16, r24
    2f6c:	e0 e1       	ldi	r30, 0x10	; 16
    2f6e:	f7 e2       	ldi	r31, 0x27	; 39
    2f70:	40 e0       	ldi	r20, 0x00	; 0
    2f72:	c0 e0       	ldi	r28, 0x00	; 0
    2f74:	d0 e0       	ldi	r29, 0x00	; 0
    uint16_t num = 10000;
    uint8_t started = 0;

    while(num > 0)
    {
        uint8_t b = w / num;
    2f76:	c8 01       	movw	r24, r16
    2f78:	bf 01       	movw	r22, r30
    2f7a:	0e 94 34 1b 	call	0x3668	; 0x3668 <__udivmodhi4>
    2f7e:	26 2f       	mov	r18, r22
        if(b > 0 || started || num == 1)
    2f80:	66 23       	and	r22, r22
    2f82:	29 f4       	brne	.+10     	; 0x2f8e <uart_putw_dec+0x2c>
    2f84:	44 23       	and	r20, r20
    2f86:	19 f4       	brne	.+6      	; 0x2f8e <uart_putw_dec+0x2c>
    2f88:	e1 30       	cpi	r30, 0x01	; 1
    2f8a:	f1 05       	cpc	r31, r1
    2f8c:	49 f4       	brne	.+18     	; 0x2fa0 <uart_putw_dec+0x3e>

}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
    2f8e:	80 91 c0 00 	lds	r24, 0x00C0
    2f92:	85 ff       	sbrs	r24, 5
    2f94:	fc cf       	rjmp	.-8      	; 0x2f8e <uart_putw_dec+0x2c>
    while(num > 0)
    {
        uint8_t b = w / num;
        if(b > 0 || started || num == 1)
        {
            uart_putc('0' + b);
    2f96:	20 5d       	subi	r18, 0xD0	; 208
}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
  UDR0 = c;
    2f98:	20 93 c6 00 	sts	0x00C6, r18
    2f9c:	20 53       	subi	r18, 0x30	; 48
    2f9e:	41 e0       	ldi	r20, 0x01	; 1
            uart_putc('0' + b);
            started = 1;
        }
        w -= b * num;

        num /= 10;
    2fa0:	cf 01       	movw	r24, r30
    2fa2:	6a e0       	ldi	r22, 0x0A	; 10
    2fa4:	70 e0       	ldi	r23, 0x00	; 0
    2fa6:	0e 94 34 1b 	call	0x3668	; 0x3668 <__udivmodhi4>
    2faa:	21 96       	adiw	r28, 0x01	; 1
void uart_putw_dec(uint16_t w)
{
    uint16_t num = 10000;
    uint8_t started = 0;

    while(num > 0)
    2fac:	c5 30       	cpi	r28, 0x05	; 5
    2fae:	d1 05       	cpc	r29, r1
    2fb0:	71 f0       	breq	.+28     	; 0x2fce <uart_putw_dec+0x6c>
        if(b > 0 || started || num == 1)
        {
            uart_putc('0' + b);
            started = 1;
        }
        w -= b * num;
    2fb2:	82 2f       	mov	r24, r18
    2fb4:	90 e0       	ldi	r25, 0x00	; 0
    2fb6:	9c 01       	movw	r18, r24
    2fb8:	2e 9f       	mul	r18, r30
    2fba:	c0 01       	movw	r24, r0
    2fbc:	2f 9f       	mul	r18, r31
    2fbe:	90 0d       	add	r25, r0
    2fc0:	3e 9f       	mul	r19, r30
    2fc2:	90 0d       	add	r25, r0
    2fc4:	11 24       	eor	r1, r1
    2fc6:	08 1b       	sub	r16, r24
    2fc8:	19 0b       	sbc	r17, r25
    2fca:	fb 01       	movw	r30, r22
    2fcc:	d4 cf       	rjmp	.-88     	; 0x2f76 <uart_putw_dec+0x14>

        num /= 10;
    }
}
    2fce:	df 91       	pop	r29
    2fd0:	cf 91       	pop	r28
    2fd2:	1f 91       	pop	r17
    2fd4:	0f 91       	pop	r16
    2fd6:	08 95       	ret

00002fd8 <uart_putdw_dec>:

void uart_putdw_dec(uint32_t dw)
{
    2fd8:	4f 92       	push	r4
    2fda:	5f 92       	push	r5
    2fdc:	6f 92       	push	r6
    2fde:	7f 92       	push	r7
    2fe0:	8f 92       	push	r8
    2fe2:	9f 92       	push	r9
    2fe4:	af 92       	push	r10
    2fe6:	bf 92       	push	r11
    2fe8:	cf 92       	push	r12
    2fea:	df 92       	push	r13
    2fec:	ef 92       	push	r14
    2fee:	ff 92       	push	r15
    2ff0:	0f 93       	push	r16
    2ff2:	1f 93       	push	r17
    2ff4:	cf 93       	push	r28
    2ff6:	df 93       	push	r29
    2ff8:	4b 01       	movw	r8, r22
    2ffa:	5c 01       	movw	r10, r24
    2ffc:	e1 2c       	mov	r14, r1
    2ffe:	9a ec       	ldi	r25, 0xCA	; 202
    3000:	f9 2e       	mov	r15, r25
    3002:	9a e9       	ldi	r25, 0x9A	; 154
    3004:	09 2f       	mov	r16, r25
    3006:	9b e3       	ldi	r25, 0x3B	; 59
    3008:	19 2f       	mov	r17, r25
    300a:	44 24       	eor	r4, r4
    300c:	c0 e0       	ldi	r28, 0x00	; 0
    300e:	d0 e0       	ldi	r29, 0x00	; 0
    uint32_t num = 1000000000;
    uint8_t started = 0;

    while(num > 0)
    {
        uint8_t b = dw / num;
    3010:	c5 01       	movw	r24, r10
    3012:	b4 01       	movw	r22, r8
    3014:	a8 01       	movw	r20, r16
    3016:	97 01       	movw	r18, r14
    3018:	0e 94 5b 1b 	call	0x36b6	; 0x36b6 <__udivmodsi4>
    301c:	d2 2e       	mov	r13, r18
        if(b > 0 || started || num == 1)
    301e:	22 23       	and	r18, r18
    3020:	41 f4       	brne	.+16     	; 0x3032 <uart_putdw_dec+0x5a>
    3022:	44 20       	and	r4, r4
    3024:	31 f4       	brne	.+12     	; 0x3032 <uart_putdw_dec+0x5a>
    3026:	81 e0       	ldi	r24, 0x01	; 1
    3028:	e8 16       	cp	r14, r24
    302a:	f1 04       	cpc	r15, r1
    302c:	01 05       	cpc	r16, r1
    302e:	11 05       	cpc	r17, r1
    3030:	61 f4       	brne	.+24     	; 0x304a <uart_putdw_dec+0x72>

}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
    3032:	80 91 c0 00 	lds	r24, 0x00C0
    3036:	85 ff       	sbrs	r24, 5
    3038:	fc cf       	rjmp	.-8      	; 0x3032 <uart_putdw_dec+0x5a>
    while(num > 0)
    {
        uint8_t b = dw / num;
        if(b > 0 || started || num == 1)
        {
            uart_putc('0' + b);
    303a:	80 e3       	ldi	r24, 0x30	; 48
    303c:	d8 0e       	add	r13, r24
}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
  UDR0 = c;
    303e:	d0 92 c6 00 	sts	0x00C6, r13
    3042:	80 ed       	ldi	r24, 0xD0	; 208
    3044:	d8 0e       	add	r13, r24
    3046:	44 24       	eor	r4, r4
    3048:	43 94       	inc	r4
            uart_putc('0' + b);
            started = 1;
        }
        dw -= b * num;

        num /= 10;
    304a:	c8 01       	movw	r24, r16
    304c:	b7 01       	movw	r22, r14
    304e:	2a e0       	ldi	r18, 0x0A	; 10
    3050:	30 e0       	ldi	r19, 0x00	; 0
    3052:	40 e0       	ldi	r20, 0x00	; 0
    3054:	50 e0       	ldi	r21, 0x00	; 0
    3056:	0e 94 5b 1b 	call	0x36b6	; 0x36b6 <__udivmodsi4>
    305a:	c2 2e       	mov	r12, r18
    305c:	73 2e       	mov	r7, r19
    305e:	64 2e       	mov	r6, r20
    3060:	55 2e       	mov	r5, r21
    3062:	21 96       	adiw	r28, 0x01	; 1
void uart_putdw_dec(uint32_t dw)
{
    uint32_t num = 1000000000;
    uint8_t started = 0;

    while(num > 0)
    3064:	ca 30       	cpi	r28, 0x0A	; 10
    3066:	d1 05       	cpc	r29, r1
    3068:	a9 f0       	breq	.+42     	; 0x3094 <uart_putdw_dec+0xbc>
        if(b > 0 || started || num == 1)
        {
            uart_putc('0' + b);
            started = 1;
        }
        dw -= b * num;
    306a:	6d 2d       	mov	r22, r13
    306c:	70 e0       	ldi	r23, 0x00	; 0
    306e:	80 e0       	ldi	r24, 0x00	; 0
    3070:	90 e0       	ldi	r25, 0x00	; 0
    3072:	a8 01       	movw	r20, r16
    3074:	97 01       	movw	r18, r14
    3076:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <__mulsi3>
    307a:	86 1a       	sub	r8, r22
    307c:	97 0a       	sbc	r9, r23
    307e:	a8 0a       	sbc	r10, r24
    3080:	b9 0a       	sbc	r11, r25
    3082:	2c 2d       	mov	r18, r12
    3084:	37 2d       	mov	r19, r7
    3086:	46 2d       	mov	r20, r6
    3088:	55 2d       	mov	r21, r5
    308a:	c9 01       	movw	r24, r18
    308c:	da 01       	movw	r26, r20
    308e:	7c 01       	movw	r14, r24
    3090:	8d 01       	movw	r16, r26
    3092:	be cf       	rjmp	.-132    	; 0x3010 <uart_putdw_dec+0x38>

        num /= 10;
    }
}
    3094:	df 91       	pop	r29
    3096:	cf 91       	pop	r28
    3098:	1f 91       	pop	r17
    309a:	0f 91       	pop	r16
    309c:	ff 90       	pop	r15
    309e:	ef 90       	pop	r14
    30a0:	df 90       	pop	r13
    30a2:	cf 90       	pop	r12
    30a4:	bf 90       	pop	r11
    30a6:	af 90       	pop	r10
    30a8:	9f 90       	pop	r9
    30aa:	8f 90       	pop	r8
    30ac:	7f 90       	pop	r7
    30ae:	6f 90       	pop	r6
    30b0:	5f 90       	pop	r5
    30b2:	4f 90       	pop	r4
    30b4:	08 95       	ret

000030b6 <sprintf_P>:
    30b6:	ae e0       	ldi	r26, 0x0E	; 14
    30b8:	b0 e0       	ldi	r27, 0x00	; 0
    30ba:	e1 e6       	ldi	r30, 0x61	; 97
    30bc:	f8 e1       	ldi	r31, 0x18	; 24
    30be:	0c 94 a6 1b 	jmp	0x374c	; 0x374c <__prologue_saves__+0x1c>
    30c2:	0d 89       	ldd	r16, Y+21	; 0x15
    30c4:	1e 89       	ldd	r17, Y+22	; 0x16
    30c6:	8e e0       	ldi	r24, 0x0E	; 14
    30c8:	8c 83       	std	Y+4, r24	; 0x04
    30ca:	1a 83       	std	Y+2, r17	; 0x02
    30cc:	09 83       	std	Y+1, r16	; 0x01
    30ce:	8f ef       	ldi	r24, 0xFF	; 255
    30d0:	9f e7       	ldi	r25, 0x7F	; 127
    30d2:	9e 83       	std	Y+6, r25	; 0x06
    30d4:	8d 83       	std	Y+5, r24	; 0x05
    30d6:	9e 01       	movw	r18, r28
    30d8:	27 5e       	subi	r18, 0xE7	; 231
    30da:	3f 4f       	sbci	r19, 0xFF	; 255
    30dc:	ce 01       	movw	r24, r28
    30de:	01 96       	adiw	r24, 0x01	; 1
    30e0:	6f 89       	ldd	r22, Y+23	; 0x17
    30e2:	78 8d       	ldd	r23, Y+24	; 0x18
    30e4:	a9 01       	movw	r20, r18
    30e6:	0e 94 7f 18 	call	0x30fe	; 0x30fe <vfprintf>
    30ea:	2f 81       	ldd	r18, Y+7	; 0x07
    30ec:	38 85       	ldd	r19, Y+8	; 0x08
    30ee:	02 0f       	add	r16, r18
    30f0:	13 1f       	adc	r17, r19
    30f2:	f8 01       	movw	r30, r16
    30f4:	10 82       	st	Z, r1
    30f6:	2e 96       	adiw	r28, 0x0e	; 14
    30f8:	e4 e0       	ldi	r30, 0x04	; 4
    30fa:	0c 94 c2 1b 	jmp	0x3784	; 0x3784 <__epilogue_restores__+0x1c>

000030fe <vfprintf>:
    30fe:	ab e0       	ldi	r26, 0x0B	; 11
    3100:	b0 e0       	ldi	r27, 0x00	; 0
    3102:	e5 e8       	ldi	r30, 0x85	; 133
    3104:	f8 e1       	ldi	r31, 0x18	; 24
    3106:	0c 94 98 1b 	jmp	0x3730	; 0x3730 <__prologue_saves__>
    310a:	3c 01       	movw	r6, r24
    310c:	2b 01       	movw	r4, r22
    310e:	5a 01       	movw	r10, r20
    3110:	fc 01       	movw	r30, r24
    3112:	17 82       	std	Z+7, r1	; 0x07
    3114:	16 82       	std	Z+6, r1	; 0x06
    3116:	83 81       	ldd	r24, Z+3	; 0x03
    3118:	81 fd       	sbrc	r24, 1
    311a:	03 c0       	rjmp	.+6      	; 0x3122 <vfprintf+0x24>
    311c:	6f ef       	ldi	r22, 0xFF	; 255
    311e:	7f ef       	ldi	r23, 0xFF	; 255
    3120:	c6 c1       	rjmp	.+908    	; 0x34ae <vfprintf+0x3b0>
    3122:	9a e0       	ldi	r25, 0x0A	; 10
    3124:	89 2e       	mov	r8, r25
    3126:	1e 01       	movw	r2, r28
    3128:	08 94       	sec
    312a:	21 1c       	adc	r2, r1
    312c:	31 1c       	adc	r3, r1
    312e:	f3 01       	movw	r30, r6
    3130:	23 81       	ldd	r18, Z+3	; 0x03
    3132:	f2 01       	movw	r30, r4
    3134:	23 fd       	sbrc	r18, 3
    3136:	85 91       	lpm	r24, Z+
    3138:	23 ff       	sbrs	r18, 3
    313a:	81 91       	ld	r24, Z+
    313c:	2f 01       	movw	r4, r30
    313e:	88 23       	and	r24, r24
    3140:	09 f4       	brne	.+2      	; 0x3144 <vfprintf+0x46>
    3142:	b2 c1       	rjmp	.+868    	; 0x34a8 <vfprintf+0x3aa>
    3144:	85 32       	cpi	r24, 0x25	; 37
    3146:	39 f4       	brne	.+14     	; 0x3156 <vfprintf+0x58>
    3148:	23 fd       	sbrc	r18, 3
    314a:	85 91       	lpm	r24, Z+
    314c:	23 ff       	sbrs	r18, 3
    314e:	81 91       	ld	r24, Z+
    3150:	2f 01       	movw	r4, r30
    3152:	85 32       	cpi	r24, 0x25	; 37
    3154:	29 f4       	brne	.+10     	; 0x3160 <vfprintf+0x62>
    3156:	90 e0       	ldi	r25, 0x00	; 0
    3158:	b3 01       	movw	r22, r6
    315a:	0e 94 72 1a 	call	0x34e4	; 0x34e4 <fputc>
    315e:	e7 cf       	rjmp	.-50     	; 0x312e <vfprintf+0x30>
    3160:	98 2f       	mov	r25, r24
    3162:	ff 24       	eor	r15, r15
    3164:	ee 24       	eor	r14, r14
    3166:	99 24       	eor	r9, r9
    3168:	ff e1       	ldi	r31, 0x1F	; 31
    316a:	ff 15       	cp	r31, r15
    316c:	d0 f0       	brcs	.+52     	; 0x31a2 <vfprintf+0xa4>
    316e:	9b 32       	cpi	r25, 0x2B	; 43
    3170:	69 f0       	breq	.+26     	; 0x318c <vfprintf+0x8e>
    3172:	9c 32       	cpi	r25, 0x2C	; 44
    3174:	28 f4       	brcc	.+10     	; 0x3180 <vfprintf+0x82>
    3176:	90 32       	cpi	r25, 0x20	; 32
    3178:	59 f0       	breq	.+22     	; 0x3190 <vfprintf+0x92>
    317a:	93 32       	cpi	r25, 0x23	; 35
    317c:	91 f4       	brne	.+36     	; 0x31a2 <vfprintf+0xa4>
    317e:	0e c0       	rjmp	.+28     	; 0x319c <vfprintf+0x9e>
    3180:	9d 32       	cpi	r25, 0x2D	; 45
    3182:	49 f0       	breq	.+18     	; 0x3196 <vfprintf+0x98>
    3184:	90 33       	cpi	r25, 0x30	; 48
    3186:	69 f4       	brne	.+26     	; 0x31a2 <vfprintf+0xa4>
    3188:	41 e0       	ldi	r20, 0x01	; 1
    318a:	24 c0       	rjmp	.+72     	; 0x31d4 <vfprintf+0xd6>
    318c:	52 e0       	ldi	r21, 0x02	; 2
    318e:	f5 2a       	or	r15, r21
    3190:	84 e0       	ldi	r24, 0x04	; 4
    3192:	f8 2a       	or	r15, r24
    3194:	28 c0       	rjmp	.+80     	; 0x31e6 <vfprintf+0xe8>
    3196:	98 e0       	ldi	r25, 0x08	; 8
    3198:	f9 2a       	or	r15, r25
    319a:	25 c0       	rjmp	.+74     	; 0x31e6 <vfprintf+0xe8>
    319c:	e0 e1       	ldi	r30, 0x10	; 16
    319e:	fe 2a       	or	r15, r30
    31a0:	22 c0       	rjmp	.+68     	; 0x31e6 <vfprintf+0xe8>
    31a2:	f7 fc       	sbrc	r15, 7
    31a4:	29 c0       	rjmp	.+82     	; 0x31f8 <vfprintf+0xfa>
    31a6:	89 2f       	mov	r24, r25
    31a8:	80 53       	subi	r24, 0x30	; 48
    31aa:	8a 30       	cpi	r24, 0x0A	; 10
    31ac:	70 f4       	brcc	.+28     	; 0x31ca <vfprintf+0xcc>
    31ae:	f6 fe       	sbrs	r15, 6
    31b0:	05 c0       	rjmp	.+10     	; 0x31bc <vfprintf+0xbe>
    31b2:	98 9c       	mul	r9, r8
    31b4:	90 2c       	mov	r9, r0
    31b6:	11 24       	eor	r1, r1
    31b8:	98 0e       	add	r9, r24
    31ba:	15 c0       	rjmp	.+42     	; 0x31e6 <vfprintf+0xe8>
    31bc:	e8 9c       	mul	r14, r8
    31be:	e0 2c       	mov	r14, r0
    31c0:	11 24       	eor	r1, r1
    31c2:	e8 0e       	add	r14, r24
    31c4:	f0 e2       	ldi	r31, 0x20	; 32
    31c6:	ff 2a       	or	r15, r31
    31c8:	0e c0       	rjmp	.+28     	; 0x31e6 <vfprintf+0xe8>
    31ca:	9e 32       	cpi	r25, 0x2E	; 46
    31cc:	29 f4       	brne	.+10     	; 0x31d8 <vfprintf+0xda>
    31ce:	f6 fc       	sbrc	r15, 6
    31d0:	6b c1       	rjmp	.+726    	; 0x34a8 <vfprintf+0x3aa>
    31d2:	40 e4       	ldi	r20, 0x40	; 64
    31d4:	f4 2a       	or	r15, r20
    31d6:	07 c0       	rjmp	.+14     	; 0x31e6 <vfprintf+0xe8>
    31d8:	9c 36       	cpi	r25, 0x6C	; 108
    31da:	19 f4       	brne	.+6      	; 0x31e2 <vfprintf+0xe4>
    31dc:	50 e8       	ldi	r21, 0x80	; 128
    31de:	f5 2a       	or	r15, r21
    31e0:	02 c0       	rjmp	.+4      	; 0x31e6 <vfprintf+0xe8>
    31e2:	98 36       	cpi	r25, 0x68	; 104
    31e4:	49 f4       	brne	.+18     	; 0x31f8 <vfprintf+0xfa>
    31e6:	f2 01       	movw	r30, r4
    31e8:	23 fd       	sbrc	r18, 3
    31ea:	95 91       	lpm	r25, Z+
    31ec:	23 ff       	sbrs	r18, 3
    31ee:	91 91       	ld	r25, Z+
    31f0:	2f 01       	movw	r4, r30
    31f2:	99 23       	and	r25, r25
    31f4:	09 f0       	breq	.+2      	; 0x31f8 <vfprintf+0xfa>
    31f6:	b8 cf       	rjmp	.-144    	; 0x3168 <vfprintf+0x6a>
    31f8:	89 2f       	mov	r24, r25
    31fa:	85 54       	subi	r24, 0x45	; 69
    31fc:	83 30       	cpi	r24, 0x03	; 3
    31fe:	18 f0       	brcs	.+6      	; 0x3206 <vfprintf+0x108>
    3200:	80 52       	subi	r24, 0x20	; 32
    3202:	83 30       	cpi	r24, 0x03	; 3
    3204:	38 f4       	brcc	.+14     	; 0x3214 <vfprintf+0x116>
    3206:	44 e0       	ldi	r20, 0x04	; 4
    3208:	50 e0       	ldi	r21, 0x00	; 0
    320a:	a4 0e       	add	r10, r20
    320c:	b5 1e       	adc	r11, r21
    320e:	5f e3       	ldi	r21, 0x3F	; 63
    3210:	59 83       	std	Y+1, r21	; 0x01
    3212:	0f c0       	rjmp	.+30     	; 0x3232 <vfprintf+0x134>
    3214:	93 36       	cpi	r25, 0x63	; 99
    3216:	31 f0       	breq	.+12     	; 0x3224 <vfprintf+0x126>
    3218:	93 37       	cpi	r25, 0x73	; 115
    321a:	79 f0       	breq	.+30     	; 0x323a <vfprintf+0x13c>
    321c:	93 35       	cpi	r25, 0x53	; 83
    321e:	09 f0       	breq	.+2      	; 0x3222 <vfprintf+0x124>
    3220:	56 c0       	rjmp	.+172    	; 0x32ce <vfprintf+0x1d0>
    3222:	20 c0       	rjmp	.+64     	; 0x3264 <vfprintf+0x166>
    3224:	f5 01       	movw	r30, r10
    3226:	80 81       	ld	r24, Z
    3228:	89 83       	std	Y+1, r24	; 0x01
    322a:	42 e0       	ldi	r20, 0x02	; 2
    322c:	50 e0       	ldi	r21, 0x00	; 0
    322e:	a4 0e       	add	r10, r20
    3230:	b5 1e       	adc	r11, r21
    3232:	61 01       	movw	r12, r2
    3234:	01 e0       	ldi	r16, 0x01	; 1
    3236:	10 e0       	ldi	r17, 0x00	; 0
    3238:	12 c0       	rjmp	.+36     	; 0x325e <vfprintf+0x160>
    323a:	f5 01       	movw	r30, r10
    323c:	c0 80       	ld	r12, Z
    323e:	d1 80       	ldd	r13, Z+1	; 0x01
    3240:	f6 fc       	sbrc	r15, 6
    3242:	03 c0       	rjmp	.+6      	; 0x324a <vfprintf+0x14c>
    3244:	6f ef       	ldi	r22, 0xFF	; 255
    3246:	7f ef       	ldi	r23, 0xFF	; 255
    3248:	02 c0       	rjmp	.+4      	; 0x324e <vfprintf+0x150>
    324a:	69 2d       	mov	r22, r9
    324c:	70 e0       	ldi	r23, 0x00	; 0
    324e:	42 e0       	ldi	r20, 0x02	; 2
    3250:	50 e0       	ldi	r21, 0x00	; 0
    3252:	a4 0e       	add	r10, r20
    3254:	b5 1e       	adc	r11, r21
    3256:	c6 01       	movw	r24, r12
    3258:	0e 94 67 1a 	call	0x34ce	; 0x34ce <strnlen>
    325c:	8c 01       	movw	r16, r24
    325e:	5f e7       	ldi	r21, 0x7F	; 127
    3260:	f5 22       	and	r15, r21
    3262:	14 c0       	rjmp	.+40     	; 0x328c <vfprintf+0x18e>
    3264:	f5 01       	movw	r30, r10
    3266:	c0 80       	ld	r12, Z
    3268:	d1 80       	ldd	r13, Z+1	; 0x01
    326a:	f6 fc       	sbrc	r15, 6
    326c:	03 c0       	rjmp	.+6      	; 0x3274 <vfprintf+0x176>
    326e:	6f ef       	ldi	r22, 0xFF	; 255
    3270:	7f ef       	ldi	r23, 0xFF	; 255
    3272:	02 c0       	rjmp	.+4      	; 0x3278 <vfprintf+0x17a>
    3274:	69 2d       	mov	r22, r9
    3276:	70 e0       	ldi	r23, 0x00	; 0
    3278:	42 e0       	ldi	r20, 0x02	; 2
    327a:	50 e0       	ldi	r21, 0x00	; 0
    327c:	a4 0e       	add	r10, r20
    327e:	b5 1e       	adc	r11, r21
    3280:	c6 01       	movw	r24, r12
    3282:	0e 94 5c 1a 	call	0x34b8	; 0x34b8 <strnlen_P>
    3286:	8c 01       	movw	r16, r24
    3288:	50 e8       	ldi	r21, 0x80	; 128
    328a:	f5 2a       	or	r15, r21
    328c:	f3 fe       	sbrs	r15, 3
    328e:	07 c0       	rjmp	.+14     	; 0x329e <vfprintf+0x1a0>
    3290:	1a c0       	rjmp	.+52     	; 0x32c6 <vfprintf+0x1c8>
    3292:	80 e2       	ldi	r24, 0x20	; 32
    3294:	90 e0       	ldi	r25, 0x00	; 0
    3296:	b3 01       	movw	r22, r6
    3298:	0e 94 72 1a 	call	0x34e4	; 0x34e4 <fputc>
    329c:	ea 94       	dec	r14
    329e:	8e 2d       	mov	r24, r14
    32a0:	90 e0       	ldi	r25, 0x00	; 0
    32a2:	08 17       	cp	r16, r24
    32a4:	19 07       	cpc	r17, r25
    32a6:	a8 f3       	brcs	.-22     	; 0x3292 <vfprintf+0x194>
    32a8:	0e c0       	rjmp	.+28     	; 0x32c6 <vfprintf+0x1c8>
    32aa:	f6 01       	movw	r30, r12
    32ac:	f7 fc       	sbrc	r15, 7
    32ae:	85 91       	lpm	r24, Z+
    32b0:	f7 fe       	sbrs	r15, 7
    32b2:	81 91       	ld	r24, Z+
    32b4:	6f 01       	movw	r12, r30
    32b6:	90 e0       	ldi	r25, 0x00	; 0
    32b8:	b3 01       	movw	r22, r6
    32ba:	0e 94 72 1a 	call	0x34e4	; 0x34e4 <fputc>
    32be:	e1 10       	cpse	r14, r1
    32c0:	ea 94       	dec	r14
    32c2:	01 50       	subi	r16, 0x01	; 1
    32c4:	10 40       	sbci	r17, 0x00	; 0
    32c6:	01 15       	cp	r16, r1
    32c8:	11 05       	cpc	r17, r1
    32ca:	79 f7       	brne	.-34     	; 0x32aa <vfprintf+0x1ac>
    32cc:	ea c0       	rjmp	.+468    	; 0x34a2 <vfprintf+0x3a4>
    32ce:	94 36       	cpi	r25, 0x64	; 100
    32d0:	11 f0       	breq	.+4      	; 0x32d6 <vfprintf+0x1d8>
    32d2:	99 36       	cpi	r25, 0x69	; 105
    32d4:	69 f5       	brne	.+90     	; 0x3330 <vfprintf+0x232>
    32d6:	f7 fe       	sbrs	r15, 7
    32d8:	08 c0       	rjmp	.+16     	; 0x32ea <vfprintf+0x1ec>
    32da:	f5 01       	movw	r30, r10
    32dc:	20 81       	ld	r18, Z
    32de:	31 81       	ldd	r19, Z+1	; 0x01
    32e0:	42 81       	ldd	r20, Z+2	; 0x02
    32e2:	53 81       	ldd	r21, Z+3	; 0x03
    32e4:	84 e0       	ldi	r24, 0x04	; 4
    32e6:	90 e0       	ldi	r25, 0x00	; 0
    32e8:	0a c0       	rjmp	.+20     	; 0x32fe <vfprintf+0x200>
    32ea:	f5 01       	movw	r30, r10
    32ec:	80 81       	ld	r24, Z
    32ee:	91 81       	ldd	r25, Z+1	; 0x01
    32f0:	9c 01       	movw	r18, r24
    32f2:	44 27       	eor	r20, r20
    32f4:	37 fd       	sbrc	r19, 7
    32f6:	40 95       	com	r20
    32f8:	54 2f       	mov	r21, r20
    32fa:	82 e0       	ldi	r24, 0x02	; 2
    32fc:	90 e0       	ldi	r25, 0x00	; 0
    32fe:	a8 0e       	add	r10, r24
    3300:	b9 1e       	adc	r11, r25
    3302:	9f e6       	ldi	r25, 0x6F	; 111
    3304:	f9 22       	and	r15, r25
    3306:	57 ff       	sbrs	r21, 7
    3308:	09 c0       	rjmp	.+18     	; 0x331c <vfprintf+0x21e>
    330a:	50 95       	com	r21
    330c:	40 95       	com	r20
    330e:	30 95       	com	r19
    3310:	21 95       	neg	r18
    3312:	3f 4f       	sbci	r19, 0xFF	; 255
    3314:	4f 4f       	sbci	r20, 0xFF	; 255
    3316:	5f 4f       	sbci	r21, 0xFF	; 255
    3318:	e0 e8       	ldi	r30, 0x80	; 128
    331a:	fe 2a       	or	r15, r30
    331c:	ca 01       	movw	r24, r20
    331e:	b9 01       	movw	r22, r18
    3320:	a1 01       	movw	r20, r2
    3322:	2a e0       	ldi	r18, 0x0A	; 10
    3324:	30 e0       	ldi	r19, 0x00	; 0
    3326:	0e 94 9e 1a 	call	0x353c	; 0x353c <__ultoa_invert>
    332a:	d8 2e       	mov	r13, r24
    332c:	d2 18       	sub	r13, r2
    332e:	40 c0       	rjmp	.+128    	; 0x33b0 <vfprintf+0x2b2>
    3330:	95 37       	cpi	r25, 0x75	; 117
    3332:	29 f4       	brne	.+10     	; 0x333e <vfprintf+0x240>
    3334:	1f 2d       	mov	r17, r15
    3336:	1f 7e       	andi	r17, 0xEF	; 239
    3338:	2a e0       	ldi	r18, 0x0A	; 10
    333a:	30 e0       	ldi	r19, 0x00	; 0
    333c:	1d c0       	rjmp	.+58     	; 0x3378 <vfprintf+0x27a>
    333e:	1f 2d       	mov	r17, r15
    3340:	19 7f       	andi	r17, 0xF9	; 249
    3342:	9f 36       	cpi	r25, 0x6F	; 111
    3344:	61 f0       	breq	.+24     	; 0x335e <vfprintf+0x260>
    3346:	90 37       	cpi	r25, 0x70	; 112
    3348:	20 f4       	brcc	.+8      	; 0x3352 <vfprintf+0x254>
    334a:	98 35       	cpi	r25, 0x58	; 88
    334c:	09 f0       	breq	.+2      	; 0x3350 <vfprintf+0x252>
    334e:	ac c0       	rjmp	.+344    	; 0x34a8 <vfprintf+0x3aa>
    3350:	0f c0       	rjmp	.+30     	; 0x3370 <vfprintf+0x272>
    3352:	90 37       	cpi	r25, 0x70	; 112
    3354:	39 f0       	breq	.+14     	; 0x3364 <vfprintf+0x266>
    3356:	98 37       	cpi	r25, 0x78	; 120
    3358:	09 f0       	breq	.+2      	; 0x335c <vfprintf+0x25e>
    335a:	a6 c0       	rjmp	.+332    	; 0x34a8 <vfprintf+0x3aa>
    335c:	04 c0       	rjmp	.+8      	; 0x3366 <vfprintf+0x268>
    335e:	28 e0       	ldi	r18, 0x08	; 8
    3360:	30 e0       	ldi	r19, 0x00	; 0
    3362:	0a c0       	rjmp	.+20     	; 0x3378 <vfprintf+0x27a>
    3364:	10 61       	ori	r17, 0x10	; 16
    3366:	14 fd       	sbrc	r17, 4
    3368:	14 60       	ori	r17, 0x04	; 4
    336a:	20 e1       	ldi	r18, 0x10	; 16
    336c:	30 e0       	ldi	r19, 0x00	; 0
    336e:	04 c0       	rjmp	.+8      	; 0x3378 <vfprintf+0x27a>
    3370:	14 fd       	sbrc	r17, 4
    3372:	16 60       	ori	r17, 0x06	; 6
    3374:	20 e1       	ldi	r18, 0x10	; 16
    3376:	32 e0       	ldi	r19, 0x02	; 2
    3378:	17 ff       	sbrs	r17, 7
    337a:	08 c0       	rjmp	.+16     	; 0x338c <vfprintf+0x28e>
    337c:	f5 01       	movw	r30, r10
    337e:	60 81       	ld	r22, Z
    3380:	71 81       	ldd	r23, Z+1	; 0x01
    3382:	82 81       	ldd	r24, Z+2	; 0x02
    3384:	93 81       	ldd	r25, Z+3	; 0x03
    3386:	44 e0       	ldi	r20, 0x04	; 4
    3388:	50 e0       	ldi	r21, 0x00	; 0
    338a:	08 c0       	rjmp	.+16     	; 0x339c <vfprintf+0x29e>
    338c:	f5 01       	movw	r30, r10
    338e:	80 81       	ld	r24, Z
    3390:	91 81       	ldd	r25, Z+1	; 0x01
    3392:	bc 01       	movw	r22, r24
    3394:	80 e0       	ldi	r24, 0x00	; 0
    3396:	90 e0       	ldi	r25, 0x00	; 0
    3398:	42 e0       	ldi	r20, 0x02	; 2
    339a:	50 e0       	ldi	r21, 0x00	; 0
    339c:	a4 0e       	add	r10, r20
    339e:	b5 1e       	adc	r11, r21
    33a0:	a1 01       	movw	r20, r2
    33a2:	0e 94 9e 1a 	call	0x353c	; 0x353c <__ultoa_invert>
    33a6:	d8 2e       	mov	r13, r24
    33a8:	d2 18       	sub	r13, r2
    33aa:	8f e7       	ldi	r24, 0x7F	; 127
    33ac:	f8 2e       	mov	r15, r24
    33ae:	f1 22       	and	r15, r17
    33b0:	f6 fe       	sbrs	r15, 6
    33b2:	0b c0       	rjmp	.+22     	; 0x33ca <vfprintf+0x2cc>
    33b4:	5e ef       	ldi	r21, 0xFE	; 254
    33b6:	f5 22       	and	r15, r21
    33b8:	d9 14       	cp	r13, r9
    33ba:	38 f4       	brcc	.+14     	; 0x33ca <vfprintf+0x2cc>
    33bc:	f4 fe       	sbrs	r15, 4
    33be:	07 c0       	rjmp	.+14     	; 0x33ce <vfprintf+0x2d0>
    33c0:	f2 fc       	sbrc	r15, 2
    33c2:	05 c0       	rjmp	.+10     	; 0x33ce <vfprintf+0x2d0>
    33c4:	8f ee       	ldi	r24, 0xEF	; 239
    33c6:	f8 22       	and	r15, r24
    33c8:	02 c0       	rjmp	.+4      	; 0x33ce <vfprintf+0x2d0>
    33ca:	1d 2d       	mov	r17, r13
    33cc:	01 c0       	rjmp	.+2      	; 0x33d0 <vfprintf+0x2d2>
    33ce:	19 2d       	mov	r17, r9
    33d0:	f4 fe       	sbrs	r15, 4
    33d2:	0d c0       	rjmp	.+26     	; 0x33ee <vfprintf+0x2f0>
    33d4:	fe 01       	movw	r30, r28
    33d6:	ed 0d       	add	r30, r13
    33d8:	f1 1d       	adc	r31, r1
    33da:	80 81       	ld	r24, Z
    33dc:	80 33       	cpi	r24, 0x30	; 48
    33de:	19 f4       	brne	.+6      	; 0x33e6 <vfprintf+0x2e8>
    33e0:	99 ee       	ldi	r25, 0xE9	; 233
    33e2:	f9 22       	and	r15, r25
    33e4:	08 c0       	rjmp	.+16     	; 0x33f6 <vfprintf+0x2f8>
    33e6:	1f 5f       	subi	r17, 0xFF	; 255
    33e8:	f2 fe       	sbrs	r15, 2
    33ea:	05 c0       	rjmp	.+10     	; 0x33f6 <vfprintf+0x2f8>
    33ec:	03 c0       	rjmp	.+6      	; 0x33f4 <vfprintf+0x2f6>
    33ee:	8f 2d       	mov	r24, r15
    33f0:	86 78       	andi	r24, 0x86	; 134
    33f2:	09 f0       	breq	.+2      	; 0x33f6 <vfprintf+0x2f8>
    33f4:	1f 5f       	subi	r17, 0xFF	; 255
    33f6:	0f 2d       	mov	r16, r15
    33f8:	f3 fc       	sbrc	r15, 3
    33fa:	14 c0       	rjmp	.+40     	; 0x3424 <vfprintf+0x326>
    33fc:	f0 fe       	sbrs	r15, 0
    33fe:	0f c0       	rjmp	.+30     	; 0x341e <vfprintf+0x320>
    3400:	1e 15       	cp	r17, r14
    3402:	10 f0       	brcs	.+4      	; 0x3408 <vfprintf+0x30a>
    3404:	9d 2c       	mov	r9, r13
    3406:	0b c0       	rjmp	.+22     	; 0x341e <vfprintf+0x320>
    3408:	9d 2c       	mov	r9, r13
    340a:	9e 0c       	add	r9, r14
    340c:	91 1a       	sub	r9, r17
    340e:	1e 2d       	mov	r17, r14
    3410:	06 c0       	rjmp	.+12     	; 0x341e <vfprintf+0x320>
    3412:	80 e2       	ldi	r24, 0x20	; 32
    3414:	90 e0       	ldi	r25, 0x00	; 0
    3416:	b3 01       	movw	r22, r6
    3418:	0e 94 72 1a 	call	0x34e4	; 0x34e4 <fputc>
    341c:	1f 5f       	subi	r17, 0xFF	; 255
    341e:	1e 15       	cp	r17, r14
    3420:	c0 f3       	brcs	.-16     	; 0x3412 <vfprintf+0x314>
    3422:	04 c0       	rjmp	.+8      	; 0x342c <vfprintf+0x32e>
    3424:	1e 15       	cp	r17, r14
    3426:	10 f4       	brcc	.+4      	; 0x342c <vfprintf+0x32e>
    3428:	e1 1a       	sub	r14, r17
    342a:	01 c0       	rjmp	.+2      	; 0x342e <vfprintf+0x330>
    342c:	ee 24       	eor	r14, r14
    342e:	04 ff       	sbrs	r16, 4
    3430:	0f c0       	rjmp	.+30     	; 0x3450 <vfprintf+0x352>
    3432:	80 e3       	ldi	r24, 0x30	; 48
    3434:	90 e0       	ldi	r25, 0x00	; 0
    3436:	b3 01       	movw	r22, r6
    3438:	0e 94 72 1a 	call	0x34e4	; 0x34e4 <fputc>
    343c:	02 ff       	sbrs	r16, 2
    343e:	1d c0       	rjmp	.+58     	; 0x347a <vfprintf+0x37c>
    3440:	01 fd       	sbrc	r16, 1
    3442:	03 c0       	rjmp	.+6      	; 0x344a <vfprintf+0x34c>
    3444:	88 e7       	ldi	r24, 0x78	; 120
    3446:	90 e0       	ldi	r25, 0x00	; 0
    3448:	0e c0       	rjmp	.+28     	; 0x3466 <vfprintf+0x368>
    344a:	88 e5       	ldi	r24, 0x58	; 88
    344c:	90 e0       	ldi	r25, 0x00	; 0
    344e:	0b c0       	rjmp	.+22     	; 0x3466 <vfprintf+0x368>
    3450:	80 2f       	mov	r24, r16
    3452:	86 78       	andi	r24, 0x86	; 134
    3454:	91 f0       	breq	.+36     	; 0x347a <vfprintf+0x37c>
    3456:	01 ff       	sbrs	r16, 1
    3458:	02 c0       	rjmp	.+4      	; 0x345e <vfprintf+0x360>
    345a:	8b e2       	ldi	r24, 0x2B	; 43
    345c:	01 c0       	rjmp	.+2      	; 0x3460 <vfprintf+0x362>
    345e:	80 e2       	ldi	r24, 0x20	; 32
    3460:	f7 fc       	sbrc	r15, 7
    3462:	8d e2       	ldi	r24, 0x2D	; 45
    3464:	90 e0       	ldi	r25, 0x00	; 0
    3466:	b3 01       	movw	r22, r6
    3468:	0e 94 72 1a 	call	0x34e4	; 0x34e4 <fputc>
    346c:	06 c0       	rjmp	.+12     	; 0x347a <vfprintf+0x37c>
    346e:	80 e3       	ldi	r24, 0x30	; 48
    3470:	90 e0       	ldi	r25, 0x00	; 0
    3472:	b3 01       	movw	r22, r6
    3474:	0e 94 72 1a 	call	0x34e4	; 0x34e4 <fputc>
    3478:	9a 94       	dec	r9
    347a:	d9 14       	cp	r13, r9
    347c:	c0 f3       	brcs	.-16     	; 0x346e <vfprintf+0x370>
    347e:	da 94       	dec	r13
    3480:	f1 01       	movw	r30, r2
    3482:	ed 0d       	add	r30, r13
    3484:	f1 1d       	adc	r31, r1
    3486:	80 81       	ld	r24, Z
    3488:	90 e0       	ldi	r25, 0x00	; 0
    348a:	b3 01       	movw	r22, r6
    348c:	0e 94 72 1a 	call	0x34e4	; 0x34e4 <fputc>
    3490:	dd 20       	and	r13, r13
    3492:	a9 f7       	brne	.-22     	; 0x347e <vfprintf+0x380>
    3494:	06 c0       	rjmp	.+12     	; 0x34a2 <vfprintf+0x3a4>
    3496:	80 e2       	ldi	r24, 0x20	; 32
    3498:	90 e0       	ldi	r25, 0x00	; 0
    349a:	b3 01       	movw	r22, r6
    349c:	0e 94 72 1a 	call	0x34e4	; 0x34e4 <fputc>
    34a0:	ea 94       	dec	r14
    34a2:	ee 20       	and	r14, r14
    34a4:	c1 f7       	brne	.-16     	; 0x3496 <vfprintf+0x398>
    34a6:	43 ce       	rjmp	.-890    	; 0x312e <vfprintf+0x30>
    34a8:	f3 01       	movw	r30, r6
    34aa:	66 81       	ldd	r22, Z+6	; 0x06
    34ac:	77 81       	ldd	r23, Z+7	; 0x07
    34ae:	cb 01       	movw	r24, r22
    34b0:	2b 96       	adiw	r28, 0x0b	; 11
    34b2:	e2 e1       	ldi	r30, 0x12	; 18
    34b4:	0c 94 b4 1b 	jmp	0x3768	; 0x3768 <__epilogue_restores__>

000034b8 <strnlen_P>:
    34b8:	fc 01       	movw	r30, r24
    34ba:	05 90       	lpm	r0, Z+
    34bc:	61 50       	subi	r22, 0x01	; 1
    34be:	70 40       	sbci	r23, 0x00	; 0
    34c0:	01 10       	cpse	r0, r1
    34c2:	d8 f7       	brcc	.-10     	; 0x34ba <strnlen_P+0x2>
    34c4:	80 95       	com	r24
    34c6:	90 95       	com	r25
    34c8:	8e 0f       	add	r24, r30
    34ca:	9f 1f       	adc	r25, r31
    34cc:	08 95       	ret

000034ce <strnlen>:
    34ce:	fc 01       	movw	r30, r24
    34d0:	61 50       	subi	r22, 0x01	; 1
    34d2:	70 40       	sbci	r23, 0x00	; 0
    34d4:	01 90       	ld	r0, Z+
    34d6:	01 10       	cpse	r0, r1
    34d8:	d8 f7       	brcc	.-10     	; 0x34d0 <strnlen+0x2>
    34da:	80 95       	com	r24
    34dc:	90 95       	com	r25
    34de:	8e 0f       	add	r24, r30
    34e0:	9f 1f       	adc	r25, r31
    34e2:	08 95       	ret

000034e4 <fputc>:
    34e4:	0f 93       	push	r16
    34e6:	1f 93       	push	r17
    34e8:	cf 93       	push	r28
    34ea:	df 93       	push	r29
    34ec:	8c 01       	movw	r16, r24
    34ee:	eb 01       	movw	r28, r22
    34f0:	8b 81       	ldd	r24, Y+3	; 0x03
    34f2:	81 ff       	sbrs	r24, 1
    34f4:	1b c0       	rjmp	.+54     	; 0x352c <fputc+0x48>
    34f6:	82 ff       	sbrs	r24, 2
    34f8:	0d c0       	rjmp	.+26     	; 0x3514 <fputc+0x30>
    34fa:	2e 81       	ldd	r18, Y+6	; 0x06
    34fc:	3f 81       	ldd	r19, Y+7	; 0x07
    34fe:	8c 81       	ldd	r24, Y+4	; 0x04
    3500:	9d 81       	ldd	r25, Y+5	; 0x05
    3502:	28 17       	cp	r18, r24
    3504:	39 07       	cpc	r19, r25
    3506:	64 f4       	brge	.+24     	; 0x3520 <fputc+0x3c>
    3508:	e8 81       	ld	r30, Y
    350a:	f9 81       	ldd	r31, Y+1	; 0x01
    350c:	01 93       	st	Z+, r16
    350e:	f9 83       	std	Y+1, r31	; 0x01
    3510:	e8 83       	st	Y, r30
    3512:	06 c0       	rjmp	.+12     	; 0x3520 <fputc+0x3c>
    3514:	e8 85       	ldd	r30, Y+8	; 0x08
    3516:	f9 85       	ldd	r31, Y+9	; 0x09
    3518:	80 2f       	mov	r24, r16
    351a:	09 95       	icall
    351c:	89 2b       	or	r24, r25
    351e:	31 f4       	brne	.+12     	; 0x352c <fputc+0x48>
    3520:	8e 81       	ldd	r24, Y+6	; 0x06
    3522:	9f 81       	ldd	r25, Y+7	; 0x07
    3524:	01 96       	adiw	r24, 0x01	; 1
    3526:	9f 83       	std	Y+7, r25	; 0x07
    3528:	8e 83       	std	Y+6, r24	; 0x06
    352a:	02 c0       	rjmp	.+4      	; 0x3530 <fputc+0x4c>
    352c:	0f ef       	ldi	r16, 0xFF	; 255
    352e:	1f ef       	ldi	r17, 0xFF	; 255
    3530:	c8 01       	movw	r24, r16
    3532:	df 91       	pop	r29
    3534:	cf 91       	pop	r28
    3536:	1f 91       	pop	r17
    3538:	0f 91       	pop	r16
    353a:	08 95       	ret

0000353c <__ultoa_invert>:
    353c:	fa 01       	movw	r30, r20
    353e:	aa 27       	eor	r26, r26
    3540:	28 30       	cpi	r18, 0x08	; 8
    3542:	51 f1       	breq	.+84     	; 0x3598 <__ultoa_invert+0x5c>
    3544:	20 31       	cpi	r18, 0x10	; 16
    3546:	81 f1       	breq	.+96     	; 0x35a8 <__ultoa_invert+0x6c>
    3548:	e8 94       	clt
    354a:	6f 93       	push	r22
    354c:	6e 7f       	andi	r22, 0xFE	; 254
    354e:	6e 5f       	subi	r22, 0xFE	; 254
    3550:	7f 4f       	sbci	r23, 0xFF	; 255
    3552:	8f 4f       	sbci	r24, 0xFF	; 255
    3554:	9f 4f       	sbci	r25, 0xFF	; 255
    3556:	af 4f       	sbci	r26, 0xFF	; 255
    3558:	b1 e0       	ldi	r27, 0x01	; 1
    355a:	3e d0       	rcall	.+124    	; 0x35d8 <__ultoa_invert+0x9c>
    355c:	b4 e0       	ldi	r27, 0x04	; 4
    355e:	3c d0       	rcall	.+120    	; 0x35d8 <__ultoa_invert+0x9c>
    3560:	67 0f       	add	r22, r23
    3562:	78 1f       	adc	r23, r24
    3564:	89 1f       	adc	r24, r25
    3566:	9a 1f       	adc	r25, r26
    3568:	a1 1d       	adc	r26, r1
    356a:	68 0f       	add	r22, r24
    356c:	79 1f       	adc	r23, r25
    356e:	8a 1f       	adc	r24, r26
    3570:	91 1d       	adc	r25, r1
    3572:	a1 1d       	adc	r26, r1
    3574:	6a 0f       	add	r22, r26
    3576:	71 1d       	adc	r23, r1
    3578:	81 1d       	adc	r24, r1
    357a:	91 1d       	adc	r25, r1
    357c:	a1 1d       	adc	r26, r1
    357e:	20 d0       	rcall	.+64     	; 0x35c0 <__ultoa_invert+0x84>
    3580:	09 f4       	brne	.+2      	; 0x3584 <__ultoa_invert+0x48>
    3582:	68 94       	set
    3584:	3f 91       	pop	r19
    3586:	2a e0       	ldi	r18, 0x0A	; 10
    3588:	26 9f       	mul	r18, r22
    358a:	11 24       	eor	r1, r1
    358c:	30 19       	sub	r19, r0
    358e:	30 5d       	subi	r19, 0xD0	; 208
    3590:	31 93       	st	Z+, r19
    3592:	de f6       	brtc	.-74     	; 0x354a <__ultoa_invert+0xe>
    3594:	cf 01       	movw	r24, r30
    3596:	08 95       	ret
    3598:	46 2f       	mov	r20, r22
    359a:	47 70       	andi	r20, 0x07	; 7
    359c:	40 5d       	subi	r20, 0xD0	; 208
    359e:	41 93       	st	Z+, r20
    35a0:	b3 e0       	ldi	r27, 0x03	; 3
    35a2:	0f d0       	rcall	.+30     	; 0x35c2 <__ultoa_invert+0x86>
    35a4:	c9 f7       	brne	.-14     	; 0x3598 <__ultoa_invert+0x5c>
    35a6:	f6 cf       	rjmp	.-20     	; 0x3594 <__ultoa_invert+0x58>
    35a8:	46 2f       	mov	r20, r22
    35aa:	4f 70       	andi	r20, 0x0F	; 15
    35ac:	40 5d       	subi	r20, 0xD0	; 208
    35ae:	4a 33       	cpi	r20, 0x3A	; 58
    35b0:	18 f0       	brcs	.+6      	; 0x35b8 <__ultoa_invert+0x7c>
    35b2:	49 5d       	subi	r20, 0xD9	; 217
    35b4:	31 fd       	sbrc	r19, 1
    35b6:	40 52       	subi	r20, 0x20	; 32
    35b8:	41 93       	st	Z+, r20
    35ba:	02 d0       	rcall	.+4      	; 0x35c0 <__ultoa_invert+0x84>
    35bc:	a9 f7       	brne	.-22     	; 0x35a8 <__ultoa_invert+0x6c>
    35be:	ea cf       	rjmp	.-44     	; 0x3594 <__ultoa_invert+0x58>
    35c0:	b4 e0       	ldi	r27, 0x04	; 4
    35c2:	a6 95       	lsr	r26
    35c4:	97 95       	ror	r25
    35c6:	87 95       	ror	r24
    35c8:	77 95       	ror	r23
    35ca:	67 95       	ror	r22
    35cc:	ba 95       	dec	r27
    35ce:	c9 f7       	brne	.-14     	; 0x35c2 <__ultoa_invert+0x86>
    35d0:	00 97       	sbiw	r24, 0x00	; 0
    35d2:	61 05       	cpc	r22, r1
    35d4:	71 05       	cpc	r23, r1
    35d6:	08 95       	ret
    35d8:	9b 01       	movw	r18, r22
    35da:	ac 01       	movw	r20, r24
    35dc:	0a 2e       	mov	r0, r26
    35de:	06 94       	lsr	r0
    35e0:	57 95       	ror	r21
    35e2:	47 95       	ror	r20
    35e4:	37 95       	ror	r19
    35e6:	27 95       	ror	r18
    35e8:	ba 95       	dec	r27
    35ea:	c9 f7       	brne	.-14     	; 0x35de <__ultoa_invert+0xa2>
    35ec:	62 0f       	add	r22, r18
    35ee:	73 1f       	adc	r23, r19
    35f0:	84 1f       	adc	r24, r20
    35f2:	95 1f       	adc	r25, r21
    35f4:	a0 1d       	adc	r26, r0
    35f6:	08 95       	ret

000035f8 <__mulsi3>:
    35f8:	62 9f       	mul	r22, r18
    35fa:	d0 01       	movw	r26, r0
    35fc:	73 9f       	mul	r23, r19
    35fe:	f0 01       	movw	r30, r0
    3600:	82 9f       	mul	r24, r18
    3602:	e0 0d       	add	r30, r0
    3604:	f1 1d       	adc	r31, r1
    3606:	64 9f       	mul	r22, r20
    3608:	e0 0d       	add	r30, r0
    360a:	f1 1d       	adc	r31, r1
    360c:	92 9f       	mul	r25, r18
    360e:	f0 0d       	add	r31, r0
    3610:	83 9f       	mul	r24, r19
    3612:	f0 0d       	add	r31, r0
    3614:	74 9f       	mul	r23, r20
    3616:	f0 0d       	add	r31, r0
    3618:	65 9f       	mul	r22, r21
    361a:	f0 0d       	add	r31, r0
    361c:	99 27       	eor	r25, r25
    361e:	72 9f       	mul	r23, r18
    3620:	b0 0d       	add	r27, r0
    3622:	e1 1d       	adc	r30, r1
    3624:	f9 1f       	adc	r31, r25
    3626:	63 9f       	mul	r22, r19
    3628:	b0 0d       	add	r27, r0
    362a:	e1 1d       	adc	r30, r1
    362c:	f9 1f       	adc	r31, r25
    362e:	bd 01       	movw	r22, r26
    3630:	cf 01       	movw	r24, r30
    3632:	11 24       	eor	r1, r1
    3634:	08 95       	ret

00003636 <__udivmodqi4>:
    3636:	99 1b       	sub	r25, r25
    3638:	79 e0       	ldi	r23, 0x09	; 9
    363a:	04 c0       	rjmp	.+8      	; 0x3644 <__udivmodqi4_ep>

0000363c <__udivmodqi4_loop>:
    363c:	99 1f       	adc	r25, r25
    363e:	96 17       	cp	r25, r22
    3640:	08 f0       	brcs	.+2      	; 0x3644 <__udivmodqi4_ep>
    3642:	96 1b       	sub	r25, r22

00003644 <__udivmodqi4_ep>:
    3644:	88 1f       	adc	r24, r24
    3646:	7a 95       	dec	r23
    3648:	c9 f7       	brne	.-14     	; 0x363c <__udivmodqi4_loop>
    364a:	80 95       	com	r24
    364c:	08 95       	ret

0000364e <__divmodqi4>:
    364e:	87 fb       	bst	r24, 7
    3650:	08 2e       	mov	r0, r24
    3652:	06 26       	eor	r0, r22
    3654:	87 fd       	sbrc	r24, 7
    3656:	81 95       	neg	r24
    3658:	67 fd       	sbrc	r22, 7
    365a:	61 95       	neg	r22
    365c:	ec df       	rcall	.-40     	; 0x3636 <__udivmodqi4>
    365e:	0e f4       	brtc	.+2      	; 0x3662 <__divmodqi4_1>
    3660:	91 95       	neg	r25

00003662 <__divmodqi4_1>:
    3662:	07 fc       	sbrc	r0, 7
    3664:	81 95       	neg	r24

00003666 <__divmodqi4_exit>:
    3666:	08 95       	ret

00003668 <__udivmodhi4>:
    3668:	aa 1b       	sub	r26, r26
    366a:	bb 1b       	sub	r27, r27
    366c:	51 e1       	ldi	r21, 0x11	; 17
    366e:	07 c0       	rjmp	.+14     	; 0x367e <__udivmodhi4_ep>

00003670 <__udivmodhi4_loop>:
    3670:	aa 1f       	adc	r26, r26
    3672:	bb 1f       	adc	r27, r27
    3674:	a6 17       	cp	r26, r22
    3676:	b7 07       	cpc	r27, r23
    3678:	10 f0       	brcs	.+4      	; 0x367e <__udivmodhi4_ep>
    367a:	a6 1b       	sub	r26, r22
    367c:	b7 0b       	sbc	r27, r23

0000367e <__udivmodhi4_ep>:
    367e:	88 1f       	adc	r24, r24
    3680:	99 1f       	adc	r25, r25
    3682:	5a 95       	dec	r21
    3684:	a9 f7       	brne	.-22     	; 0x3670 <__udivmodhi4_loop>
    3686:	80 95       	com	r24
    3688:	90 95       	com	r25
    368a:	bc 01       	movw	r22, r24
    368c:	cd 01       	movw	r24, r26
    368e:	08 95       	ret

00003690 <__divmodhi4>:
    3690:	97 fb       	bst	r25, 7
    3692:	09 2e       	mov	r0, r25
    3694:	07 26       	eor	r0, r23
    3696:	0a d0       	rcall	.+20     	; 0x36ac <__divmodhi4_neg1>
    3698:	77 fd       	sbrc	r23, 7
    369a:	04 d0       	rcall	.+8      	; 0x36a4 <__divmodhi4_neg2>
    369c:	e5 df       	rcall	.-54     	; 0x3668 <__udivmodhi4>
    369e:	06 d0       	rcall	.+12     	; 0x36ac <__divmodhi4_neg1>
    36a0:	00 20       	and	r0, r0
    36a2:	1a f4       	brpl	.+6      	; 0x36aa <__divmodhi4_exit>

000036a4 <__divmodhi4_neg2>:
    36a4:	70 95       	com	r23
    36a6:	61 95       	neg	r22
    36a8:	7f 4f       	sbci	r23, 0xFF	; 255

000036aa <__divmodhi4_exit>:
    36aa:	08 95       	ret

000036ac <__divmodhi4_neg1>:
    36ac:	f6 f7       	brtc	.-4      	; 0x36aa <__divmodhi4_exit>
    36ae:	90 95       	com	r25
    36b0:	81 95       	neg	r24
    36b2:	9f 4f       	sbci	r25, 0xFF	; 255
    36b4:	08 95       	ret

000036b6 <__udivmodsi4>:
    36b6:	a1 e2       	ldi	r26, 0x21	; 33
    36b8:	1a 2e       	mov	r1, r26
    36ba:	aa 1b       	sub	r26, r26
    36bc:	bb 1b       	sub	r27, r27
    36be:	fd 01       	movw	r30, r26
    36c0:	0d c0       	rjmp	.+26     	; 0x36dc <__udivmodsi4_ep>

000036c2 <__udivmodsi4_loop>:
    36c2:	aa 1f       	adc	r26, r26
    36c4:	bb 1f       	adc	r27, r27
    36c6:	ee 1f       	adc	r30, r30
    36c8:	ff 1f       	adc	r31, r31
    36ca:	a2 17       	cp	r26, r18
    36cc:	b3 07       	cpc	r27, r19
    36ce:	e4 07       	cpc	r30, r20
    36d0:	f5 07       	cpc	r31, r21
    36d2:	20 f0       	brcs	.+8      	; 0x36dc <__udivmodsi4_ep>
    36d4:	a2 1b       	sub	r26, r18
    36d6:	b3 0b       	sbc	r27, r19
    36d8:	e4 0b       	sbc	r30, r20
    36da:	f5 0b       	sbc	r31, r21

000036dc <__udivmodsi4_ep>:
    36dc:	66 1f       	adc	r22, r22
    36de:	77 1f       	adc	r23, r23
    36e0:	88 1f       	adc	r24, r24
    36e2:	99 1f       	adc	r25, r25
    36e4:	1a 94       	dec	r1
    36e6:	69 f7       	brne	.-38     	; 0x36c2 <__udivmodsi4_loop>
    36e8:	60 95       	com	r22
    36ea:	70 95       	com	r23
    36ec:	80 95       	com	r24
    36ee:	90 95       	com	r25
    36f0:	9b 01       	movw	r18, r22
    36f2:	ac 01       	movw	r20, r24
    36f4:	bd 01       	movw	r22, r26
    36f6:	cf 01       	movw	r24, r30
    36f8:	08 95       	ret

000036fa <__divmodsi4>:
    36fa:	97 fb       	bst	r25, 7
    36fc:	09 2e       	mov	r0, r25
    36fe:	05 26       	eor	r0, r21
    3700:	0e d0       	rcall	.+28     	; 0x371e <__divmodsi4_neg1>
    3702:	57 fd       	sbrc	r21, 7
    3704:	04 d0       	rcall	.+8      	; 0x370e <__divmodsi4_neg2>
    3706:	d7 df       	rcall	.-82     	; 0x36b6 <__udivmodsi4>
    3708:	0a d0       	rcall	.+20     	; 0x371e <__divmodsi4_neg1>
    370a:	00 1c       	adc	r0, r0
    370c:	38 f4       	brcc	.+14     	; 0x371c <__divmodsi4_exit>

0000370e <__divmodsi4_neg2>:
    370e:	50 95       	com	r21
    3710:	40 95       	com	r20
    3712:	30 95       	com	r19
    3714:	21 95       	neg	r18
    3716:	3f 4f       	sbci	r19, 0xFF	; 255
    3718:	4f 4f       	sbci	r20, 0xFF	; 255
    371a:	5f 4f       	sbci	r21, 0xFF	; 255

0000371c <__divmodsi4_exit>:
    371c:	08 95       	ret

0000371e <__divmodsi4_neg1>:
    371e:	f6 f7       	brtc	.-4      	; 0x371c <__divmodsi4_exit>
    3720:	90 95       	com	r25
    3722:	80 95       	com	r24
    3724:	70 95       	com	r23
    3726:	61 95       	neg	r22
    3728:	7f 4f       	sbci	r23, 0xFF	; 255
    372a:	8f 4f       	sbci	r24, 0xFF	; 255
    372c:	9f 4f       	sbci	r25, 0xFF	; 255
    372e:	08 95       	ret

00003730 <__prologue_saves__>:
    3730:	2f 92       	push	r2
    3732:	3f 92       	push	r3
    3734:	4f 92       	push	r4
    3736:	5f 92       	push	r5
    3738:	6f 92       	push	r6
    373a:	7f 92       	push	r7
    373c:	8f 92       	push	r8
    373e:	9f 92       	push	r9
    3740:	af 92       	push	r10
    3742:	bf 92       	push	r11
    3744:	cf 92       	push	r12
    3746:	df 92       	push	r13
    3748:	ef 92       	push	r14
    374a:	ff 92       	push	r15
    374c:	0f 93       	push	r16
    374e:	1f 93       	push	r17
    3750:	cf 93       	push	r28
    3752:	df 93       	push	r29
    3754:	cd b7       	in	r28, 0x3d	; 61
    3756:	de b7       	in	r29, 0x3e	; 62
    3758:	ca 1b       	sub	r28, r26
    375a:	db 0b       	sbc	r29, r27
    375c:	0f b6       	in	r0, 0x3f	; 63
    375e:	f8 94       	cli
    3760:	de bf       	out	0x3e, r29	; 62
    3762:	0f be       	out	0x3f, r0	; 63
    3764:	cd bf       	out	0x3d, r28	; 61
    3766:	09 94       	ijmp

00003768 <__epilogue_restores__>:
    3768:	2a 88       	ldd	r2, Y+18	; 0x12
    376a:	39 88       	ldd	r3, Y+17	; 0x11
    376c:	48 88       	ldd	r4, Y+16	; 0x10
    376e:	5f 84       	ldd	r5, Y+15	; 0x0f
    3770:	6e 84       	ldd	r6, Y+14	; 0x0e
    3772:	7d 84       	ldd	r7, Y+13	; 0x0d
    3774:	8c 84       	ldd	r8, Y+12	; 0x0c
    3776:	9b 84       	ldd	r9, Y+11	; 0x0b
    3778:	aa 84       	ldd	r10, Y+10	; 0x0a
    377a:	b9 84       	ldd	r11, Y+9	; 0x09
    377c:	c8 84       	ldd	r12, Y+8	; 0x08
    377e:	df 80       	ldd	r13, Y+7	; 0x07
    3780:	ee 80       	ldd	r14, Y+6	; 0x06
    3782:	fd 80       	ldd	r15, Y+5	; 0x05
    3784:	0c 81       	ldd	r16, Y+4	; 0x04
    3786:	1b 81       	ldd	r17, Y+3	; 0x03
    3788:	aa 81       	ldd	r26, Y+2	; 0x02
    378a:	b9 81       	ldd	r27, Y+1	; 0x01
    378c:	ce 0f       	add	r28, r30
    378e:	d1 1d       	adc	r29, r1
    3790:	0f b6       	in	r0, 0x3f	; 63
    3792:	f8 94       	cli
    3794:	de bf       	out	0x3e, r29	; 62
    3796:	0f be       	out	0x3f, r0	; 63
    3798:	cd bf       	out	0x3d, r28	; 61
    379a:	ed 01       	movw	r28, r26
    379c:	08 95       	ret

0000379e <_exit>:
    379e:	f8 94       	cli

000037a0 <__stop_program>:
    37a0:	ff cf       	rjmp	.-2      	; 0x37a0 <__stop_program>
