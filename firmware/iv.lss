
iv.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000146  00800100  00002e30  00002ec4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002e30  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000b1  00800246  00800246  0000300a  2**0
                  ALLOC
  3 .debug_aranges 00000040  00000000  00000000  0000300a  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000063f  00000000  00000000  0000304a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000025eb  00000000  00000000  00003689  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000502  00000000  00000000  00005c74  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000030a5  00000000  00000000  00006176  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000003e0  00000000  00000000  0000921c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000659  00000000  00000000  000095fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000119c  00000000  00000000  00009c55  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000240  00000000  00000000  0000adf1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 ab 00 	jmp	0x156	; 0x156 <__ctors_end>
       4:	0c 94 bd 14 	jmp	0x297a	; 0x297a <__vector_1>
       8:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
       c:	0c 94 5a 10 	jmp	0x20b4	; 0x20b4 <__vector_3>
      10:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
      14:	0c 94 b3 10 	jmp	0x2166	; 0x2166 <__vector_5>
      18:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
      1c:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
      20:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
      24:	0c 94 1a 0d 	jmp	0x1a34	; 0x1a34 <__vector_9>
      28:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
      2c:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
      30:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
      34:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
      38:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
      3c:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
      40:	0c 94 4c 0a 	jmp	0x1498	; 0x1498 <__vector_16>
      44:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
      48:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
      4c:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
      50:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
      54:	0c 94 ac 02 	jmp	0x558	; 0x558 <__vector_21>
      58:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
      5c:	0c 94 a9 0f 	jmp	0x1f52	; 0x1f52 <__vector_23>
      60:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>
      64:	0c 94 c8 00 	jmp	0x190	; 0x190 <__bad_interrupt>

00000068 <alphatable>:
      68:	fa 3e 1a 7a de 8e f6 2e 60 78 ae 1c aa 2a 3a ce     .>.z....`x...*:.
      78:	f3 0a b6 1e 38 38 b8 6e 76 da                       ....88.nv.

00000082 <alphatable_p>:
      82:	68 00                                               h.

00000084 <numbertable>:
      84:	fc 60 da f2 66 b6 be e0 fe f6                       .`..f.....

0000008e <numbertable_p>:
      8e:	84 00                                               ..

00000090 <digittable>:
      90:	03 07 08 09 06 0a 05 0c 04                          .........

00000099 <digittable_p>:
      99:	90 00                                               ..

0000009b <segmenttable>:
      9b:	0b 10 12 0f 0d 0e 11 13                             ........

000000a3 <segmenttable_p>:
      a3:	9b 00                                               ..

000000a5 <__c.3299>:
      a5:	61 6c 61 72 6d 20 6f 6e 21 00                       alarm on!.

000000af <__c.2571>:
      af:	61 6c 61 72 6d 20 6f 66 66 00                       alarm off.

000000b9 <__c.2308>:
      b9:	53 65 74 20 64 61 79 00                             Set day.

000000c1 <__c.2127>:
      c1:	64 6f 6e 65 00                                      done.

000000c6 <__c.2125>:
      c6:	61 6c 61 72 6d 20 69 6e 69 74 00                    alarm init.

000000d1 <__c.2123>:
      d1:	63 6c 6f 63 6b 20 69 6e 69 74 00                    clock init.

000000dc <__c.2121>:
      dc:	73 70 65 61 6b 65 72 20 69 6e 69 74 00              speaker init.

000000e9 <__c.2119>:
      e9:	62 6f 6f 73 74 20 69 6e 69 74 00                    boost init.

000000f4 <__c.2117>:
      f4:	76 66 64 20 69 6e 69 74 00                          vfd init.

000000fd <__c.2115>:
      fd:	74 75 72 6e 69 6e 67 20 6f 6e 20 61 6c 61 72 6d     turning on alarm
     10d:	73 77 00                                            sw.

00000110 <__c.2113>:
     110:	74 75 72 6e 69 6e 67 20 6f 6e 20 62 75 74 74 6f     turning on butto
     120:	6e 73 00                                            ns.

00000123 <__c.2111>:
     123:	63 6c 6f 63 6b 20 69 6e 69 74 00                    clock init.

0000012e <__c.2109>:
     12e:	21 00                                               !.

00000130 <__c.2077>:
     130:	77 61 6b 65 74 69 6d 65 00                          waketime.

00000139 <__c.1995>:
     139:	57 41 4b 45 52 45 53 45 54 00                       WAKERESET.

00000143 <__c.1993>:
     143:	7a 00                                               z.

00000145 <__c.1907>:
     145:	62 32 00                                            b2.

00000148 <__c.1855>:
     148:	62 33 00                                            b3.

0000014b <__c.1853>:
     14b:	62 31 00                                            b1.

0000014e <__c.1804>:
     14e:	73 6e 6f 6f 7a 65 00 00                             snooze..

00000156 <__ctors_end>:
     156:	11 24       	eor	r1, r1
     158:	1f be       	out	0x3f, r1	; 63
     15a:	cf ef       	ldi	r28, 0xFF	; 255
     15c:	d4 e0       	ldi	r29, 0x04	; 4
     15e:	de bf       	out	0x3e, r29	; 62
     160:	cd bf       	out	0x3d, r28	; 61

00000162 <__do_copy_data>:
     162:	12 e0       	ldi	r17, 0x02	; 2
     164:	a0 e0       	ldi	r26, 0x00	; 0
     166:	b1 e0       	ldi	r27, 0x01	; 1
     168:	e0 e3       	ldi	r30, 0x30	; 48
     16a:	fe e2       	ldi	r31, 0x2E	; 46
     16c:	02 c0       	rjmp	.+4      	; 0x172 <.do_copy_data_start>

0000016e <.do_copy_data_loop>:
     16e:	05 90       	lpm	r0, Z+
     170:	0d 92       	st	X+, r0

00000172 <.do_copy_data_start>:
     172:	a6 34       	cpi	r26, 0x46	; 70
     174:	b1 07       	cpc	r27, r17
     176:	d9 f7       	brne	.-10     	; 0x16e <.do_copy_data_loop>

00000178 <__do_clear_bss>:
     178:	12 e0       	ldi	r17, 0x02	; 2
     17a:	a6 e4       	ldi	r26, 0x46	; 70
     17c:	b2 e0       	ldi	r27, 0x02	; 2
     17e:	01 c0       	rjmp	.+2      	; 0x182 <.do_clear_bss_start>

00000180 <.do_clear_bss_loop>:
     180:	1d 92       	st	X+, r1

00000182 <.do_clear_bss_start>:
     182:	a7 3f       	cpi	r26, 0xF7	; 247
     184:	b1 07       	cpc	r27, r17
     186:	e1 f7       	brne	.-8      	; 0x180 <.do_clear_bss_loop>
     188:	0e 94 4d 13 	call	0x269a	; 0x269a <main>
     18c:	0c 94 16 17 	jmp	0x2e2c	; 0x2e2c <_exit>

00000190 <__bad_interrupt>:
     190:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000194 <delayms>:
uint16_t snoozetimer = 0;

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
     194:	9c 01       	movw	r18, r24
	sei();
     196:	78 94       	sei

	milliseconds = 0;
     198:	10 92 57 02 	sts	0x0257, r1
     19c:	10 92 56 02 	sts	0x0256, r1
	while (milliseconds < ms);
     1a0:	80 91 56 02 	lds	r24, 0x0256
     1a4:	90 91 57 02 	lds	r25, 0x0257
     1a8:	82 17       	cp	r24, r18
     1aa:	93 07       	cpc	r25, r19
     1ac:	c8 f3       	brcs	.-14     	; 0x1a0 <delayms+0xc>
}
     1ae:	08 95       	ret

000001b0 <kickthedog>:
	displaymode = SHOW_TIME;
}

// we reset the watchdog timer 
void kickthedog(void) {
	wdt_reset();
     1b0:	a8 95       	wdr
}
     1b2:	08 95       	ret

000001b4 <gotosleep>:
	// battery
	//if (sleepmode) //already asleep?
	//  return;
	//DEBUGP("sleeptime");

	sleepmode = 1;
     1b4:	81 e0       	ldi	r24, 0x01	; 1
     1b6:	80 93 49 02 	sts	0x0249, r24
	VFDSWITCH_PORT |= _BV(VFDSWITCH); // turn off display
     1ba:	5b 9a       	sbi	0x0b, 3	; 11
	SPCR  &= ~_BV(SPE); // turn off spi
     1bc:	8c b5       	in	r24, 0x2c	; 44
     1be:	8f 7b       	andi	r24, 0xBF	; 191
     1c0:	8c bd       	out	0x2c, r24	; 44
	VFDCLK_PORT &= ~_BV(VFDCLK) & ~_BV(VFDDATA); // no power to vfdchip
     1c2:	85 b1       	in	r24, 0x05	; 5
     1c4:	87 7d       	andi	r24, 0xD7	; 215
     1c6:	85 b9       	out	0x05, r24	; 5
	BOOST_PORT &= ~_BV(BOOST); // pull boost fet low
     1c8:	5e 98       	cbi	0x0b, 6	; 11
	TCCR0B = 0; // no boost
     1ca:	15 bc       	out	0x25, r1	; 37
	volume = 0; // low power buzzer
     1cc:	10 92 e4 02 	sts	0x02E4, r1
	PCICR = 0;  // ignore buttons
     1d0:	10 92 68 00 	sts	0x0068, r1
#ifdef FEATURE_AUTODIM
	DIMMER_POWER_PORT &= ~_BV(DIMMER_POWER_PIN); // no power to photoresistor
     1d4:	45 98       	cbi	0x08, 5	; 8
	// sleep time!
	//beep(3520, 1);
	//beep(1760, 1);
	//beep(880, 1);
	// turn beeper off
	PORTB &= ~_BV(SPK1) & ~_BV(SPK2); 
     1d6:	85 b1       	in	r24, 0x05	; 5
     1d8:	89 7f       	andi	r24, 0xF9	; 249
     1da:	85 b9       	out	0x05, r24	; 5

	// turn off pullups
	PORTD &= ~_BV(BUTTON1) & ~_BV(BUTTON3);
     1dc:	8b b1       	in	r24, 0x0b	; 11
     1de:	8f 7c       	andi	r24, 0xCF	; 207
     1e0:	8b b9       	out	0x0b, r24	; 11
	PORTB &= ~_BV(BUTTON2);
     1e2:	28 98       	cbi	0x05, 0	; 5
	DDRD &= ~_BV(BUTTON1) & ~_BV(BUTTON3);
     1e4:	8a b1       	in	r24, 0x0a	; 10
     1e6:	8f 7c       	andi	r24, 0xCF	; 207
     1e8:	8a b9       	out	0x0a, r24	; 10
	DDRB &= ~_BV(BUTTON2);
     1ea:	20 98       	cbi	0x04, 0	; 4
	ALARM_PORT &= ~_BV(ALARM);
     1ec:	5a 98       	cbi	0x0b, 2	; 11
	ALARM_DDR &= ~_BV(ALARM);
     1ee:	52 98       	cbi	0x0a, 2	; 10


	// reduce the clock speed
	CLKPR = _BV(CLKPCE);
     1f0:	e1 e6       	ldi	r30, 0x61	; 97
     1f2:	f0 e0       	ldi	r31, 0x00	; 0
     1f4:	90 e8       	ldi	r25, 0x80	; 128
     1f6:	90 83       	st	Z, r25
	CLKPR = _BV(CLKPS3);
     1f8:	88 e0       	ldi	r24, 0x08	; 8
     1fa:	80 83       	st	Z, r24

	//  PPR |= _BV(PRUSART0) | _BV(PRADC) | _BV(PRSPI) | _BV(PRTIM1) | _BV(PRTIM0) | _BV(PRTWI);
	PORTC |= _BV(4);  // sleep signal
     1fc:	44 9a       	sbi	0x08, 4	; 8
	SMCR |= _BV(SM1) | _BV(SM0) | _BV(SE); // sleep mode
     1fe:	83 b7       	in	r24, 0x33	; 51
     200:	87 60       	ori	r24, 0x07	; 7
     202:	83 bf       	out	0x33, r24	; 51
	asm("sleep"); 
     204:	88 95       	sleep
	CLKPR = _BV(CLKPCE);
     206:	90 83       	st	Z, r25
	CLKPR = 0;
     208:	10 82       	st	Z, r1
	PORTC &= ~_BV(4);
     20a:	44 98       	cbi	0x08, 4	; 8
}
     20c:	08 95       	ret

0000020e <initbuttons>:
	kickthedog();
}


void initbuttons(void) {
	DDRB =  _BV(VFDCLK) | _BV(VFDDATA) | _BV(SPK1) | _BV(SPK2);
     20e:	8e e2       	ldi	r24, 0x2E	; 46
     210:	84 b9       	out	0x04, r24	; 4
	DDRD = _BV(BOOST) | _BV(VFDSWITCH);
     212:	88 e4       	ldi	r24, 0x48	; 72
     214:	8a b9       	out	0x0a, r24	; 10
	DDRC = _BV(VFDLOAD) | _BV(VFDBLANK);
     216:	89 e0       	ldi	r24, 0x09	; 9
     218:	87 b9       	out	0x07, r24	; 7
	PORTD = _BV(BUTTON1) | _BV(BUTTON3) | _BV(ALARM);
     21a:	84 e3       	ldi	r24, 0x34	; 52
     21c:	8b b9       	out	0x0b, r24	; 11
	PORTB = _BV(BUTTON2);
     21e:	91 e0       	ldi	r25, 0x01	; 1
     220:	95 b9       	out	0x05, r25	; 5

	PCICR = _BV(PCIE0) | _BV(PCIE2);
     222:	85 e0       	ldi	r24, 0x05	; 5
     224:	80 93 68 00 	sts	0x0068, r24
	PCMSK0 = _BV(PCINT0);
     228:	90 93 6b 00 	sts	0x006B, r25
	PCMSK2 = _BV(PCINT21) | _BV(PCINT20);    
     22c:	80 e3       	ldi	r24, 0x30	; 48
     22e:	80 93 6d 00 	sts	0x006D, r24
}
     232:	08 95       	ret

00000234 <display_brightness>:
			}
		}
	}
}

void display_brightness(int brightness) {
     234:	9c 01       	movw	r18, r24
#ifdef FEATURE_AUTODIM
	if (brightness == 0) {
     236:	00 97       	sbiw	r24, 0x00	; 0
     238:	a9 f4       	brne	.+42     	; 0x264 <display_brightness+0x30>
		// auto-dim
		display[7] =  pgm_read_byte(alphatable_p + 'a' - 'a') | 0x1;
     23a:	e8 e6       	ldi	r30, 0x68	; 104
     23c:	f0 e0       	ldi	r31, 0x00	; 0
     23e:	84 91       	lpm	r24, Z+
     240:	81 60       	ori	r24, 0x01	; 1
     242:	80 93 ed 02 	sts	0x02ED, r24
		display[8] =  pgm_read_byte(alphatable_p + 'u' - 'a') | 0x1;
     246:	74 96       	adiw	r30, 0x14	; 20
     248:	e4 91       	lpm	r30, Z+
     24a:	e1 60       	ori	r30, 0x01	; 1
     24c:	e0 93 ee 02 	sts	0x02EE, r30
	ADCSRA |= _BV(ADIE);  // Enable ADC interrupt
}

// Start ADC conversion for dimmer
void dimmer_update(void) {
	if (brightness_level == 0) 
     250:	80 91 f2 02 	lds	r24, 0x02F2
     254:	88 23       	and	r24, r24
     256:	41 f5       	brne	.+80     	; 0x2a8 <display_brightness+0x74>
		ADCSRA |= _BV(ADSC);
     258:	80 91 7a 00 	lds	r24, 0x007A
     25c:	80 64       	ori	r24, 0x40	; 64
     25e:	80 93 7a 00 	sts	0x007A, r24
     262:	08 95       	ret
		display[8] =  pgm_read_byte(alphatable_p + 'u' - 'a') | 0x1;
		dimmer_update();
		return;
	}
#endif
	display[7] = pgm_read_byte(numbertable_p + (brightness / 10)) | 0x1;
     264:	6a e0       	ldi	r22, 0x0A	; 10
     266:	70 e0       	ldi	r23, 0x00	; 0
     268:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__divmodhi4>
     26c:	fb 01       	movw	r30, r22
     26e:	ec 57       	subi	r30, 0x7C	; 124
     270:	ff 4f       	sbci	r31, 0xFF	; 255
     272:	e4 91       	lpm	r30, Z+
     274:	e1 60       	ori	r30, 0x01	; 1
     276:	e0 93 ed 02 	sts	0x02ED, r30
	display[8] = pgm_read_byte(numbertable_p + (brightness % 10)) | 0x1;
     27a:	c9 01       	movw	r24, r18
     27c:	6a e0       	ldi	r22, 0x0A	; 10
     27e:	70 e0       	ldi	r23, 0x00	; 0
     280:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__divmodhi4>
     284:	fc 01       	movw	r30, r24
     286:	ec 57       	subi	r30, 0x7C	; 124
     288:	ff 4f       	sbci	r31, 0xFF	; 255
     28a:	e4 91       	lpm	r30, Z+
     28c:	e1 60       	ori	r30, 0x01	; 1
     28e:	e0 93 ee 02 	sts	0x02EE, r30
	set_vfd_brightness(brightness);
     292:	92 2f       	mov	r25, r18
}

void set_vfd_brightness(uint8_t brightness) {
	// Set PWM value, don't set it so high that
	// we could damage the MAX chip or display
	if (brightness > BRIGHTNESS_MAX)
     294:	2b 35       	cpi	r18, 0x5B	; 91
     296:	10 f0       	brcs	.+4      	; 0x29c <display_brightness+0x68>
     298:	9a e5       	ldi	r25, 0x5A	; 90
     29a:	03 c0       	rjmp	.+6      	; 0x2a2 <display_brightness+0x6e>
		brightness = BRIGHTNESS_MAX;

	// Or so low its not visible
	if (brightness < BRIGHTNESS_MIN)
     29c:	2e 31       	cpi	r18, 0x1E	; 30
     29e:	08 f4       	brcc	.+2      	; 0x2a2 <display_brightness+0x6e>
     2a0:	9e e1       	ldi	r25, 0x1E	; 30
	//// Round up to the next brightness increment
	//if (brightness % BRIGHTNESS_INCREMENT != 0) {
	//  brightness += BRIGHTNESS_INCREMENT - (brightness % BRIGHTNESS_INCREMENT);
	//}

	if (OCR0A == brightness)
     2a2:	87 b5       	in	r24, 0x27	; 39
     2a4:	89 13       	cpse	r24, r25
		return;

	OCR0A = brightness;
     2a6:	97 bd       	out	0x27, r25	; 39
     2a8:	08 95       	ret

000002aa <clock_init>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     2aa:	f9 99       	sbic	0x1f, 1	; 31
     2ac:	fe cf       	rjmp	.-4      	; 0x2aa <clock_init>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
     2ae:	84 e0       	ldi	r24, 0x04	; 4
     2b0:	90 e0       	ldi	r25, 0x00	; 0
     2b2:	92 bd       	out	0x22, r25	; 34
     2b4:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     2b6:	f8 9a       	sbi	0x1f, 0	; 31
     2b8:	80 b5       	in	r24, 0x20	; 32

/**************************** RTC & ALARM *****************************/
void clock_init(void) {
	// we store the time in EEPROM when switching from power modes so its
	// reasonable to start with whats in memory
	time_h = eeprom_read_byte((uint8_t *)EE_HOUR) % 24;
     2ba:	68 e1       	ldi	r22, 0x18	; 24
     2bc:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__udivmodqi4>
     2c0:	90 93 61 02 	sts	0x0261, r25
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     2c4:	f9 99       	sbic	0x1f, 1	; 31
     2c6:	fe cf       	rjmp	.-4      	; 0x2c4 <clock_init+0x1a>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
     2c8:	85 e0       	ldi	r24, 0x05	; 5
     2ca:	90 e0       	ldi	r25, 0x00	; 0
     2cc:	92 bd       	out	0x22, r25	; 34
     2ce:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     2d0:	f8 9a       	sbi	0x1f, 0	; 31
     2d2:	80 b5       	in	r24, 0x20	; 32
	time_m = eeprom_read_byte((uint8_t *)EE_MIN) % 60;
     2d4:	6c e3       	ldi	r22, 0x3C	; 60
     2d6:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__udivmodqi4>
     2da:	90 93 ef 02 	sts	0x02EF, r25
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     2de:	f9 99       	sbic	0x1f, 1	; 31
     2e0:	fe cf       	rjmp	.-4      	; 0x2de <clock_init+0x34>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
     2e2:	86 e0       	ldi	r24, 0x06	; 6
     2e4:	90 e0       	ldi	r25, 0x00	; 0
     2e6:	92 bd       	out	0x22, r25	; 34
     2e8:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     2ea:	f8 9a       	sbi	0x1f, 0	; 31
     2ec:	80 b5       	in	r24, 0x20	; 32
	time_s = eeprom_read_byte((uint8_t *)EE_SEC) % 60;
     2ee:	6c e3       	ldi	r22, 0x3C	; 60
     2f0:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__udivmodqi4>
     2f4:	90 93 f6 02 	sts	0x02F6, r25
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     2f8:	f9 99       	sbic	0x1f, 1	; 31
     2fa:	fe cf       	rjmp	.-4      	; 0x2f8 <clock_init+0x4e>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
     2fc:	88 e0       	ldi	r24, 0x08	; 8
     2fe:	90 e0       	ldi	r25, 0x00	; 0
     300:	92 bd       	out	0x22, r25	; 34
     302:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     304:	f8 9a       	sbi	0x1f, 0	; 31
     306:	80 b5       	in	r24, 0x20	; 32
	time_m = TIMEMIN;
	time_s = TIMESEC + 10;
	*/

	// Set up the stored alarm time and date
	alarm_m = eeprom_read_byte((uint8_t *)EE_ALARM_MIN) % 60;
     308:	6c e3       	ldi	r22, 0x3C	; 60
     30a:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__udivmodqi4>
     30e:	90 93 e3 02 	sts	0x02E3, r25
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     312:	f9 99       	sbic	0x1f, 1	; 31
     314:	fe cf       	rjmp	.-4      	; 0x312 <clock_init+0x68>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
     316:	87 e0       	ldi	r24, 0x07	; 7
     318:	90 e0       	ldi	r25, 0x00	; 0
     31a:	92 bd       	out	0x22, r25	; 34
     31c:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     31e:	f8 9a       	sbi	0x1f, 0	; 31
     320:	80 b5       	in	r24, 0x20	; 32
	alarm_h = eeprom_read_byte((uint8_t *)EE_ALARM_HOUR) % 24;
     322:	68 e1       	ldi	r22, 0x18	; 24
     324:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__udivmodqi4>
     328:	90 93 f1 02 	sts	0x02F1, r25
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     32c:	f9 99       	sbic	0x1f, 1	; 31
     32e:	fe cf       	rjmp	.-4      	; 0x32c <clock_init+0x82>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
     330:	81 e0       	ldi	r24, 0x01	; 1
     332:	90 e0       	ldi	r25, 0x00	; 0
     334:	92 bd       	out	0x22, r25	; 34
     336:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     338:	f8 9a       	sbi	0x1f, 0	; 31
     33a:	80 b5       	in	r24, 0x20	; 32

	date_y = eeprom_read_byte((uint8_t *)EE_YEAR) % 100;
     33c:	64 e6       	ldi	r22, 0x64	; 100
     33e:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__udivmodqi4>
     342:	90 93 e2 02 	sts	0x02E2, r25
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     346:	f9 99       	sbic	0x1f, 1	; 31
     348:	fe cf       	rjmp	.-4      	; 0x346 <clock_init+0x9c>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
     34a:	82 e0       	ldi	r24, 0x02	; 2
     34c:	90 e0       	ldi	r25, 0x00	; 0
     34e:	92 bd       	out	0x22, r25	; 34
     350:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     352:	f8 9a       	sbi	0x1f, 0	; 31
     354:	80 b5       	in	r24, 0x20	; 32
	date_m = eeprom_read_byte((uint8_t *)EE_MONTH) % 13;
     356:	6d e0       	ldi	r22, 0x0D	; 13
     358:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__udivmodqi4>
     35c:	90 93 f5 02 	sts	0x02F5, r25
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     360:	f9 99       	sbic	0x1f, 1	; 31
     362:	fe cf       	rjmp	.-4      	; 0x360 <clock_init+0xb6>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
     364:	83 e0       	ldi	r24, 0x03	; 3
     366:	90 e0       	ldi	r25, 0x00	; 0
     368:	92 bd       	out	0x22, r25	; 34
     36a:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     36c:	f8 9a       	sbi	0x1f, 0	; 31
     36e:	80 b5       	in	r24, 0x20	; 32
	date_d = eeprom_read_byte((uint8_t *)EE_DAY) % 32;
     370:	8f 71       	andi	r24, 0x1F	; 31
     372:	80 93 e5 02 	sts	0x02E5, r24

	restored = 1;
     376:	91 e0       	ldi	r25, 0x01	; 1
     378:	90 93 4b 02 	sts	0x024B, r25

	// Turn on the RTC by selecting the external 32khz crystal
	// 32.768 / 128 = 256 which is exactly an 8-bit timer overflow
	ASSR |= _BV(AS2); // use crystal
     37c:	80 91 b6 00 	lds	r24, 0x00B6
     380:	80 62       	ori	r24, 0x20	; 32
     382:	80 93 b6 00 	sts	0x00B6, r24
	TCCR2B = _BV(CS22) | _BV(CS20); // div by 128
     386:	85 e0       	ldi	r24, 0x05	; 5
     388:	80 93 b1 00 	sts	0x00B1, r24
	// We will overflow once a second, and call an interrupt

	// enable interrupt
	TIMSK2 = _BV(TOIE2);
     38c:	90 93 70 00 	sts	0x0070, r25

	// enable all interrupts!
	sei();
     390:	78 94       	sei
}
     392:	08 95       	ret

00000394 <leapyear>:
	}
}

// This will calculate leapyears, give it the year
// and it will return 1 (true) or 0 (false)
uint8_t leapyear(uint16_t y) {
     394:	fc 01       	movw	r30, r24
	return ( (!(y % 4) && (y % 100)) || !(y % 400));
     396:	83 70       	andi	r24, 0x03	; 3
     398:	90 70       	andi	r25, 0x00	; 0
     39a:	89 2b       	or	r24, r25
     39c:	39 f4       	brne	.+14     	; 0x3ac <leapyear+0x18>
     39e:	cf 01       	movw	r24, r30
     3a0:	64 e6       	ldi	r22, 0x64	; 100
     3a2:	70 e0       	ldi	r23, 0x00	; 0
     3a4:	0e 94 b2 16 	call	0x2d64	; 0x2d64 <__udivmodhi4>
     3a8:	89 2b       	or	r24, r25
     3aa:	49 f4       	brne	.+18     	; 0x3be <leapyear+0x2a>
     3ac:	20 e0       	ldi	r18, 0x00	; 0
     3ae:	30 e0       	ldi	r19, 0x00	; 0
     3b0:	cf 01       	movw	r24, r30
     3b2:	60 e9       	ldi	r22, 0x90	; 144
     3b4:	71 e0       	ldi	r23, 0x01	; 1
     3b6:	0e 94 b2 16 	call	0x2d64	; 0x2d64 <__udivmodhi4>
     3ba:	89 2b       	or	r24, r25
     3bc:	11 f4       	brne	.+4      	; 0x3c2 <leapyear+0x2e>
     3be:	21 e0       	ldi	r18, 0x01	; 1
     3c0:	30 e0       	ldi	r19, 0x00	; 0
}
     3c2:	82 2f       	mov	r24, r18
     3c4:	08 95       	ret

000003c6 <speaker_init>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     3c6:	f9 99       	sbic	0x1f, 1	; 31
     3c8:	fe cf       	rjmp	.-4      	; 0x3c6 <speaker_init>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
     3ca:	8a e0       	ldi	r24, 0x0A	; 10
     3cc:	90 e0       	ldi	r25, 0x00	; 0
     3ce:	92 bd       	out	0x22, r25	; 34
     3d0:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     3d2:	f8 9a       	sbi	0x1f, 0	; 31
     3d4:	80 b5       	in	r24, 0x20	; 32
/**************************** SPEAKER *****************************/
// Set up the speaker to prepare for beeping!
void speaker_init(void) {

	// read the preferences for high/low volume
	volume = eeprom_read_byte((uint8_t *)EE_VOLUME);
     3d6:	80 93 e4 02 	sts	0x02E4, r24

	// We use the built-in fast PWM, 8 bit timer
	PORTB |= _BV(SPK1) | _BV(SPK2); 
     3da:	85 b1       	in	r24, 0x05	; 5
     3dc:	86 60       	ori	r24, 0x06	; 6
     3de:	85 b9       	out	0x05, r24	; 5

	// Turn on PWM outputs for both pins
	TCCR1A = _BV(COM1B1) | _BV(COM1B0) | _BV(WGM11);
     3e0:	82 e3       	ldi	r24, 0x32	; 50
     3e2:	80 93 80 00 	sts	0x0080, r24
	if (volume) {
     3e6:	80 91 e4 02 	lds	r24, 0x02E4
     3ea:	88 23       	and	r24, r24
     3ec:	29 f0       	breq	.+10     	; 0x3f8 <speaker_init+0x32>
		TCCR1A |= _BV(COM1A1);
     3ee:	80 91 80 00 	lds	r24, 0x0080
     3f2:	80 68       	ori	r24, 0x80	; 128
     3f4:	80 93 80 00 	sts	0x0080, r24
	} 
	TCCR1B = _BV(WGM13) | _BV(WGM12);
     3f8:	88 e1       	ldi	r24, 0x18	; 24
     3fa:	80 93 81 00 	sts	0x0081, r24

	// start at 4khz:  250 * 8 multiplier * 4000 = 8mhz
	ICR1 = 250;
     3fe:	8a ef       	ldi	r24, 0xFA	; 250
     400:	90 e0       	ldi	r25, 0x00	; 0
     402:	90 93 87 00 	sts	0x0087, r25
     406:	80 93 86 00 	sts	0x0086, r24
	OCR1B = OCR1A = ICR1 / 2;
     40a:	80 91 86 00 	lds	r24, 0x0086
     40e:	90 91 87 00 	lds	r25, 0x0087
     412:	96 95       	lsr	r25
     414:	87 95       	ror	r24
     416:	90 93 89 00 	sts	0x0089, r25
     41a:	80 93 88 00 	sts	0x0088, r24
     41e:	80 91 88 00 	lds	r24, 0x0088
     422:	90 91 89 00 	lds	r25, 0x0089
     426:	90 93 8b 00 	sts	0x008B, r25
     42a:	80 93 8a 00 	sts	0x008A, r24
}
     42e:	08 95       	ret

00000430 <tick>:

// This makes the speaker tick, it doesnt use PWM
// instead it just flicks the piezo
void tick(void) {
	TCCR1A = 0;
     430:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;
     434:	10 92 81 00 	sts	0x0081, r1

	// Send a pulse thru both pins, alternating
	SPK_PORT |= _BV(SPK1);
     438:	29 9a       	sbi	0x05, 1	; 5
	SPK_PORT &= ~_BV(SPK2);
     43a:	2a 98       	cbi	0x05, 2	; 5

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
     43c:	78 94       	sei

	milliseconds = 0;
     43e:	10 92 57 02 	sts	0x0257, r1
     442:	10 92 56 02 	sts	0x0256, r1
	while (milliseconds < ms);
     446:	80 91 56 02 	lds	r24, 0x0256
     44a:	90 91 57 02 	lds	r25, 0x0257
     44e:	0a 97       	sbiw	r24, 0x0a	; 10
     450:	d0 f3       	brcs	.-12     	; 0x446 <tick+0x16>

	// Send a pulse thru both pins, alternating
	SPK_PORT |= _BV(SPK1);
	SPK_PORT &= ~_BV(SPK2);
	delayms(10);
	SPK_PORT |= _BV(SPK2);
     452:	2a 9a       	sbi	0x05, 2	; 5
	SPK_PORT &= ~_BV(SPK1);
     454:	29 98       	cbi	0x05, 1	; 5

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
     456:	78 94       	sei

	milliseconds = 0;
     458:	10 92 57 02 	sts	0x0257, r1
     45c:	10 92 56 02 	sts	0x0256, r1
	while (milliseconds < ms);
     460:	80 91 56 02 	lds	r24, 0x0256
     464:	90 91 57 02 	lds	r25, 0x0257
     468:	0a 97       	sbiw	r24, 0x0a	; 10
     46a:	d0 f3       	brcs	.-12     	; 0x460 <tick+0x30>
	delayms(10);
	SPK_PORT |= _BV(SPK2);
	SPK_PORT &= ~_BV(SPK1);
	delayms(10);
	// turn them both off
	SPK_PORT &= ~_BV(SPK1) & ~_BV(SPK2);
     46c:	85 b1       	in	r24, 0x05	; 5
     46e:	89 7f       	andi	r24, 0xF9	; 249
     470:	85 b9       	out	0x05, r24	; 5

	TCCR1A = _BV(COM1A1) | _BV(COM1B1) | _BV(COM1B0) | _BV(WGM11);
     472:	82 eb       	ldi	r24, 0xB2	; 178
     474:	80 93 80 00 	sts	0x0080, r24
	TCCR1B = _BV(WGM13) | _BV(WGM12);
     478:	88 e1       	ldi	r24, 0x18	; 24
     47a:	80 93 81 00 	sts	0x0081, r24
}
     47e:	08 95       	ret

00000480 <beep>:

// We can play short beeps!
void beep(uint16_t freq, uint8_t times) {
     480:	1f 93       	push	r17
     482:	16 2f       	mov	r17, r22
	// set the PWM output to match the desired frequency
	ICR1 = (F_CPU/8)/freq;
     484:	9c 01       	movw	r18, r24
     486:	40 e0       	ldi	r20, 0x00	; 0
     488:	50 e0       	ldi	r21, 0x00	; 0
     48a:	60 e4       	ldi	r22, 0x40	; 64
     48c:	72 e4       	ldi	r23, 0x42	; 66
     48e:	8f e0       	ldi	r24, 0x0F	; 15
     490:	90 e0       	ldi	r25, 0x00	; 0
     492:	0e 94 fb 16 	call	0x2df6	; 0x2df6 <__divmodsi4>
     496:	30 93 87 00 	sts	0x0087, r19
     49a:	20 93 86 00 	sts	0x0086, r18
	// we want 50% duty cycle square wave
	OCR1A = OCR1B = ICR1/2;
     49e:	80 91 86 00 	lds	r24, 0x0086
     4a2:	90 91 87 00 	lds	r25, 0x0087
     4a6:	96 95       	lsr	r25
     4a8:	87 95       	ror	r24
     4aa:	90 93 8b 00 	sts	0x008B, r25
     4ae:	80 93 8a 00 	sts	0x008A, r24
     4b2:	80 91 8a 00 	lds	r24, 0x008A
     4b6:	90 91 8b 00 	lds	r25, 0x008B
     4ba:	90 93 89 00 	sts	0x0089, r25
     4be:	80 93 88 00 	sts	0x0088, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     4c2:	28 ec       	ldi	r18, 0xC8	; 200
     4c4:	30 e0       	ldi	r19, 0x00	; 0
     4c6:	1c c0       	rjmp	.+56     	; 0x500 <__stack+0x1>

	while (times--) {
		TCCR1B |= _BV(CS11); // turn it on!
     4c8:	80 91 81 00 	lds	r24, 0x0081
     4cc:	82 60       	ori	r24, 0x02	; 2
     4ce:	80 93 81 00 	sts	0x0081, r24
     4d2:	80 ed       	ldi	r24, 0xD0	; 208
     4d4:	97 e0       	ldi	r25, 0x07	; 7
     4d6:	f9 01       	movw	r30, r18
     4d8:	31 97       	sbiw	r30, 0x01	; 1
     4da:	f1 f7       	brne	.-4      	; 0x4d8 <beep+0x58>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     4dc:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     4de:	d9 f7       	brne	.-10     	; 0x4d6 <beep+0x56>
		// beeps are 200ms long on
		_delay_ms(200);
		TCCR1B &= ~_BV(CS11); // turn it off!
     4e0:	80 91 81 00 	lds	r24, 0x0081
     4e4:	8d 7f       	andi	r24, 0xFD	; 253
     4e6:	80 93 81 00 	sts	0x0081, r24
		PORTB &= ~_BV(SPK1) & ~_BV(SPK2);
     4ea:	85 b1       	in	r24, 0x05	; 5
     4ec:	89 7f       	andi	r24, 0xF9	; 249
     4ee:	85 b9       	out	0x05, r24	; 5
     4f0:	80 ed       	ldi	r24, 0xD0	; 208
     4f2:	97 e0       	ldi	r25, 0x07	; 7
     4f4:	f9 01       	movw	r30, r18
     4f6:	31 97       	sbiw	r30, 0x01	; 1
     4f8:	f1 f7       	brne	.-4      	; 0x4f6 <beep+0x76>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     4fa:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     4fc:	d9 f7       	brne	.-10     	; 0x4f4 <beep+0x74>
     4fe:	11 50       	subi	r17, 0x01	; 1
	// set the PWM output to match the desired frequency
	ICR1 = (F_CPU/8)/freq;
	// we want 50% duty cycle square wave
	OCR1A = OCR1B = ICR1/2;

	while (times--) {
     500:	11 23       	and	r17, r17
     502:	11 f7       	brne	.-60     	; 0x4c8 <beep+0x48>
		PORTB &= ~_BV(SPK1) & ~_BV(SPK2);
		// beeps are 200ms long off
		_delay_ms(200);
	}
	// turn speaker off
	PORTB &= ~_BV(SPK1) & ~_BV(SPK2);
     504:	85 b1       	in	r24, 0x05	; 5
     506:	89 7f       	andi	r24, 0xF9	; 249
     508:	85 b9       	out	0x05, r24	; 5
}
     50a:	1f 91       	pop	r17
     50c:	08 95       	ret

0000050e <dimmer_init>:

#ifdef FEATURE_AUTODIM
/**************************** DIMMER ****************************/
void dimmer_init(void) {
	// Power for the photoresistor
	DIMMER_POWER_DDR |= _BV(DIMMER_POWER_PIN); 
     50e:	3d 9a       	sbi	0x07, 5	; 7
	DIMMER_POWER_PORT |= _BV(DIMMER_POWER_PIN);
     510:	45 9a       	sbi	0x08, 5	; 8

	ADCSRA |= _BV(ADPS2)| _BV(ADPS1); // Set ADC prescalar to 64 - 125KHz sample rate @ 8MHz F_CPU
     512:	aa e7       	ldi	r26, 0x7A	; 122
     514:	b0 e0       	ldi	r27, 0x00	; 0
     516:	8c 91       	ld	r24, X
     518:	86 60       	ori	r24, 0x06	; 6
     51a:	8c 93       	st	X, r24
	ADMUX |= _BV(REFS0);  // Set ADC reference to AVCC
     51c:	ec e7       	ldi	r30, 0x7C	; 124
     51e:	f0 e0       	ldi	r31, 0x00	; 0
     520:	80 81       	ld	r24, Z
     522:	80 64       	ori	r24, 0x40	; 64
     524:	80 83       	st	Z, r24
	ADMUX |= _BV(DIMMER_SENSE_PIN);   // Set ADC input as ADC4 (PC4)
     526:	80 81       	ld	r24, Z
     528:	84 60       	ori	r24, 0x04	; 4
     52a:	80 83       	st	Z, r24
	DIDR0 |= _BV(DIMMER_SENSE_PIND); // Disable the digital imput buffer on the sense pin to save power.
     52c:	ee e7       	ldi	r30, 0x7E	; 126
     52e:	f0 e0       	ldi	r31, 0x00	; 0
     530:	80 81       	ld	r24, Z
     532:	80 61       	ori	r24, 0x10	; 16
     534:	80 83       	st	Z, r24
	ADCSRA |= _BV(ADEN);  // Enable ADC
     536:	8c 91       	ld	r24, X
     538:	80 68       	ori	r24, 0x80	; 128
     53a:	8c 93       	st	X, r24
	ADCSRA |= _BV(ADIE);  // Enable ADC interrupt
     53c:	8c 91       	ld	r24, X
     53e:	88 60       	ori	r24, 0x08	; 8
     540:	8c 93       	st	X, r24
}
     542:	08 95       	ret

00000544 <dimmer_update>:

// Start ADC conversion for dimmer
void dimmer_update(void) {
	if (brightness_level == 0) 
     544:	80 91 f2 02 	lds	r24, 0x02F2
     548:	88 23       	and	r24, r24
     54a:	29 f4       	brne	.+10     	; 0x556 <dimmer_update+0x12>
		ADCSRA |= _BV(ADSC);
     54c:	80 91 7a 00 	lds	r24, 0x007A
     550:	80 64       	ori	r24, 0x40	; 64
     552:	80 93 7a 00 	sts	0x007A, r24
     556:	08 95       	ret

00000558 <__vector_21>:
}

// Update brightness once ADC measurement completes
SIGNAL(SIG_ADC) {
     558:	1f 92       	push	r1
     55a:	0f 92       	push	r0
     55c:	0f b6       	in	r0, 0x3f	; 63
     55e:	0f 92       	push	r0
     560:	11 24       	eor	r1, r1
     562:	2f 93       	push	r18
     564:	3f 93       	push	r19
     566:	4f 93       	push	r20
     568:	5f 93       	push	r21
     56a:	6f 93       	push	r22
     56c:	7f 93       	push	r23
     56e:	8f 93       	push	r24
     570:	9f 93       	push	r25
     572:	af 93       	push	r26
     574:	bf 93       	push	r27
     576:	ef 93       	push	r30
     578:	ff 93       	push	r31
	uint8_t low, high;
	unsigned int val;
	if (brightness_level != 0)
     57a:	80 91 f2 02 	lds	r24, 0x02F2
     57e:	88 23       	and	r24, r24
     580:	b9 f5       	brne	.+110    	; 0x5f0 <__vector_21+0x98>
		return;
	// Read 2-byte value. Must read ADCL first because that locks the value.
	low = ADCL;
     582:	30 91 78 00 	lds	r19, 0x0078
	high = ADCH;
     586:	20 91 79 00 	lds	r18, 0x0079
	val = (high << 8) | low;
     58a:	92 2f       	mov	r25, r18
     58c:	80 e0       	ldi	r24, 0x00	; 0
     58e:	63 2f       	mov	r22, r19
     590:	70 e0       	ldi	r23, 0x00	; 0
     592:	68 2b       	or	r22, r24
     594:	79 2b       	or	r23, r25
	// Set brightness to a value between min & max based on light reading.
	if (val >= PHOTOCELL_DARK) {
     596:	83 e0       	ldi	r24, 0x03	; 3
     598:	6f 3f       	cpi	r22, 0xFF	; 255
     59a:	78 07       	cpc	r23, r24
     59c:	18 f0       	brcs	.+6      	; 0x5a4 <__vector_21+0x4c>
     59e:	8d e2       	ldi	r24, 0x2D	; 45
     5a0:	90 e0       	ldi	r25, 0x00	; 0
     5a2:	1b c0       	rjmp	.+54     	; 0x5da <__vector_21+0x82>
		val = PHOTOCELL_MIN;
	} else if (val <= PHOTOCELL_LIGHT) {
     5a4:	82 e0       	ldi	r24, 0x02	; 2
     5a6:	69 35       	cpi	r22, 0x59	; 89
     5a8:	78 07       	cpc	r23, r24
     5aa:	18 f4       	brcc	.+6      	; 0x5b2 <__vector_21+0x5a>
     5ac:	8a e5       	ldi	r24, 0x5A	; 90
     5ae:	90 e0       	ldi	r25, 0x00	; 0
     5b0:	14 c0       	rjmp	.+40     	; 0x5da <__vector_21+0x82>
		val = PHOTOCELL_MAX;
	} else {
		val = PHOTOCELL_MAX - (((unsigned long)(PHOTOCELL_MAX - PHOTOCELL_MIN)) *
     5b2:	68 55       	subi	r22, 0x58	; 88
     5b4:	72 40       	sbci	r23, 0x02	; 2
     5b6:	80 e0       	ldi	r24, 0x00	; 0
     5b8:	90 e0       	ldi	r25, 0x00	; 0
     5ba:	2d e2       	ldi	r18, 0x2D	; 45
     5bc:	30 e0       	ldi	r19, 0x00	; 0
     5be:	40 e0       	ldi	r20, 0x00	; 0
     5c0:	50 e0       	ldi	r21, 0x00	; 0
     5c2:	0e 94 7a 16 	call	0x2cf4	; 0x2cf4 <__mulsi3>
     5c6:	27 ea       	ldi	r18, 0xA7	; 167
     5c8:	31 e0       	ldi	r19, 0x01	; 1
     5ca:	40 e0       	ldi	r20, 0x00	; 0
     5cc:	50 e0       	ldi	r21, 0x00	; 0
     5ce:	0e 94 d9 16 	call	0x2db2	; 0x2db2 <__udivmodsi4>
     5d2:	8a e5       	ldi	r24, 0x5A	; 90
     5d4:	90 e0       	ldi	r25, 0x00	; 0
     5d6:	82 1b       	sub	r24, r18
     5d8:	93 0b       	sbc	r25, r19
				(val - PHOTOCELL_LIGHT)) / (PHOTOCELL_DARK - PHOTOCELL_LIGHT);
	}
	set_vfd_brightness(val);
     5da:	98 2f       	mov	r25, r24
}

void set_vfd_brightness(uint8_t brightness) {
	// Set PWM value, don't set it so high that
	// we could damage the MAX chip or display
	if (brightness > BRIGHTNESS_MAX)
     5dc:	8b 35       	cpi	r24, 0x5B	; 91
     5de:	10 f0       	brcs	.+4      	; 0x5e4 <__vector_21+0x8c>
     5e0:	9a e5       	ldi	r25, 0x5A	; 90
     5e2:	03 c0       	rjmp	.+6      	; 0x5ea <__vector_21+0x92>
		brightness = BRIGHTNESS_MAX;

	// Or so low its not visible
	if (brightness < BRIGHTNESS_MIN)
     5e4:	8e 31       	cpi	r24, 0x1E	; 30
     5e6:	08 f4       	brcc	.+2      	; 0x5ea <__vector_21+0x92>
     5e8:	9e e1       	ldi	r25, 0x1E	; 30
	//// Round up to the next brightness increment
	//if (brightness % BRIGHTNESS_INCREMENT != 0) {
	//  brightness += BRIGHTNESS_INCREMENT - (brightness % BRIGHTNESS_INCREMENT);
	//}

	if (OCR0A == brightness)
     5ea:	87 b5       	in	r24, 0x27	; 39
     5ec:	89 13       	cpse	r24, r25
		return;

	OCR0A = brightness;
     5ee:	97 bd       	out	0x27, r25	; 39
	} else {
		val = PHOTOCELL_MAX - (((unsigned long)(PHOTOCELL_MAX - PHOTOCELL_MIN)) *
				(val - PHOTOCELL_LIGHT)) / (PHOTOCELL_DARK - PHOTOCELL_LIGHT);
	}
	set_vfd_brightness(val);
}
     5f0:	ff 91       	pop	r31
     5f2:	ef 91       	pop	r30
     5f4:	bf 91       	pop	r27
     5f6:	af 91       	pop	r26
     5f8:	9f 91       	pop	r25
     5fa:	8f 91       	pop	r24
     5fc:	7f 91       	pop	r23
     5fe:	6f 91       	pop	r22
     600:	5f 91       	pop	r21
     602:	4f 91       	pop	r20
     604:	3f 91       	pop	r19
     606:	2f 91       	pop	r18
     608:	0f 90       	pop	r0
     60a:	0f be       	out	0x3f, r0	; 63
     60c:	0f 90       	pop	r0
     60e:	1f 90       	pop	r1
     610:	18 95       	reti

00000612 <boost_init>:

/**************************** BOOST *****************************/

// We control the boost converter by changing the PWM output
// pins
void boost_init(uint8_t brightness) {
     612:	98 2f       	mov	r25, r24
}

void set_vfd_brightness(uint8_t brightness) {
	// Set PWM value, don't set it so high that
	// we could damage the MAX chip or display
	if (brightness > BRIGHTNESS_MAX)
     614:	8b 35       	cpi	r24, 0x5B	; 91
     616:	10 f0       	brcs	.+4      	; 0x61c <boost_init+0xa>
     618:	9a e5       	ldi	r25, 0x5A	; 90
     61a:	03 c0       	rjmp	.+6      	; 0x622 <boost_init+0x10>
		brightness = BRIGHTNESS_MAX;

	// Or so low its not visible
	if (brightness < BRIGHTNESS_MIN)
     61c:	8e 31       	cpi	r24, 0x1E	; 30
     61e:	08 f4       	brcc	.+2      	; 0x622 <boost_init+0x10>
     620:	9e e1       	ldi	r25, 0x1E	; 30
	//// Round up to the next brightness increment
	//if (brightness % BRIGHTNESS_INCREMENT != 0) {
	//  brightness += BRIGHTNESS_INCREMENT - (brightness % BRIGHTNESS_INCREMENT);
	//}

	if (OCR0A == brightness)
     622:	87 b5       	in	r24, 0x27	; 39
     624:	89 13       	cpse	r24, r25
		return;

	OCR0A = brightness;
     626:	97 bd       	out	0x27, r25	; 39
void boost_init(uint8_t brightness) {

	set_vfd_brightness(brightness);

	// fast PWM, set OC0A (boost output pin) on match
	TCCR0A = _BV(WGM00) | _BV(WGM01);  
     628:	83 e0       	ldi	r24, 0x03	; 3
     62a:	84 bd       	out	0x24, r24	; 36

	// Use the fastest clock
	TCCR0B = _BV(CS00);
     62c:	81 e0       	ldi	r24, 0x01	; 1
     62e:	85 bd       	out	0x25, r24	; 37

	TCCR0A |= _BV(COM0A1);
     630:	84 b5       	in	r24, 0x24	; 36
     632:	80 68       	ori	r24, 0x80	; 128
     634:	84 bd       	out	0x24, r24	; 36
	TIMSK0 |= _BV(TOIE0); // turn on the interrupt for muxing
     636:	80 91 6e 00 	lds	r24, 0x006E
     63a:	81 60       	ori	r24, 0x01	; 1
     63c:	80 93 6e 00 	sts	0x006E, r24
	sei();
     640:	78 94       	sei
}
     642:	08 95       	ret

00000644 <set_vfd_brightness>:

void set_vfd_brightness(uint8_t brightness) {
     644:	98 2f       	mov	r25, r24
	// Set PWM value, don't set it so high that
	// we could damage the MAX chip or display
	if (brightness > BRIGHTNESS_MAX)
     646:	8b 35       	cpi	r24, 0x5B	; 91
     648:	10 f0       	brcs	.+4      	; 0x64e <set_vfd_brightness+0xa>
     64a:	9a e5       	ldi	r25, 0x5A	; 90
     64c:	03 c0       	rjmp	.+6      	; 0x654 <set_vfd_brightness+0x10>
		brightness = BRIGHTNESS_MAX;

	// Or so low its not visible
	if (brightness < BRIGHTNESS_MIN)
     64e:	8e 31       	cpi	r24, 0x1E	; 30
     650:	08 f4       	brcc	.+2      	; 0x654 <set_vfd_brightness+0x10>
     652:	9e e1       	ldi	r25, 0x1E	; 30
	//// Round up to the next brightness increment
	//if (brightness % BRIGHTNESS_INCREMENT != 0) {
	//  brightness += BRIGHTNESS_INCREMENT - (brightness % BRIGHTNESS_INCREMENT);
	//}

	if (OCR0A == brightness)
     654:	87 b5       	in	r24, 0x27	; 39
     656:	89 13       	cpse	r24, r25
		return;

	OCR0A = brightness;
     658:	97 bd       	out	0x27, r25	; 39
     65a:	08 95       	ret

0000065c <display_time>:

	}
}

// This displays a time on the clock
void display_time(uint8_t h, uint8_t m, uint8_t s) {
     65c:	1f 93       	push	r17
     65e:	18 2f       	mov	r17, r24
     660:	26 2f       	mov	r18, r22
	 * 	8		32
	 * 		16			1
	 */

	// seconds and minutes are at the end
	display[8] =  pgm_read_byte(numbertable_p + (s % 10));
     662:	84 2f       	mov	r24, r20
     664:	6a e0       	ldi	r22, 0x0A	; 10
     666:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__udivmodqi4>
     66a:	e9 2f       	mov	r30, r25
     66c:	f0 e0       	ldi	r31, 0x00	; 0
     66e:	ec 57       	subi	r30, 0x7C	; 124
     670:	ff 4f       	sbci	r31, 0xFF	; 255
     672:	e4 91       	lpm	r30, Z+
     674:	e0 93 ee 02 	sts	0x02EE, r30
	display[7] =  pgm_read_byte(numbertable_p + (s / 10));
     678:	84 2f       	mov	r24, r20
     67a:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__udivmodqi4>
     67e:	e8 2f       	mov	r30, r24
     680:	f0 e0       	ldi	r31, 0x00	; 0
     682:	ec 57       	subi	r30, 0x7C	; 124
     684:	ff 4f       	sbci	r31, 0xFF	; 255
     686:	e4 91       	lpm	r30, Z+
     688:	e0 93 ed 02 	sts	0x02ED, r30

	switch(secondDisp) {
     68c:	80 91 4e 02 	lds	r24, 0x024E
     690:	83 30       	cpi	r24, 0x03	; 3
     692:	91 f0       	breq	.+36     	; 0x6b8 <display_time+0x5c>
     694:	84 30       	cpi	r24, 0x04	; 4
     696:	28 f4       	brcc	.+10     	; 0x6a2 <display_time+0x46>
     698:	81 30       	cpi	r24, 0x01	; 1
     69a:	91 f0       	breq	.+36     	; 0x6c0 <display_time+0x64>
     69c:	82 30       	cpi	r24, 0x02	; 2
     69e:	50 f4       	brcc	.+20     	; 0x6b4 <display_time+0x58>
     6a0:	07 c0       	rjmp	.+14     	; 0x6b0 <display_time+0x54>
     6a2:	85 30       	cpi	r24, 0x05	; 5
     6a4:	69 f0       	breq	.+26     	; 0x6c0 <display_time+0x64>
     6a6:	85 30       	cpi	r24, 0x05	; 5
     6a8:	48 f0       	brcs	.+18     	; 0x6bc <display_time+0x60>
     6aa:	86 30       	cpi	r24, 0x06	; 6
     6ac:	69 f4       	brne	.+26     	; 0x6c8 <display_time+0x6c>
     6ae:	0a c0       	rjmp	.+20     	; 0x6c4 <display_time+0x68>
		case 0:
			display[3] = 0x08;
     6b0:	88 e0       	ldi	r24, 0x08	; 8
     6b2:	0b c0       	rjmp	.+22     	; 0x6ca <display_time+0x6e>
		case 1:
			display[3] = 0x02;
			display[6] = 0x02;
			break;
		case 2:
			display[3] = 0x40;
     6b4:	80 e4       	ldi	r24, 0x40	; 64
     6b6:	09 c0       	rjmp	.+18     	; 0x6ca <display_time+0x6e>
			display[6] = 0x40;
			break;
		case 3:
			display[3] = 0x80;
     6b8:	80 e8       	ldi	r24, 0x80	; 128
     6ba:	07 c0       	rjmp	.+14     	; 0x6ca <display_time+0x6e>
			display[6] = 0x80;
			break;
		case 4:
			display[3] = 0x04;
     6bc:	84 e0       	ldi	r24, 0x04	; 4
     6be:	05 c0       	rjmp	.+10     	; 0x6ca <display_time+0x6e>
			display[6] = 0x04;
			break;
		case 5:
			display[3] = 0x02;
     6c0:	82 e0       	ldi	r24, 0x02	; 2
     6c2:	03 c0       	rjmp	.+6      	; 0x6ca <display_time+0x6e>
			display[6] = 0x02;
			break;
		case 6:
			display[3] = 0x20;
     6c4:	80 e2       	ldi	r24, 0x20	; 32
     6c6:	01 c0       	rjmp	.+2      	; 0x6ca <display_time+0x6e>
			display[6] = 0x20;
			break;
		default:
			display[3] = 0x10;
     6c8:	80 e1       	ldi	r24, 0x10	; 16
     6ca:	80 93 e9 02 	sts	0x02E9, r24
			display[6] = 0x10;
     6ce:	80 93 ec 02 	sts	0x02EC, r24
	}

	if (secondDisp==7) {
     6d2:	80 91 4e 02 	lds	r24, 0x024E
     6d6:	87 30       	cpi	r24, 0x07	; 7
     6d8:	19 f4       	brne	.+6      	; 0x6e0 <display_time+0x84>
		secondDisp=0;
     6da:	10 92 4e 02 	sts	0x024E, r1
     6de:	05 c0       	rjmp	.+10     	; 0x6ea <display_time+0x8e>
	} else {
		secondDisp+=1;
     6e0:	80 91 4e 02 	lds	r24, 0x024E
     6e4:	8f 5f       	subi	r24, 0xFF	; 255
     6e6:	80 93 4e 02 	sts	0x024E, r24
	}


	display[5] =  pgm_read_byte(numbertable_p + (m % 10));
     6ea:	82 2f       	mov	r24, r18
     6ec:	6a e0       	ldi	r22, 0x0A	; 10
     6ee:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__udivmodqi4>
     6f2:	e9 2f       	mov	r30, r25
     6f4:	f0 e0       	ldi	r31, 0x00	; 0
     6f6:	ec 57       	subi	r30, 0x7C	; 124
     6f8:	ff 4f       	sbci	r31, 0xFF	; 255
     6fa:	e4 91       	lpm	r30, Z+
     6fc:	e0 93 eb 02 	sts	0x02EB, r30
	display[4] =  pgm_read_byte(numbertable_p + (m / 10)); 
     700:	82 2f       	mov	r24, r18
     702:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__udivmodqi4>
     706:	e8 2f       	mov	r30, r24
     708:	f0 e0       	ldi	r31, 0x00	; 0
     70a:	ec 57       	subi	r30, 0x7C	; 124
     70c:	ff 4f       	sbci	r31, 0xFF	; 255
     70e:	e4 91       	lpm	r30, Z+
     710:	e0 93 ea 02 	sts	0x02EA, r30


	// check euro (24h) or US (12h) style time
	if (region == REGION_US) {
     714:	80 91 48 02 	lds	r24, 0x0248
     718:	88 23       	and	r24, r24
     71a:	61 f5       	brne	.+88     	; 0x774 <display_time+0x118>
		display[2] =  pgm_read_byte(numbertable_p + ( (((h+11)%12)+1) % 10));
     71c:	81 2f       	mov	r24, r17
     71e:	90 e0       	ldi	r25, 0x00	; 0
     720:	0b 96       	adiw	r24, 0x0b	; 11
     722:	6c e0       	ldi	r22, 0x0C	; 12
     724:	70 e0       	ldi	r23, 0x00	; 0
     726:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__divmodhi4>
     72a:	9c 01       	movw	r18, r24
     72c:	2f 5f       	subi	r18, 0xFF	; 255
     72e:	3f 4f       	sbci	r19, 0xFF	; 255
     730:	c9 01       	movw	r24, r18
     732:	6a e0       	ldi	r22, 0x0A	; 10
     734:	70 e0       	ldi	r23, 0x00	; 0
     736:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__divmodhi4>
     73a:	fc 01       	movw	r30, r24
     73c:	ec 57       	subi	r30, 0x7C	; 124
     73e:	ff 4f       	sbci	r31, 0xFF	; 255
     740:	e4 91       	lpm	r30, Z+
     742:	e0 93 e8 02 	sts	0x02E8, r30
		display[1] =  pgm_read_byte(numbertable_p + ( (((h+11)%12)+1) / 10));
     746:	c9 01       	movw	r24, r18
     748:	6a e0       	ldi	r22, 0x0A	; 10
     74a:	70 e0       	ldi	r23, 0x00	; 0
     74c:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__divmodhi4>
     750:	fb 01       	movw	r30, r22
     752:	ec 57       	subi	r30, 0x7C	; 124
     754:	ff 4f       	sbci	r31, 0xFF	; 255
     756:	e4 91       	lpm	r30, Z+
     758:	e0 93 e7 02 	sts	0x02E7, r30

		// We use the '*' as an am/pm notice
		if (h >= 12)
     75c:	1c 30       	cpi	r17, 0x0C	; 12
     75e:	20 f0       	brcs	.+8      	; 0x768 <display_time+0x10c>
			display[0] |= 0x1;  // 'pm' notice
     760:	80 91 e6 02 	lds	r24, 0x02E6
     764:	81 60       	ori	r24, 0x01	; 1
     766:	03 c0       	rjmp	.+6      	; 0x76e <display_time+0x112>
		else 
			display[0] &= ~0x1;  // 'pm' notice
     768:	80 91 e6 02 	lds	r24, 0x02E6
     76c:	8e 7f       	andi	r24, 0xFE	; 254
     76e:	80 93 e6 02 	sts	0x02E6, r24
     772:	1a c0       	rjmp	.+52     	; 0x7a8 <display_time+0x14c>
	} else {
		display[2] =  pgm_read_byte(numbertable_p + ( (h%24) % 10));
     774:	81 2f       	mov	r24, r17
     776:	68 e1       	ldi	r22, 0x18	; 24
     778:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__udivmodqi4>
     77c:	29 2f       	mov	r18, r25
     77e:	89 2f       	mov	r24, r25
     780:	6a e0       	ldi	r22, 0x0A	; 10
     782:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__udivmodqi4>
     786:	e9 2f       	mov	r30, r25
     788:	f0 e0       	ldi	r31, 0x00	; 0
     78a:	ec 57       	subi	r30, 0x7C	; 124
     78c:	ff 4f       	sbci	r31, 0xFF	; 255
     78e:	e4 91       	lpm	r30, Z+
     790:	e0 93 e8 02 	sts	0x02E8, r30
		display[1] =  pgm_read_byte(numbertable_p + ( (h%24) / 10));
     794:	82 2f       	mov	r24, r18
     796:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__udivmodqi4>
     79a:	e8 2f       	mov	r30, r24
     79c:	f0 e0       	ldi	r31, 0x00	; 0
     79e:	ec 57       	subi	r30, 0x7C	; 124
     7a0:	ff 4f       	sbci	r31, 0xFF	; 255
     7a2:	e4 91       	lpm	r30, Z+
     7a4:	e0 93 e7 02 	sts	0x02E7, r30
	}
}
     7a8:	1f 91       	pop	r17
     7aa:	08 95       	ret

000007ac <set_time>:
		}
	}
}

void set_time(void) 
{
     7ac:	bf 92       	push	r11
     7ae:	cf 92       	push	r12
     7b0:	df 92       	push	r13
     7b2:	ef 92       	push	r14
     7b4:	ff 92       	push	r15
     7b6:	0f 93       	push	r16
     7b8:	1f 93       	push	r17
     7ba:	cf 93       	push	r28
     7bc:	df 93       	push	r29
	uint8_t mode;
	uint8_t hour, min, sec;

	hour = time_h;
     7be:	e0 90 61 02 	lds	r14, 0x0261
	min = time_m;
     7c2:	f0 90 ef 02 	lds	r15, 0x02EF
	sec = time_s;
     7c6:	00 91 f6 02 	lds	r16, 0x02F6
	mode = SHOW_MENU;

	timeoutcounter = INACTIVITYTIMEOUT;
     7ca:	8a e0       	ldi	r24, 0x0A	; 10
     7cc:	80 93 5c 02 	sts	0x025C, r24
     7d0:	10 e0       	ldi	r17, 0x00	; 0
	while (1) {
		if (just_pressed & 0x1) { // mode change
			return;
		}
		if (just_pressed || pressed) {
			timeoutcounter = INACTIVITYTIMEOUT;  
     7d2:	5a e0       	ldi	r21, 0x0A	; 10
     7d4:	b5 2e       	mov	r11, r21
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
     7d6:	45 e0       	ldi	r20, 0x05	; 5
     7d8:	c4 2e       	mov	r12, r20
     7da:	d1 2c       	mov	r13, r1
	mode = SHOW_MENU;

	timeoutcounter = INACTIVITYTIMEOUT;

	while (1) {
		if (just_pressed & 0x1) { // mode change
     7dc:	c4 e0       	ldi	r28, 0x04	; 4
     7de:	d0 e0       	ldi	r29, 0x00	; 0
     7e0:	80 91 59 02 	lds	r24, 0x0259
     7e4:	80 fd       	sbrc	r24, 0
     7e6:	e5 c0       	rjmp	.+458    	; 0x9b2 <set_time+0x206>
			return;
		}
		if (just_pressed || pressed) {
     7e8:	80 91 59 02 	lds	r24, 0x0259
     7ec:	88 23       	and	r24, r24
     7ee:	21 f4       	brne	.+8      	; 0x7f8 <set_time+0x4c>
     7f0:	80 91 5a 02 	lds	r24, 0x025A
     7f4:	88 23       	and	r24, r24
     7f6:	19 f0       	breq	.+6      	; 0x7fe <set_time+0x52>
			timeoutcounter = INACTIVITYTIMEOUT;  
     7f8:	b0 92 5c 02 	sts	0x025C, r11
     7fc:	05 c0       	rjmp	.+10     	; 0x808 <set_time+0x5c>
			// timeout w/no buttons pressed after 3 seconds?
		} else if (!timeoutcounter) {
     7fe:	80 91 5c 02 	lds	r24, 0x025C
     802:	88 23       	and	r24, r24
     804:	09 f4       	brne	.+2      	; 0x808 <set_time+0x5c>
     806:	4b c0       	rjmp	.+150    	; 0x89e <set_time+0xf2>
			//timed out!
			displaymode = SHOW_TIME;     
			return;
		}
		if (just_pressed & 0x2) {
     808:	80 91 59 02 	lds	r24, 0x0259
     80c:	81 ff       	sbrs	r24, 1
     80e:	4a c0       	rjmp	.+148    	; 0x8a4 <set_time+0xf8>
			just_pressed = 0;
     810:	10 92 59 02 	sts	0x0259, r1
			if (mode == SHOW_MENU) {
     814:	11 23       	and	r17, r17
     816:	b9 f4       	brne	.+46     	; 0x846 <set_time+0x9a>
				hour = time_h;
     818:	e0 90 61 02 	lds	r14, 0x0261
				min = time_m;
     81c:	f0 90 ef 02 	lds	r15, 0x02EF
				sec = time_s;
     820:	00 91 f6 02 	lds	r16, 0x02F6

				// ok now its selected
				mode = SET_HOUR;
				display_time(hour, min, sec);
     824:	8e 2d       	mov	r24, r14
     826:	6f 2d       	mov	r22, r15
     828:	40 2f       	mov	r20, r16
     82a:	0e 94 2e 03 	call	0x65c	; 0x65c <display_time>
				display[1] |= 0x1;
     82e:	80 91 e7 02 	lds	r24, 0x02E7
     832:	81 60       	ori	r24, 0x01	; 1
     834:	80 93 e7 02 	sts	0x02E7, r24
				display[2] |= 0x1;	
     838:	80 91 e8 02 	lds	r24, 0x02E8
     83c:	81 60       	ori	r24, 0x01	; 1
     83e:	80 93 e8 02 	sts	0x02E8, r24
     842:	11 e0       	ldi	r17, 0x01	; 1
     844:	2f c0       	rjmp	.+94     	; 0x8a4 <set_time+0xf8>
			} else if (mode == SET_HOUR) {
     846:	11 30       	cpi	r17, 0x01	; 1
     848:	89 f4       	brne	.+34     	; 0x86c <set_time+0xc0>
				mode = SET_MIN;
				display_time(hour, min, sec);
     84a:	8e 2d       	mov	r24, r14
     84c:	6f 2d       	mov	r22, r15
     84e:	40 2f       	mov	r20, r16
     850:	0e 94 2e 03 	call	0x65c	; 0x65c <display_time>
				display[4] |= 0x1;
     854:	80 91 ea 02 	lds	r24, 0x02EA
     858:	81 60       	ori	r24, 0x01	; 1
     85a:	80 93 ea 02 	sts	0x02EA, r24
				display[5] |= 0x1;
     85e:	80 91 eb 02 	lds	r24, 0x02EB
     862:	81 60       	ori	r24, 0x01	; 1
     864:	80 93 eb 02 	sts	0x02EB, r24
     868:	12 e0       	ldi	r17, 0x02	; 2
     86a:	1c c0       	rjmp	.+56     	; 0x8a4 <set_time+0xf8>
			} else if (mode == SET_MIN) {
     86c:	12 30       	cpi	r17, 0x02	; 2
     86e:	89 f4       	brne	.+34     	; 0x892 <set_time+0xe6>
				mode = SET_SEC;
				display_time(hour, min, sec);
     870:	8e 2d       	mov	r24, r14
     872:	6f 2d       	mov	r22, r15
     874:	40 2f       	mov	r20, r16
     876:	0e 94 2e 03 	call	0x65c	; 0x65c <display_time>
				display[7] |= 0x1;
     87a:	80 91 ed 02 	lds	r24, 0x02ED
     87e:	81 60       	ori	r24, 0x01	; 1
     880:	80 93 ed 02 	sts	0x02ED, r24
				display[8] |= 0x1;
     884:	80 91 ee 02 	lds	r24, 0x02EE
     888:	81 60       	ori	r24, 0x01	; 1
     88a:	80 93 ee 02 	sts	0x02EE, r24
     88e:	13 e0       	ldi	r17, 0x03	; 3
     890:	09 c0       	rjmp	.+18     	; 0x8a4 <set_time+0xf8>
			} else {
				// done!
				time_h = hour;
     892:	e0 92 61 02 	sts	0x0261, r14
				time_m = min;
     896:	f0 92 ef 02 	sts	0x02EF, r15
				time_s = sec;
     89a:	00 93 f6 02 	sts	0x02F6, r16
				displaymode = SHOW_TIME;
     89e:	10 92 f4 02 	sts	0x02F4, r1
     8a2:	87 c0       	rjmp	.+270    	; 0x9b2 <set_time+0x206>
				return;
			}
		}
		if ((just_pressed & 0x4) || (pressed & 0x4)) {
     8a4:	80 91 59 02 	lds	r24, 0x0259
     8a8:	82 fd       	sbrc	r24, 2
     8aa:	04 c0       	rjmp	.+8      	; 0x8b4 <set_time+0x108>
     8ac:	80 91 5a 02 	lds	r24, 0x025A
     8b0:	82 ff       	sbrs	r24, 2
     8b2:	96 cf       	rjmp	.-212    	; 0x7e0 <set_time+0x34>
			just_pressed = 0;
     8b4:	10 92 59 02 	sts	0x0259, r1

			if (mode == SET_HOUR) {
     8b8:	11 30       	cpi	r17, 0x01	; 1
     8ba:	31 f5       	brne	.+76     	; 0x908 <set_time+0x15c>
				hour = (hour+1) % 24;
     8bc:	8e 2d       	mov	r24, r14
     8be:	90 e0       	ldi	r25, 0x00	; 0
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	68 e1       	ldi	r22, 0x18	; 24
     8c4:	70 e0       	ldi	r23, 0x00	; 0
     8c6:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__divmodhi4>
     8ca:	e8 2e       	mov	r14, r24
				display_time(hour, min, sec);
     8cc:	6f 2d       	mov	r22, r15
     8ce:	40 2f       	mov	r20, r16
     8d0:	0e 94 2e 03 	call	0x65c	; 0x65c <display_time>
				display[1] |= 0x1;
     8d4:	80 91 e7 02 	lds	r24, 0x02E7
     8d8:	81 60       	ori	r24, 0x01	; 1
     8da:	80 93 e7 02 	sts	0x02E7, r24
				display[2] |= 0x1;
     8de:	80 91 e8 02 	lds	r24, 0x02E8
     8e2:	81 60       	ori	r24, 0x01	; 1
     8e4:	80 93 e8 02 	sts	0x02E8, r24
				time_h = hour;
     8e8:	e0 92 61 02 	sts	0x0261, r14
				eeprom_write_byte((uint8_t *)EE_HOUR, time_h);    
     8ec:	80 91 61 02 	lds	r24, 0x0261
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
     8f0:	f9 99       	sbic	0x1f, 1	; 31
     8f2:	fe cf       	rjmp	.-4      	; 0x8f0 <set_time+0x144>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     8f4:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
     8f6:	d2 bd       	out	0x22, r29	; 34
     8f8:	c1 bd       	out	0x21, r28	; 33
#endif
    EEDR = __value;
     8fa:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
     8fc:	0f b6       	in	r0, 0x3f	; 63
     8fe:	f8 94       	cli
     900:	fa 9a       	sbi	0x1f, 2	; 31
     902:	f9 9a       	sbi	0x1f, 1	; 31
     904:	0f be       	out	0x3f, r0	; 63
     906:	44 c0       	rjmp	.+136    	; 0x990 <set_time+0x1e4>
			}
			if (mode == SET_MIN) {
     908:	12 30       	cpi	r17, 0x02	; 2
     90a:	39 f5       	brne	.+78     	; 0x95a <set_time+0x1ae>
				min = (min+1) % 60;
     90c:	8f 2d       	mov	r24, r15
     90e:	90 e0       	ldi	r25, 0x00	; 0
     910:	01 96       	adiw	r24, 0x01	; 1
     912:	6c e3       	ldi	r22, 0x3C	; 60
     914:	70 e0       	ldi	r23, 0x00	; 0
     916:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__divmodhi4>
     91a:	f8 2e       	mov	r15, r24
				display_time(hour, min, sec);
     91c:	8e 2d       	mov	r24, r14
     91e:	6f 2d       	mov	r22, r15
     920:	40 2f       	mov	r20, r16
     922:	0e 94 2e 03 	call	0x65c	; 0x65c <display_time>
				display[4] |= 0x1;
     926:	80 91 ea 02 	lds	r24, 0x02EA
     92a:	81 60       	ori	r24, 0x01	; 1
     92c:	80 93 ea 02 	sts	0x02EA, r24
				display[5] |= 0x1;
     930:	80 91 eb 02 	lds	r24, 0x02EB
     934:	81 60       	ori	r24, 0x01	; 1
     936:	80 93 eb 02 	sts	0x02EB, r24
				eeprom_write_byte((uint8_t *)EE_MIN, time_m);
     93a:	80 91 ef 02 	lds	r24, 0x02EF
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
     93e:	f9 99       	sbic	0x1f, 1	; 31
     940:	fe cf       	rjmp	.-4      	; 0x93e <set_time+0x192>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     942:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
     944:	d2 bc       	out	0x22, r13	; 34
     946:	c1 bc       	out	0x21, r12	; 33
#endif
    EEDR = __value;
     948:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
     94a:	0f b6       	in	r0, 0x3f	; 63
     94c:	f8 94       	cli
     94e:	fa 9a       	sbi	0x1f, 2	; 31
     950:	f9 9a       	sbi	0x1f, 1	; 31
     952:	0f be       	out	0x3f, r0	; 63
				time_m = min;
     954:	f0 92 ef 02 	sts	0x02EF, r15
     958:	1b c0       	rjmp	.+54     	; 0x990 <set_time+0x1e4>
			}
			if ((mode == SET_SEC) ) {
     95a:	13 30       	cpi	r17, 0x03	; 3
     95c:	c9 f4       	brne	.+50     	; 0x990 <set_time+0x1e4>
				sec = (sec+1) % 60;
     95e:	80 2f       	mov	r24, r16
     960:	90 e0       	ldi	r25, 0x00	; 0
     962:	01 96       	adiw	r24, 0x01	; 1
     964:	6c e3       	ldi	r22, 0x3C	; 60
     966:	70 e0       	ldi	r23, 0x00	; 0
     968:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__divmodhi4>
     96c:	08 2f       	mov	r16, r24
				display_time(hour, min, sec);
     96e:	8e 2d       	mov	r24, r14
     970:	6f 2d       	mov	r22, r15
     972:	40 2f       	mov	r20, r16
     974:	0e 94 2e 03 	call	0x65c	; 0x65c <display_time>
				display[7] |= 0x1;
     978:	80 91 ed 02 	lds	r24, 0x02ED
     97c:	81 60       	ori	r24, 0x01	; 1
     97e:	80 93 ed 02 	sts	0x02ED, r24
				display[8] |= 0x1;
     982:	80 91 ee 02 	lds	r24, 0x02EE
     986:	81 60       	ori	r24, 0x01	; 1
     988:	80 93 ee 02 	sts	0x02EE, r24
				time_s = sec;
     98c:	00 93 f6 02 	sts	0x02F6, r16
			}

			if (pressed & 0x4)
     990:	80 91 5a 02 	lds	r24, 0x025A
     994:	82 ff       	sbrs	r24, 2
     996:	24 cf       	rjmp	.-440    	; 0x7e0 <set_time+0x34>

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
     998:	78 94       	sei

	milliseconds = 0;
     99a:	10 92 57 02 	sts	0x0257, r1
     99e:	10 92 56 02 	sts	0x0256, r1
	while (milliseconds < ms);
     9a2:	80 91 56 02 	lds	r24, 0x0256
     9a6:	90 91 57 02 	lds	r25, 0x0257
     9aa:	8b 34       	cpi	r24, 0x4B	; 75
     9ac:	91 05       	cpc	r25, r1
     9ae:	c8 f3       	brcs	.-14     	; 0x9a2 <set_time+0x1f6>
     9b0:	17 cf       	rjmp	.-466    	; 0x7e0 <set_time+0x34>

			if (pressed & 0x4)
				delayms(75);
		}
	}
}
     9b2:	df 91       	pop	r29
     9b4:	cf 91       	pop	r28
     9b6:	1f 91       	pop	r17
     9b8:	0f 91       	pop	r16
     9ba:	ff 90       	pop	r15
     9bc:	ef 90       	pop	r14
     9be:	df 90       	pop	r13
     9c0:	cf 90       	pop	r12
     9c2:	bf 90       	pop	r11
     9c4:	08 95       	ret

000009c6 <display_alarm>:
		display[1] =  pgm_read_byte(numbertable_p + ( (h%24) / 10));
	}
}

// Kinda like display_time but just hours and minutes
void display_alarm(uint8_t h, uint8_t m){ 
     9c6:	38 2f       	mov	r19, r24
     9c8:	26 2f       	mov	r18, r22
	display[8] = 0;
     9ca:	10 92 ee 02 	sts	0x02EE, r1
	display[7] = 0;
     9ce:	10 92 ed 02 	sts	0x02ED, r1
	display[6] = 0;
     9d2:	10 92 ec 02 	sts	0x02EC, r1
	display[5] = pgm_read_byte(numbertable_p + (m % 10));
     9d6:	86 2f       	mov	r24, r22
     9d8:	6a e0       	ldi	r22, 0x0A	; 10
     9da:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__udivmodqi4>
     9de:	e9 2f       	mov	r30, r25
     9e0:	f0 e0       	ldi	r31, 0x00	; 0
     9e2:	ec 57       	subi	r30, 0x7C	; 124
     9e4:	ff 4f       	sbci	r31, 0xFF	; 255
     9e6:	e4 91       	lpm	r30, Z+
     9e8:	e0 93 eb 02 	sts	0x02EB, r30
	display[4] = pgm_read_byte(numbertable_p + (m / 10)); 
     9ec:	82 2f       	mov	r24, r18
     9ee:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__udivmodqi4>
     9f2:	e8 2f       	mov	r30, r24
     9f4:	f0 e0       	ldi	r31, 0x00	; 0
     9f6:	ec 57       	subi	r30, 0x7C	; 124
     9f8:	ff 4f       	sbci	r31, 0xFF	; 255
     9fa:	e4 91       	lpm	r30, Z+
     9fc:	e0 93 ea 02 	sts	0x02EA, r30
	display[3] = 0;
     a00:	10 92 e9 02 	sts	0x02E9, r1

	// check euro or US style time
	if (region == REGION_US) {
     a04:	80 91 48 02 	lds	r24, 0x0248
     a08:	88 23       	and	r24, r24
     a0a:	09 f0       	breq	.+2      	; 0xa0e <display_alarm+0x48>
     a0c:	3b c0       	rjmp	.+118    	; 0xa84 <display_alarm+0xbe>
		if (h >= 12) {
     a0e:	3c 30       	cpi	r19, 0x0C	; 12
     a10:	58 f0       	brcs	.+22     	; 0xa28 <display_alarm+0x62>
			display[0] |= 0x1;  // 'pm' notice
     a12:	80 91 e6 02 	lds	r24, 0x02E6
     a16:	81 60       	ori	r24, 0x01	; 1
     a18:	80 93 e6 02 	sts	0x02E6, r24
			display[7] = pgm_read_byte(alphatable_p + 'p' - 'a');
     a1c:	e7 e7       	ldi	r30, 0x77	; 119
     a1e:	f0 e0       	ldi	r31, 0x00	; 0
     a20:	e4 91       	lpm	r30, Z+
     a22:	e0 93 ed 02 	sts	0x02ED, r30
     a26:	0a c0       	rjmp	.+20     	; 0xa3c <display_alarm+0x76>
		} else {
			display[7] = pgm_read_byte(alphatable_p + 'a' - 'a');
     a28:	e8 e6       	ldi	r30, 0x68	; 104
     a2a:	f0 e0       	ldi	r31, 0x00	; 0
     a2c:	e4 91       	lpm	r30, Z+
     a2e:	e0 93 ed 02 	sts	0x02ED, r30
			display[0] &= ~0x1;  // 'am' notice
     a32:	80 91 e6 02 	lds	r24, 0x02E6
     a36:	8e 7f       	andi	r24, 0xFE	; 254
     a38:	80 93 e6 02 	sts	0x02E6, r24
		}
		display[8] = pgm_read_byte(alphatable_p + 'm' - 'a');
     a3c:	e4 e7       	ldi	r30, 0x74	; 116
     a3e:	f0 e0       	ldi	r31, 0x00	; 0
     a40:	e4 91       	lpm	r30, Z+
     a42:	e0 93 ee 02 	sts	0x02EE, r30

		display[2] =  pgm_read_byte(numbertable_p + ( (((h+11)%12)+1) % 10));
     a46:	83 2f       	mov	r24, r19
     a48:	90 e0       	ldi	r25, 0x00	; 0
     a4a:	0b 96       	adiw	r24, 0x0b	; 11
     a4c:	6c e0       	ldi	r22, 0x0C	; 12
     a4e:	70 e0       	ldi	r23, 0x00	; 0
     a50:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__divmodhi4>
     a54:	9c 01       	movw	r18, r24
     a56:	2f 5f       	subi	r18, 0xFF	; 255
     a58:	3f 4f       	sbci	r19, 0xFF	; 255
     a5a:	c9 01       	movw	r24, r18
     a5c:	6a e0       	ldi	r22, 0x0A	; 10
     a5e:	70 e0       	ldi	r23, 0x00	; 0
     a60:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__divmodhi4>
     a64:	fc 01       	movw	r30, r24
     a66:	ec 57       	subi	r30, 0x7C	; 124
     a68:	ff 4f       	sbci	r31, 0xFF	; 255
     a6a:	e4 91       	lpm	r30, Z+
     a6c:	e0 93 e8 02 	sts	0x02E8, r30
		display[1] =  pgm_read_byte(numbertable_p + ( (((h+11)%12)+1) / 10));
     a70:	c9 01       	movw	r24, r18
     a72:	6a e0       	ldi	r22, 0x0A	; 10
     a74:	70 e0       	ldi	r23, 0x00	; 0
     a76:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__divmodhi4>
     a7a:	fb 01       	movw	r30, r22
     a7c:	ec 57       	subi	r30, 0x7C	; 124
     a7e:	ff 4f       	sbci	r31, 0xFF	; 255
     a80:	e4 91       	lpm	r30, Z+
     a82:	1e c0       	rjmp	.+60     	; 0xac0 <display_alarm+0xfa>
	} else {
		display[2] =  pgm_read_byte(numbertable_p + ( (((h+23)%24)+1) % 10));
     a84:	83 2f       	mov	r24, r19
     a86:	90 e0       	ldi	r25, 0x00	; 0
     a88:	47 96       	adiw	r24, 0x17	; 23
     a8a:	68 e1       	ldi	r22, 0x18	; 24
     a8c:	70 e0       	ldi	r23, 0x00	; 0
     a8e:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__divmodhi4>
     a92:	9c 01       	movw	r18, r24
     a94:	2f 5f       	subi	r18, 0xFF	; 255
     a96:	3f 4f       	sbci	r19, 0xFF	; 255
     a98:	c9 01       	movw	r24, r18
     a9a:	6a e0       	ldi	r22, 0x0A	; 10
     a9c:	70 e0       	ldi	r23, 0x00	; 0
     a9e:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__divmodhi4>
     aa2:	fc 01       	movw	r30, r24
     aa4:	ec 57       	subi	r30, 0x7C	; 124
     aa6:	ff 4f       	sbci	r31, 0xFF	; 255
     aa8:	e4 91       	lpm	r30, Z+
     aaa:	e0 93 e8 02 	sts	0x02E8, r30
		display[1] =  pgm_read_byte(numbertable_p + ( (((h+23)%24)+1) / 10));
     aae:	c9 01       	movw	r24, r18
     ab0:	6a e0       	ldi	r22, 0x0A	; 10
     ab2:	70 e0       	ldi	r23, 0x00	; 0
     ab4:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__divmodhi4>
     ab8:	fb 01       	movw	r30, r22
     aba:	ec 57       	subi	r30, 0x7C	; 124
     abc:	ff 4f       	sbci	r31, 0xFF	; 255
     abe:	e4 91       	lpm	r30, Z+
     ac0:	e0 93 e7 02 	sts	0x02E7, r30
     ac4:	08 95       	ret

00000ac6 <set_alarm>:
}

/**************************** SUB-MENUS *****************************/

void set_alarm(void) 
{
     ac6:	ef 92       	push	r14
     ac8:	ff 92       	push	r15
     aca:	0f 93       	push	r16
     acc:	1f 93       	push	r17
	uint8_t hour, min, sec;

	hour = min = sec = 0;
	mode = SHOW_MENU;

	hour = alarm_h;
     ace:	10 91 f1 02 	lds	r17, 0x02F1
	min = alarm_m;
     ad2:	00 91 e3 02 	lds	r16, 0x02E3
	sec = 0;

	timeoutcounter = INACTIVITYTIMEOUT;
     ad6:	8a e0       	ldi	r24, 0x0A	; 10
     ad8:	80 93 5c 02 	sts	0x025C, r24
     adc:	ff 24       	eor	r15, r15
	while (1) {
		if (just_pressed & 0x1) { // mode change
			return;
		}
		if (just_pressed || pressed) {
			timeoutcounter = INACTIVITYTIMEOUT;  
     ade:	7a e0       	ldi	r23, 0x0A	; 10
     ae0:	e7 2e       	mov	r14, r23
	sec = 0;

	timeoutcounter = INACTIVITYTIMEOUT;

	while (1) {
		if (just_pressed & 0x1) { // mode change
     ae2:	80 91 59 02 	lds	r24, 0x0259
     ae6:	80 fd       	sbrc	r24, 0
     ae8:	d3 c0       	rjmp	.+422    	; 0xc90 <set_alarm+0x1ca>
			return;
		}
		if (just_pressed || pressed) {
     aea:	80 91 59 02 	lds	r24, 0x0259
     aee:	88 23       	and	r24, r24
     af0:	21 f4       	brne	.+8      	; 0xafa <set_alarm+0x34>
     af2:	80 91 5a 02 	lds	r24, 0x025A
     af6:	88 23       	and	r24, r24
     af8:	19 f0       	breq	.+6      	; 0xb00 <set_alarm+0x3a>
			timeoutcounter = INACTIVITYTIMEOUT;  
     afa:	e0 92 5c 02 	sts	0x025C, r14
     afe:	29 c0       	rjmp	.+82     	; 0xb52 <set_alarm+0x8c>
			// timeout w/no buttons pressed after 3 seconds?
		} else if (!timeoutcounter) {
     b00:	80 91 5c 02 	lds	r24, 0x025C
     b04:	88 23       	and	r24, r24
     b06:	29 f5       	brne	.+74     	; 0xb52 <set_alarm+0x8c>
			//timed out!
			displaymode = SHOW_TIME;     
     b08:	10 92 f4 02 	sts	0x02F4, r1
			alarm_h = hour;
     b0c:	10 93 f1 02 	sts	0x02F1, r17
			alarm_m = min;
     b10:	00 93 e3 02 	sts	0x02E3, r16
			eeprom_write_byte((uint8_t *)EE_ALARM_HOUR, alarm_h);    
     b14:	20 91 f1 02 	lds	r18, 0x02F1
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
     b18:	f9 99       	sbic	0x1f, 1	; 31
     b1a:	fe cf       	rjmp	.-4      	; 0xb18 <set_alarm+0x52>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     b1c:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
     b1e:	87 e0       	ldi	r24, 0x07	; 7
     b20:	90 e0       	ldi	r25, 0x00	; 0
     b22:	92 bd       	out	0x22, r25	; 34
     b24:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
     b26:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
     b28:	0f b6       	in	r0, 0x3f	; 63
     b2a:	f8 94       	cli
     b2c:	fa 9a       	sbi	0x1f, 2	; 31
     b2e:	f9 9a       	sbi	0x1f, 1	; 31
     b30:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte((uint8_t *)EE_ALARM_MIN, alarm_m);    
     b32:	20 91 e3 02 	lds	r18, 0x02E3
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
     b36:	f9 99       	sbic	0x1f, 1	; 31
     b38:	fe cf       	rjmp	.-4      	; 0xb36 <set_alarm+0x70>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     b3a:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
     b3c:	88 e0       	ldi	r24, 0x08	; 8
     b3e:	90 e0       	ldi	r25, 0x00	; 0
     b40:	92 bd       	out	0x22, r25	; 34
     b42:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
     b44:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
     b46:	0f b6       	in	r0, 0x3f	; 63
     b48:	f8 94       	cli
     b4a:	fa 9a       	sbi	0x1f, 2	; 31
     b4c:	f9 9a       	sbi	0x1f, 1	; 31
     b4e:	0f be       	out	0x3f, r0	; 63
     b50:	9f c0       	rjmp	.+318    	; 0xc90 <set_alarm+0x1ca>
			return;
		}
		if (just_pressed & 0x2) {
     b52:	80 91 59 02 	lds	r24, 0x0259
     b56:	81 ff       	sbrs	r24, 1
     b58:	4e c0       	rjmp	.+156    	; 0xbf6 <set_alarm+0x130>
			just_pressed = 0;
     b5a:	10 92 59 02 	sts	0x0259, r1
			if (mode == SHOW_MENU) {
     b5e:	ff 20       	and	r15, r15
     b60:	89 f4       	brne	.+34     	; 0xb84 <set_alarm+0xbe>
				// ok now its selected
				mode = SET_HOUR;
				display_alarm(hour, min);
     b62:	81 2f       	mov	r24, r17
     b64:	60 2f       	mov	r22, r16
     b66:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <display_alarm>
				display[1] |= 0x1;
     b6a:	80 91 e7 02 	lds	r24, 0x02E7
     b6e:	81 60       	ori	r24, 0x01	; 1
     b70:	80 93 e7 02 	sts	0x02E7, r24
				display[2] |= 0x1;	
     b74:	80 91 e8 02 	lds	r24, 0x02E8
     b78:	81 60       	ori	r24, 0x01	; 1
     b7a:	80 93 e8 02 	sts	0x02E8, r24
     b7e:	ff 24       	eor	r15, r15
     b80:	f3 94       	inc	r15
     b82:	39 c0       	rjmp	.+114    	; 0xbf6 <set_alarm+0x130>
			} else if (mode == SET_HOUR) {
     b84:	81 e0       	ldi	r24, 0x01	; 1
     b86:	f8 16       	cp	r15, r24
     b88:	89 f4       	brne	.+34     	; 0xbac <set_alarm+0xe6>
				mode = SET_MIN;
				display_alarm(hour, min);
     b8a:	81 2f       	mov	r24, r17
     b8c:	60 2f       	mov	r22, r16
     b8e:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <display_alarm>
				display[4] |= 0x1;
     b92:	80 91 ea 02 	lds	r24, 0x02EA
     b96:	81 60       	ori	r24, 0x01	; 1
     b98:	80 93 ea 02 	sts	0x02EA, r24
				display[5] |= 0x1;
     b9c:	80 91 eb 02 	lds	r24, 0x02EB
     ba0:	81 60       	ori	r24, 0x01	; 1
     ba2:	80 93 eb 02 	sts	0x02EB, r24
     ba6:	62 e0       	ldi	r22, 0x02	; 2
     ba8:	f6 2e       	mov	r15, r22
     baa:	25 c0       	rjmp	.+74     	; 0xbf6 <set_alarm+0x130>
			} else {
				// done!
				alarm_h = hour;
     bac:	10 93 f1 02 	sts	0x02F1, r17
				alarm_m = min;
     bb0:	00 93 e3 02 	sts	0x02E3, r16
				eeprom_write_byte((uint8_t *)EE_ALARM_HOUR, alarm_h);    
     bb4:	20 91 f1 02 	lds	r18, 0x02F1
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
     bb8:	f9 99       	sbic	0x1f, 1	; 31
     bba:	fe cf       	rjmp	.-4      	; 0xbb8 <set_alarm+0xf2>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     bbc:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
     bbe:	87 e0       	ldi	r24, 0x07	; 7
     bc0:	90 e0       	ldi	r25, 0x00	; 0
     bc2:	92 bd       	out	0x22, r25	; 34
     bc4:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
     bc6:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
     bc8:	0f b6       	in	r0, 0x3f	; 63
     bca:	f8 94       	cli
     bcc:	fa 9a       	sbi	0x1f, 2	; 31
     bce:	f9 9a       	sbi	0x1f, 1	; 31
     bd0:	0f be       	out	0x3f, r0	; 63
				eeprom_write_byte((uint8_t *)EE_ALARM_MIN, alarm_m);    
     bd2:	20 91 e3 02 	lds	r18, 0x02E3
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
     bd6:	f9 99       	sbic	0x1f, 1	; 31
     bd8:	fe cf       	rjmp	.-4      	; 0xbd6 <set_alarm+0x110>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     bda:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
     bdc:	88 e0       	ldi	r24, 0x08	; 8
     bde:	90 e0       	ldi	r25, 0x00	; 0
     be0:	92 bd       	out	0x22, r25	; 34
     be2:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
     be4:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
     be6:	0f b6       	in	r0, 0x3f	; 63
     be8:	f8 94       	cli
     bea:	fa 9a       	sbi	0x1f, 2	; 31
     bec:	f9 9a       	sbi	0x1f, 1	; 31
     bee:	0f be       	out	0x3f, r0	; 63
				displaymode = SHOW_TIME;
     bf0:	10 92 f4 02 	sts	0x02F4, r1
     bf4:	4d c0       	rjmp	.+154    	; 0xc90 <set_alarm+0x1ca>
				return;
			}
		}
		if ((just_pressed & 0x4) || (pressed & 0x4)) {
     bf6:	80 91 59 02 	lds	r24, 0x0259
     bfa:	82 fd       	sbrc	r24, 2
     bfc:	04 c0       	rjmp	.+8      	; 0xc06 <set_alarm+0x140>
     bfe:	80 91 5a 02 	lds	r24, 0x025A
     c02:	82 ff       	sbrs	r24, 2
     c04:	6e cf       	rjmp	.-292    	; 0xae2 <set_alarm+0x1c>
			just_pressed = 0;
     c06:	10 92 59 02 	sts	0x0259, r1

			if (mode == SET_HOUR) {
     c0a:	81 e0       	ldi	r24, 0x01	; 1
     c0c:	f8 16       	cp	r15, r24
     c0e:	b1 f4       	brne	.+44     	; 0xc3c <set_alarm+0x176>
				hour = (hour+1) % 24;
     c10:	81 2f       	mov	r24, r17
     c12:	90 e0       	ldi	r25, 0x00	; 0
     c14:	01 96       	adiw	r24, 0x01	; 1
     c16:	68 e1       	ldi	r22, 0x18	; 24
     c18:	70 e0       	ldi	r23, 0x00	; 0
     c1a:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__divmodhi4>
     c1e:	18 2f       	mov	r17, r24
				display_alarm(hour, min);
     c20:	60 2f       	mov	r22, r16
     c22:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <display_alarm>
				display[1] |= 0x1;
     c26:	80 91 e7 02 	lds	r24, 0x02E7
     c2a:	81 60       	ori	r24, 0x01	; 1
     c2c:	80 93 e7 02 	sts	0x02E7, r24
				display[2] |= 0x1;
     c30:	80 91 e8 02 	lds	r24, 0x02E8
     c34:	81 60       	ori	r24, 0x01	; 1
     c36:	80 93 e8 02 	sts	0x02E8, r24
     c3a:	19 c0       	rjmp	.+50     	; 0xc6e <set_alarm+0x1a8>
			}
			if (mode == SET_MIN) {
     c3c:	82 e0       	ldi	r24, 0x02	; 2
     c3e:	f8 16       	cp	r15, r24
     c40:	b1 f4       	brne	.+44     	; 0xc6e <set_alarm+0x1a8>
				min = (min+1) % 60;
     c42:	80 2f       	mov	r24, r16
     c44:	90 e0       	ldi	r25, 0x00	; 0
     c46:	01 96       	adiw	r24, 0x01	; 1
     c48:	6c e3       	ldi	r22, 0x3C	; 60
     c4a:	70 e0       	ldi	r23, 0x00	; 0
     c4c:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__divmodhi4>
     c50:	08 2f       	mov	r16, r24
				display_alarm(hour, min);
     c52:	81 2f       	mov	r24, r17
     c54:	60 2f       	mov	r22, r16
     c56:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <display_alarm>
				display[4] |= 0x1;
     c5a:	80 91 ea 02 	lds	r24, 0x02EA
     c5e:	81 60       	ori	r24, 0x01	; 1
     c60:	80 93 ea 02 	sts	0x02EA, r24
				display[5] |= 0x1;
     c64:	80 91 eb 02 	lds	r24, 0x02EB
     c68:	81 60       	ori	r24, 0x01	; 1
     c6a:	80 93 eb 02 	sts	0x02EB, r24
			}

			if (pressed & 0x4)
     c6e:	80 91 5a 02 	lds	r24, 0x025A
     c72:	82 ff       	sbrs	r24, 2
     c74:	36 cf       	rjmp	.-404    	; 0xae2 <set_alarm+0x1c>

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
     c76:	78 94       	sei

	milliseconds = 0;
     c78:	10 92 57 02 	sts	0x0257, r1
     c7c:	10 92 56 02 	sts	0x0256, r1
	while (milliseconds < ms);
     c80:	80 91 56 02 	lds	r24, 0x0256
     c84:	90 91 57 02 	lds	r25, 0x0257
     c88:	8b 34       	cpi	r24, 0x4B	; 75
     c8a:	91 05       	cpc	r25, r1
     c8c:	c8 f3       	brcs	.-14     	; 0xc80 <set_alarm+0x1ba>
     c8e:	29 cf       	rjmp	.-430    	; 0xae2 <set_alarm+0x1c>

			if (pressed & 0x4)
				delayms(75);
		}
	}
}
     c90:	1f 91       	pop	r17
     c92:	0f 91       	pop	r16
     c94:	ff 90       	pop	r15
     c96:	ef 90       	pop	r14
     c98:	08 95       	ret

00000c9a <display_timezone>:
		display[1] =  pgm_read_byte(numbertable_p + ( (((h+23)%24)+1) / 10));
	}
}

// Kinda like display_time but just hours and minutes allows negative hours.
void display_timezone(int8_t h, uint8_t m){ 
     c9a:	48 2f       	mov	r20, r24
     c9c:	26 2f       	mov	r18, r22
	display[8] = pgm_read_byte(alphatable_p + 'c' - 'a');
     c9e:	ea e6       	ldi	r30, 0x6A	; 106
     ca0:	f0 e0       	ldi	r31, 0x00	; 0
     ca2:	84 91       	lpm	r24, Z+
     ca4:	80 93 ee 02 	sts	0x02EE, r24
	display[7] = pgm_read_byte(alphatable_p + 't' - 'a');
     ca8:	71 96       	adiw	r30, 0x11	; 17
     caa:	84 91       	lpm	r24, Z+
     cac:	80 93 ed 02 	sts	0x02ED, r24
	display[6] = pgm_read_byte(alphatable_p + 'u' - 'a');
     cb0:	31 96       	adiw	r30, 0x01	; 1
     cb2:	e4 91       	lpm	r30, Z+
     cb4:	e0 93 ec 02 	sts	0x02EC, r30
	display[5] = pgm_read_byte(numbertable_p + (m % 10));
     cb8:	86 2f       	mov	r24, r22
     cba:	6a e0       	ldi	r22, 0x0A	; 10
     cbc:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__udivmodqi4>
     cc0:	e9 2f       	mov	r30, r25
     cc2:	f0 e0       	ldi	r31, 0x00	; 0
     cc4:	ec 57       	subi	r30, 0x7C	; 124
     cc6:	ff 4f       	sbci	r31, 0xFF	; 255
     cc8:	e4 91       	lpm	r30, Z+
     cca:	e0 93 eb 02 	sts	0x02EB, r30
	display[4] = pgm_read_byte(numbertable_p + (m / 10)); 
     cce:	82 2f       	mov	r24, r18
     cd0:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__udivmodqi4>
     cd4:	e8 2f       	mov	r30, r24
     cd6:	f0 e0       	ldi	r31, 0x00	; 0
     cd8:	ec 57       	subi	r30, 0x7C	; 124
     cda:	ff 4f       	sbci	r31, 0xFF	; 255
     cdc:	e4 91       	lpm	r30, Z+
     cde:	e0 93 ea 02 	sts	0x02EA, r30
	display[3] = 0;
     ce2:	10 92 e9 02 	sts	0x02E9, r1
	display[2] = pgm_read_byte(numbertable_p + (abs(h) % 10));
     ce6:	24 2f       	mov	r18, r20
     ce8:	33 27       	eor	r19, r19
     cea:	27 fd       	sbrc	r18, 7
     cec:	30 95       	com	r19
     cee:	37 ff       	sbrs	r19, 7
     cf0:	03 c0       	rjmp	.+6      	; 0xcf8 <display_timezone+0x5e>
     cf2:	30 95       	com	r19
     cf4:	21 95       	neg	r18
     cf6:	3f 4f       	sbci	r19, 0xFF	; 255
     cf8:	c9 01       	movw	r24, r18
     cfa:	6a e0       	ldi	r22, 0x0A	; 10
     cfc:	70 e0       	ldi	r23, 0x00	; 0
     cfe:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__divmodhi4>
     d02:	fc 01       	movw	r30, r24
     d04:	ec 57       	subi	r30, 0x7C	; 124
     d06:	ff 4f       	sbci	r31, 0xFF	; 255
     d08:	e4 91       	lpm	r30, Z+
     d0a:	e0 93 e8 02 	sts	0x02E8, r30
	display[1] = pgm_read_byte(numbertable_p + (abs(h) / 10));
     d0e:	c9 01       	movw	r24, r18
     d10:	6a e0       	ldi	r22, 0x0A	; 10
     d12:	70 e0       	ldi	r23, 0x00	; 0
     d14:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__divmodhi4>
     d18:	fb 01       	movw	r30, r22
     d1a:	ec 57       	subi	r30, 0x7C	; 124
     d1c:	ff 4f       	sbci	r31, 0xFF	; 255
     d1e:	e4 91       	lpm	r30, Z+
     d20:	e0 93 e7 02 	sts	0x02E7, r30
	// We use the '-' as a negative sign
	if (h >= 0)
     d24:	47 fd       	sbrc	r20, 7
     d26:	04 c0       	rjmp	.+8      	; 0xd30 <display_timezone+0x96>
		display[0] &= ~0x2;  // positive numbers, implicit sign
     d28:	80 91 e6 02 	lds	r24, 0x02E6
     d2c:	8d 7f       	andi	r24, 0xFD	; 253
     d2e:	03 c0       	rjmp	.+6      	; 0xd36 <display_timezone+0x9c>
	else 
		display[0] |= 0x2;  // negative numbers, display negative sign
     d30:	80 91 e6 02 	lds	r24, 0x02E6
     d34:	82 60       	ori	r24, 0x02	; 2
     d36:	80 93 e6 02 	sts	0x02E6, r24
     d3a:	08 95       	ret

00000d3c <display_str>:

}

// display words (menus, prompts, etc)
void display_str(char *s) {
     d3c:	cf 93       	push	r28
     d3e:	df 93       	push	r29
	uint8_t i;

	// don't use the lefthand dot/slash digit
	display[0] = 0;
     d40:	10 92 e6 02 	sts	0x02E6, r1
     d44:	ec 01       	movw	r28, r24
     d46:	a7 ee       	ldi	r26, 0xE7	; 231
     d48:	b2 e0       	ldi	r27, 0x02	; 2

	// up to 8 characters
	for (i=1; i<9; i++) {
		// check for null-termination
		if (s[i-1] == 0)
     d4a:	e8 81       	ld	r30, Y
     d4c:	ee 23       	and	r30, r30
     d4e:	d1 f0       	breq	.+52     	; 0xd84 <display_str+0x48>
			return;

		// Numbers and leters are looked up in the font table!
		if ((s[i-1] >= 'a') && (s[i-1] <= 'z')) {
     d50:	8e 2f       	mov	r24, r30
     d52:	81 56       	subi	r24, 0x61	; 97
     d54:	8a 31       	cpi	r24, 0x1A	; 26
     d56:	28 f4       	brcc	.+10     	; 0xd62 <display_str+0x26>
			display[i] =  pgm_read_byte(alphatable_p + s[i-1] - 'a');
     d58:	f0 e0       	ldi	r31, 0x00	; 0
     d5a:	e9 5f       	subi	r30, 0xF9	; 249
     d5c:	ff 4f       	sbci	r31, 0xFF	; 255
     d5e:	e4 91       	lpm	r30, Z+
     d60:	08 c0       	rjmp	.+16     	; 0xd72 <display_str+0x36>
		} else if ((s[i-1] >= '0') && (s[i-1] <= '9')) {
     d62:	8e 2f       	mov	r24, r30
     d64:	80 53       	subi	r24, 0x30	; 48
     d66:	8a 30       	cpi	r24, 0x0A	; 10
     d68:	30 f4       	brcc	.+12     	; 0xd76 <display_str+0x3a>
			display[i] =  pgm_read_byte(numbertable_p + s[i-1] - '0');
     d6a:	f0 e0       	ldi	r31, 0x00	; 0
     d6c:	ec 5a       	subi	r30, 0xAC	; 172
     d6e:	ff 4f       	sbci	r31, 0xFF	; 255
     d70:	e4 91       	lpm	r30, Z+
     d72:	ec 93       	st	X, r30
     d74:	01 c0       	rjmp	.+2      	; 0xd78 <display_str+0x3c>
		} else {
			display[i] = 0;      // spaces and other stuff are ignored :(
     d76:	1c 92       	st	X, r1
     d78:	21 96       	adiw	r28, 0x01	; 1
     d7a:	11 96       	adiw	r26, 0x01	; 1

	// don't use the lefthand dot/slash digit
	display[0] = 0;

	// up to 8 characters
	for (i=1; i<9; i++) {
     d7c:	82 e0       	ldi	r24, 0x02	; 2
     d7e:	af 3e       	cpi	r26, 0xEF	; 239
     d80:	b8 07       	cpc	r27, r24
     d82:	19 f7       	brne	.-58     	; 0xd4a <display_str+0xe>
			display[i] =  pgm_read_byte(numbertable_p + s[i-1] - '0');
		} else {
			display[i] = 0;      // spaces and other stuff are ignored :(
		}
	}
}
     d84:	df 91       	pop	r29
     d86:	cf 91       	pop	r28
     d88:	08 95       	ret

00000d8a <display_date>:
}

/**************************** DISPLAY *****************************/

// We can display the current date!
void display_date(uint8_t style) {
     d8a:	cf 93       	push	r28
     d8c:	df 93       	push	r29

	// This type is mm-dd-yy OR dd-mm-yy depending on our pref.
	if (style == DATE) {
     d8e:	88 23       	and	r24, r24
     d90:	09 f0       	breq	.+2      	; 0xd94 <display_date+0xa>
     d92:	96 c0       	rjmp	.+300    	; 0xec0 <display_date+0x136>
		display[0] = 0;
     d94:	10 92 e6 02 	sts	0x02E6, r1
		display[6] = display[3] = 0x02;     // put dashes between num
     d98:	82 e0       	ldi	r24, 0x02	; 2
     d9a:	80 93 e9 02 	sts	0x02E9, r24
     d9e:	80 93 ec 02 	sts	0x02EC, r24

		if (region == REGION_US) {
     da2:	80 91 48 02 	lds	r24, 0x0248
     da6:	88 23       	and	r24, r24
     da8:	09 f0       	breq	.+2      	; 0xdac <display_date+0x22>
     daa:	37 c0       	rjmp	.+110    	; 0xe1a <display_date+0x90>
			// mm-dd-yy
			display[1] = pgm_read_byte(numbertable_p + (date_m / 10));
     dac:	80 91 f5 02 	lds	r24, 0x02F5
     db0:	6a e0       	ldi	r22, 0x0A	; 10
     db2:	0e 94 a5 16 	call	0x2d4a	; 0x2d4a <__divmodqi4>
     db6:	e8 2f       	mov	r30, r24
     db8:	ff 27       	eor	r31, r31
     dba:	e7 fd       	sbrc	r30, 7
     dbc:	f0 95       	com	r31
     dbe:	ec 57       	subi	r30, 0x7C	; 124
     dc0:	ff 4f       	sbci	r31, 0xFF	; 255
     dc2:	e4 91       	lpm	r30, Z+
     dc4:	e0 93 e7 02 	sts	0x02E7, r30
			display[2] = pgm_read_byte(numbertable_p + (date_m % 10));
     dc8:	80 91 f5 02 	lds	r24, 0x02F5
     dcc:	6a e0       	ldi	r22, 0x0A	; 10
     dce:	0e 94 a5 16 	call	0x2d4a	; 0x2d4a <__divmodqi4>
     dd2:	e9 2f       	mov	r30, r25
     dd4:	ff 27       	eor	r31, r31
     dd6:	e7 fd       	sbrc	r30, 7
     dd8:	f0 95       	com	r31
     dda:	ec 57       	subi	r30, 0x7C	; 124
     ddc:	ff 4f       	sbci	r31, 0xFF	; 255
     dde:	e4 91       	lpm	r30, Z+
     de0:	e0 93 e8 02 	sts	0x02E8, r30
			display[4] = pgm_read_byte(numbertable_p + (date_d / 10));
     de4:	80 91 e5 02 	lds	r24, 0x02E5
     de8:	6a e0       	ldi	r22, 0x0A	; 10
     dea:	0e 94 a5 16 	call	0x2d4a	; 0x2d4a <__divmodqi4>
     dee:	e8 2f       	mov	r30, r24
     df0:	ff 27       	eor	r31, r31
     df2:	e7 fd       	sbrc	r30, 7
     df4:	f0 95       	com	r31
     df6:	ec 57       	subi	r30, 0x7C	; 124
     df8:	ff 4f       	sbci	r31, 0xFF	; 255
     dfa:	e4 91       	lpm	r30, Z+
     dfc:	e0 93 ea 02 	sts	0x02EA, r30
			display[5] = pgm_read_byte(numbertable_p + (date_d % 10));
     e00:	80 91 e5 02 	lds	r24, 0x02E5
     e04:	6a e0       	ldi	r22, 0x0A	; 10
     e06:	0e 94 a5 16 	call	0x2d4a	; 0x2d4a <__divmodqi4>
     e0a:	e9 2f       	mov	r30, r25
     e0c:	ff 27       	eor	r31, r31
     e0e:	e7 fd       	sbrc	r30, 7
     e10:	f0 95       	com	r31
     e12:	ec 57       	subi	r30, 0x7C	; 124
     e14:	ff 4f       	sbci	r31, 0xFF	; 255
     e16:	e4 91       	lpm	r30, Z+
     e18:	36 c0       	rjmp	.+108    	; 0xe86 <display_date+0xfc>
		} else {
			// dd-mm-yy
			display[1] = pgm_read_byte(numbertable_p + (date_d / 10));
     e1a:	80 91 e5 02 	lds	r24, 0x02E5
     e1e:	6a e0       	ldi	r22, 0x0A	; 10
     e20:	0e 94 a5 16 	call	0x2d4a	; 0x2d4a <__divmodqi4>
     e24:	e8 2f       	mov	r30, r24
     e26:	ff 27       	eor	r31, r31
     e28:	e7 fd       	sbrc	r30, 7
     e2a:	f0 95       	com	r31
     e2c:	ec 57       	subi	r30, 0x7C	; 124
     e2e:	ff 4f       	sbci	r31, 0xFF	; 255
     e30:	e4 91       	lpm	r30, Z+
     e32:	e0 93 e7 02 	sts	0x02E7, r30
			display[2] = pgm_read_byte(numbertable_p + (date_d % 10));
     e36:	80 91 e5 02 	lds	r24, 0x02E5
     e3a:	6a e0       	ldi	r22, 0x0A	; 10
     e3c:	0e 94 a5 16 	call	0x2d4a	; 0x2d4a <__divmodqi4>
     e40:	e9 2f       	mov	r30, r25
     e42:	ff 27       	eor	r31, r31
     e44:	e7 fd       	sbrc	r30, 7
     e46:	f0 95       	com	r31
     e48:	ec 57       	subi	r30, 0x7C	; 124
     e4a:	ff 4f       	sbci	r31, 0xFF	; 255
     e4c:	e4 91       	lpm	r30, Z+
     e4e:	e0 93 e8 02 	sts	0x02E8, r30
			display[4] = pgm_read_byte(numbertable_p + (date_m / 10));
     e52:	80 91 f5 02 	lds	r24, 0x02F5
     e56:	6a e0       	ldi	r22, 0x0A	; 10
     e58:	0e 94 a5 16 	call	0x2d4a	; 0x2d4a <__divmodqi4>
     e5c:	e8 2f       	mov	r30, r24
     e5e:	ff 27       	eor	r31, r31
     e60:	e7 fd       	sbrc	r30, 7
     e62:	f0 95       	com	r31
     e64:	ec 57       	subi	r30, 0x7C	; 124
     e66:	ff 4f       	sbci	r31, 0xFF	; 255
     e68:	e4 91       	lpm	r30, Z+
     e6a:	e0 93 ea 02 	sts	0x02EA, r30
			display[5] = pgm_read_byte(numbertable_p + (date_m % 10));
     e6e:	80 91 f5 02 	lds	r24, 0x02F5
     e72:	6a e0       	ldi	r22, 0x0A	; 10
     e74:	0e 94 a5 16 	call	0x2d4a	; 0x2d4a <__divmodqi4>
     e78:	e9 2f       	mov	r30, r25
     e7a:	ff 27       	eor	r31, r31
     e7c:	e7 fd       	sbrc	r30, 7
     e7e:	f0 95       	com	r31
     e80:	ec 57       	subi	r30, 0x7C	; 124
     e82:	ff 4f       	sbci	r31, 0xFF	; 255
     e84:	e4 91       	lpm	r30, Z+
     e86:	e0 93 eb 02 	sts	0x02EB, r30
		}
		// the yy part is the same
		display[7] = pgm_read_byte(numbertable_p + (date_y / 10));
     e8a:	80 91 e2 02 	lds	r24, 0x02E2
     e8e:	6a e0       	ldi	r22, 0x0A	; 10
     e90:	0e 94 a5 16 	call	0x2d4a	; 0x2d4a <__divmodqi4>
     e94:	e8 2f       	mov	r30, r24
     e96:	ff 27       	eor	r31, r31
     e98:	e7 fd       	sbrc	r30, 7
     e9a:	f0 95       	com	r31
     e9c:	ec 57       	subi	r30, 0x7C	; 124
     e9e:	ff 4f       	sbci	r31, 0xFF	; 255
     ea0:	e4 91       	lpm	r30, Z+
     ea2:	e0 93 ed 02 	sts	0x02ED, r30
		display[8] = pgm_read_byte(numbertable_p + (date_y % 10));
     ea6:	80 91 e2 02 	lds	r24, 0x02E2
     eaa:	6a e0       	ldi	r22, 0x0A	; 10
     eac:	0e 94 a5 16 	call	0x2d4a	; 0x2d4a <__divmodqi4>
     eb0:	e9 2f       	mov	r30, r25
     eb2:	ff 27       	eor	r31, r31
     eb4:	e7 fd       	sbrc	r30, 7
     eb6:	f0 95       	com	r31
     eb8:	ec 57       	subi	r30, 0x7C	; 124
     eba:	ff 4f       	sbci	r31, 0xFF	; 255
     ebc:	e4 91       	lpm	r30, Z+
     ebe:	ee c0       	rjmp	.+476    	; 0x109c <display_date+0x312>

	} else if (style == DAY) {
     ec0:	81 30       	cpi	r24, 0x01	; 1
     ec2:	09 f0       	breq	.+2      	; 0xec6 <display_date+0x13c>
     ec4:	ed c0       	rjmp	.+474    	; 0x10a0 <display_date+0x316>
		uint16_t month, year;
		uint8_t dotw;

		// Calculate day of the week

		month = date_m;
     ec6:	80 91 f5 02 	lds	r24, 0x02F5
     eca:	c8 2f       	mov	r28, r24
     ecc:	dd 27       	eor	r29, r29
     ece:	c7 fd       	sbrc	r28, 7
     ed0:	d0 95       	com	r29
		year = 2000 + date_y;
     ed2:	80 91 e2 02 	lds	r24, 0x02E2
     ed6:	e8 2f       	mov	r30, r24
     ed8:	ff 27       	eor	r31, r31
     eda:	e7 fd       	sbrc	r30, 7
     edc:	f0 95       	com	r31
     ede:	e0 53       	subi	r30, 0x30	; 48
     ee0:	f8 4f       	sbci	r31, 0xF8	; 248
		if (date_m < 3)  {
     ee2:	80 91 f5 02 	lds	r24, 0x02F5
     ee6:	83 30       	cpi	r24, 0x03	; 3
     ee8:	14 f4       	brge	.+4      	; 0xeee <display_date+0x164>
			month += 12;
     eea:	2c 96       	adiw	r28, 0x0c	; 12
			year -= 1;
     eec:	31 97       	sbiw	r30, 0x01	; 1
		}
		dotw = (date_d + (2 * month) + (6 * (month+1)/10) + year + (year/4) - (year/100) + (year/400) + 1) % 7;
     eee:	20 91 e5 02 	lds	r18, 0x02E5

		// Display the day first
		display[8] = display[7] = 0;
     ef2:	10 92 ed 02 	sts	0x02ED, r1
     ef6:	10 92 ee 02 	sts	0x02EE, r1
		switch (dotw) {
     efa:	33 27       	eor	r19, r19
     efc:	27 fd       	sbrc	r18, 7
     efe:	30 95       	com	r19
     f00:	2f 5f       	subi	r18, 0xFF	; 255
     f02:	3f 4f       	sbci	r19, 0xFF	; 255
     f04:	2e 0f       	add	r18, r30
     f06:	3f 1f       	adc	r19, r31
     f08:	ce 01       	movw	r24, r28
     f0a:	88 0f       	add	r24, r24
     f0c:	99 1f       	adc	r25, r25
     f0e:	28 0f       	add	r18, r24
     f10:	39 1f       	adc	r19, r25
     f12:	cf 01       	movw	r24, r30
     f14:	96 95       	lsr	r25
     f16:	87 95       	ror	r24
     f18:	96 95       	lsr	r25
     f1a:	87 95       	ror	r24
     f1c:	28 0f       	add	r18, r24
     f1e:	39 1f       	adc	r19, r25
     f20:	cf 01       	movw	r24, r30
     f22:	60 e9       	ldi	r22, 0x90	; 144
     f24:	71 e0       	ldi	r23, 0x01	; 1
     f26:	0e 94 b2 16 	call	0x2d64	; 0x2d64 <__udivmodhi4>
     f2a:	26 0f       	add	r18, r22
     f2c:	37 1f       	adc	r19, r23
     f2e:	cf 01       	movw	r24, r30
     f30:	64 e6       	ldi	r22, 0x64	; 100
     f32:	70 e0       	ldi	r23, 0x00	; 0
     f34:	0e 94 b2 16 	call	0x2d64	; 0x2d64 <__udivmodhi4>
     f38:	26 1b       	sub	r18, r22
     f3a:	37 0b       	sbc	r19, r23
     f3c:	ae 01       	movw	r20, r28
     f3e:	4f 5f       	subi	r20, 0xFF	; 255
     f40:	5f 4f       	sbci	r21, 0xFF	; 255
     f42:	ca 01       	movw	r24, r20
     f44:	88 0f       	add	r24, r24
     f46:	99 1f       	adc	r25, r25
     f48:	84 0f       	add	r24, r20
     f4a:	95 1f       	adc	r25, r21
     f4c:	88 0f       	add	r24, r24
     f4e:	99 1f       	adc	r25, r25
     f50:	6a e0       	ldi	r22, 0x0A	; 10
     f52:	70 e0       	ldi	r23, 0x00	; 0
     f54:	0e 94 b2 16 	call	0x2d64	; 0x2d64 <__udivmodhi4>
     f58:	c9 01       	movw	r24, r18
     f5a:	86 0f       	add	r24, r22
     f5c:	97 1f       	adc	r25, r23
     f5e:	67 e0       	ldi	r22, 0x07	; 7
     f60:	70 e0       	ldi	r23, 0x00	; 0
     f62:	0e 94 b2 16 	call	0x2d64	; 0x2d64 <__udivmodhi4>
     f66:	83 30       	cpi	r24, 0x03	; 3
     f68:	b9 f0       	breq	.+46     	; 0xf98 <display_date+0x20e>
     f6a:	84 30       	cpi	r24, 0x04	; 4
     f6c:	28 f4       	brcc	.+10     	; 0xf78 <display_date+0x1ee>
     f6e:	81 30       	cpi	r24, 0x01	; 1
     f70:	69 f0       	breq	.+26     	; 0xf8c <display_date+0x202>
     f72:	82 30       	cpi	r24, 0x02	; 2
     f74:	70 f4       	brcc	.+28     	; 0xf92 <display_date+0x208>
     f76:	07 c0       	rjmp	.+14     	; 0xf86 <display_date+0x1fc>
     f78:	85 30       	cpi	r24, 0x05	; 5
     f7a:	a1 f0       	breq	.+40     	; 0xfa4 <display_date+0x21a>
     f7c:	85 30       	cpi	r24, 0x05	; 5
     f7e:	78 f0       	brcs	.+30     	; 0xf9e <display_date+0x214>
     f80:	86 30       	cpi	r24, 0x06	; 6
     f82:	b9 f4       	brne	.+46     	; 0xfb2 <display_date+0x228>
     f84:	12 c0       	rjmp	.+36     	; 0xfaa <display_date+0x220>
			case 0:
				display_str("sunday"); break;
     f86:	80 e0       	ldi	r24, 0x00	; 0
     f88:	91 e0       	ldi	r25, 0x01	; 1
     f8a:	11 c0       	rjmp	.+34     	; 0xfae <display_date+0x224>
			case 1:
				display_str("monday"); break;
     f8c:	87 e0       	ldi	r24, 0x07	; 7
     f8e:	91 e0       	ldi	r25, 0x01	; 1
     f90:	0e c0       	rjmp	.+28     	; 0xfae <display_date+0x224>
			case 2:
				display_str("tuesday"); break;
     f92:	8e e0       	ldi	r24, 0x0E	; 14
     f94:	91 e0       	ldi	r25, 0x01	; 1
     f96:	0b c0       	rjmp	.+22     	; 0xfae <display_date+0x224>
			case 3:
				display_str("wednsday"); break;
     f98:	86 e1       	ldi	r24, 0x16	; 22
     f9a:	91 e0       	ldi	r25, 0x01	; 1
     f9c:	08 c0       	rjmp	.+16     	; 0xfae <display_date+0x224>
			case 4:
				display_str("thursday"); break;
     f9e:	8f e1       	ldi	r24, 0x1F	; 31
     fa0:	91 e0       	ldi	r25, 0x01	; 1
     fa2:	05 c0       	rjmp	.+10     	; 0xfae <display_date+0x224>
			case 5:
				display_str("friday"); break;
     fa4:	88 e2       	ldi	r24, 0x28	; 40
     fa6:	91 e0       	ldi	r25, 0x01	; 1
     fa8:	02 c0       	rjmp	.+4      	; 0xfae <display_date+0x224>
			case 6:
				display_str("saturday"); break;
     faa:	8f e2       	ldi	r24, 0x2F	; 47
     fac:	91 e0       	ldi	r25, 0x01	; 1
     fae:	0e 94 9e 06 	call	0xd3c	; 0xd3c <display_str>

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
     fb2:	78 94       	sei

	milliseconds = 0;
     fb4:	10 92 57 02 	sts	0x0257, r1
     fb8:	10 92 56 02 	sts	0x0256, r1
	while (milliseconds < ms);
     fbc:	80 91 56 02 	lds	r24, 0x0256
     fc0:	90 91 57 02 	lds	r25, 0x0257
     fc4:	88 5e       	subi	r24, 0xE8	; 232
     fc6:	93 40       	sbci	r25, 0x03	; 3
     fc8:	c8 f3       	brcs	.-14     	; 0xfbc <display_date+0x232>

		// wait one seconds about
		delayms(1000);

		// Then display the month and date
		display[6] = display[5] = display[4] = 0;
     fca:	10 92 ea 02 	sts	0x02EA, r1
     fce:	10 92 eb 02 	sts	0x02EB, r1
     fd2:	10 92 ec 02 	sts	0x02EC, r1
		switch (date_m) {
     fd6:	80 91 f5 02 	lds	r24, 0x02F5
     fda:	86 30       	cpi	r24, 0x06	; 6
     fdc:	79 f1       	breq	.+94     	; 0x103c <display_date+0x2b2>
     fde:	87 30       	cpi	r24, 0x07	; 7
     fe0:	74 f4       	brge	.+28     	; 0xffe <display_date+0x274>
     fe2:	83 30       	cpi	r24, 0x03	; 3
     fe4:	11 f1       	breq	.+68     	; 0x102a <display_date+0x2a0>
     fe6:	84 30       	cpi	r24, 0x04	; 4
     fe8:	2c f4       	brge	.+10     	; 0xff4 <display_date+0x26a>
     fea:	81 30       	cpi	r24, 0x01	; 1
     fec:	c1 f0       	breq	.+48     	; 0x101e <display_date+0x294>
     fee:	82 30       	cpi	r24, 0x02	; 2
     ff0:	d9 f5       	brne	.+118    	; 0x1068 <display_date+0x2de>
     ff2:	18 c0       	rjmp	.+48     	; 0x1024 <display_date+0x29a>
     ff4:	84 30       	cpi	r24, 0x04	; 4
     ff6:	e1 f0       	breq	.+56     	; 0x1030 <display_date+0x2a6>
     ff8:	85 30       	cpi	r24, 0x05	; 5
     ffa:	b1 f5       	brne	.+108    	; 0x1068 <display_date+0x2de>
     ffc:	1c c0       	rjmp	.+56     	; 0x1036 <display_date+0x2ac>
     ffe:	89 30       	cpi	r24, 0x09	; 9
    1000:	31 f1       	breq	.+76     	; 0x104e <display_date+0x2c4>
    1002:	8a 30       	cpi	r24, 0x0A	; 10
    1004:	2c f4       	brge	.+10     	; 0x1010 <display_date+0x286>
    1006:	87 30       	cpi	r24, 0x07	; 7
    1008:	e1 f0       	breq	.+56     	; 0x1042 <display_date+0x2b8>
    100a:	88 30       	cpi	r24, 0x08	; 8
    100c:	69 f5       	brne	.+90     	; 0x1068 <display_date+0x2de>
    100e:	1c c0       	rjmp	.+56     	; 0x1048 <display_date+0x2be>
    1010:	8b 30       	cpi	r24, 0x0B	; 11
    1012:	19 f1       	breq	.+70     	; 0x105a <display_date+0x2d0>
    1014:	8b 30       	cpi	r24, 0x0B	; 11
    1016:	f4 f0       	brlt	.+60     	; 0x1054 <display_date+0x2ca>
    1018:	8c 30       	cpi	r24, 0x0C	; 12
    101a:	31 f5       	brne	.+76     	; 0x1068 <display_date+0x2de>
    101c:	21 c0       	rjmp	.+66     	; 0x1060 <display_date+0x2d6>
			case 1:
				display_str("jan"); break;
    101e:	88 e3       	ldi	r24, 0x38	; 56
    1020:	91 e0       	ldi	r25, 0x01	; 1
    1022:	20 c0       	rjmp	.+64     	; 0x1064 <display_date+0x2da>
			case 2:
				display_str("feb"); break;
    1024:	8c e3       	ldi	r24, 0x3C	; 60
    1026:	91 e0       	ldi	r25, 0x01	; 1
    1028:	1d c0       	rjmp	.+58     	; 0x1064 <display_date+0x2da>
			case 3:
				display_str("march"); break;
    102a:	80 e4       	ldi	r24, 0x40	; 64
    102c:	91 e0       	ldi	r25, 0x01	; 1
    102e:	1a c0       	rjmp	.+52     	; 0x1064 <display_date+0x2da>
			case 4:
				display_str("april"); break;
    1030:	86 e4       	ldi	r24, 0x46	; 70
    1032:	91 e0       	ldi	r25, 0x01	; 1
    1034:	17 c0       	rjmp	.+46     	; 0x1064 <display_date+0x2da>
			case 5:
				display_str("may"); break;
    1036:	8c e4       	ldi	r24, 0x4C	; 76
    1038:	91 e0       	ldi	r25, 0x01	; 1
    103a:	14 c0       	rjmp	.+40     	; 0x1064 <display_date+0x2da>
			case 6:
				display_str("june"); break;
    103c:	80 e5       	ldi	r24, 0x50	; 80
    103e:	91 e0       	ldi	r25, 0x01	; 1
    1040:	11 c0       	rjmp	.+34     	; 0x1064 <display_date+0x2da>
			case 7:
				display_str("july"); break;
    1042:	85 e5       	ldi	r24, 0x55	; 85
    1044:	91 e0       	ldi	r25, 0x01	; 1
    1046:	0e c0       	rjmp	.+28     	; 0x1064 <display_date+0x2da>
			case 8:
				display_str("augst"); break;
    1048:	8a e5       	ldi	r24, 0x5A	; 90
    104a:	91 e0       	ldi	r25, 0x01	; 1
    104c:	0b c0       	rjmp	.+22     	; 0x1064 <display_date+0x2da>
			case 9:
				display_str("sept"); break;
    104e:	80 e6       	ldi	r24, 0x60	; 96
    1050:	91 e0       	ldi	r25, 0x01	; 1
    1052:	08 c0       	rjmp	.+16     	; 0x1064 <display_date+0x2da>
			case 10:
				display_str("octob"); break;
    1054:	85 e6       	ldi	r24, 0x65	; 101
    1056:	91 e0       	ldi	r25, 0x01	; 1
    1058:	05 c0       	rjmp	.+10     	; 0x1064 <display_date+0x2da>
			case 11:
				display_str("novem"); break;
    105a:	8b e6       	ldi	r24, 0x6B	; 107
    105c:	91 e0       	ldi	r25, 0x01	; 1
    105e:	02 c0       	rjmp	.+4      	; 0x1064 <display_date+0x2da>
			case 12:
				display_str("decem"); break;
    1060:	81 e7       	ldi	r24, 0x71	; 113
    1062:	91 e0       	ldi	r25, 0x01	; 1
    1064:	0e 94 9e 06 	call	0xd3c	; 0xd3c <display_str>
		}
		display[7] = pgm_read_byte(numbertable_p + (date_d / 10));
    1068:	80 91 e5 02 	lds	r24, 0x02E5
    106c:	6a e0       	ldi	r22, 0x0A	; 10
    106e:	0e 94 a5 16 	call	0x2d4a	; 0x2d4a <__divmodqi4>
    1072:	e8 2f       	mov	r30, r24
    1074:	ff 27       	eor	r31, r31
    1076:	e7 fd       	sbrc	r30, 7
    1078:	f0 95       	com	r31
    107a:	ec 57       	subi	r30, 0x7C	; 124
    107c:	ff 4f       	sbci	r31, 0xFF	; 255
    107e:	e4 91       	lpm	r30, Z+
    1080:	e0 93 ed 02 	sts	0x02ED, r30
		display[8] = pgm_read_byte(numbertable_p + (date_d % 10));
    1084:	80 91 e5 02 	lds	r24, 0x02E5
    1088:	6a e0       	ldi	r22, 0x0A	; 10
    108a:	0e 94 a5 16 	call	0x2d4a	; 0x2d4a <__divmodqi4>
    108e:	e9 2f       	mov	r30, r25
    1090:	ff 27       	eor	r31, r31
    1092:	e7 fd       	sbrc	r30, 7
    1094:	f0 95       	com	r31
    1096:	ec 57       	subi	r30, 0x7C	; 124
    1098:	ff 4f       	sbci	r31, 0xFF	; 255
    109a:	e4 91       	lpm	r30, Z+
    109c:	e0 93 ee 02 	sts	0x02EE, r30

	}
}
    10a0:	df 91       	pop	r29
    10a2:	cf 91       	pop	r28
    10a4:	08 95       	ret

000010a6 <set_region>:
}




void set_region(void) {
    10a6:	0f 93       	push	r16
    10a8:	1f 93       	push	r17
    10aa:	cf 93       	push	r28
    10ac:	df 93       	push	r29
	uint8_t mode = SHOW_MENU;

	timeoutcounter = INACTIVITYTIMEOUT;;  
    10ae:	8a e0       	ldi	r24, 0x0A	; 10
    10b0:	80 93 5c 02 	sts	0x025C, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    10b4:	f9 99       	sbic	0x1f, 1	; 31
    10b6:	fe cf       	rjmp	.-4      	; 0x10b4 <set_region+0xe>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    10b8:	8b e0       	ldi	r24, 0x0B	; 11
    10ba:	90 e0       	ldi	r25, 0x00	; 0
    10bc:	92 bd       	out	0x22, r25	; 34
    10be:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    10c0:	f8 9a       	sbi	0x1f, 0	; 31
    10c2:	80 b5       	in	r24, 0x20	; 32
	region = eeprom_read_byte((uint8_t *)EE_REGION);
    10c4:	80 93 48 02 	sts	0x0248, r24
    10c8:	10 e0       	ldi	r17, 0x00	; 0

	while (1) {
		if (just_pressed || pressed) {
			timeoutcounter = INACTIVITYTIMEOUT;;  
    10ca:	0a e0       	ldi	r16, 0x0A	; 10
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    10cc:	cb e0       	ldi	r28, 0x0B	; 11
    10ce:	d0 e0       	ldi	r29, 0x00	; 0
    10d0:	01 c0       	rjmp	.+2      	; 0x10d4 <set_region+0x2e>

void set_region(void) {
	uint8_t mode = SHOW_MENU;

	timeoutcounter = INACTIVITYTIMEOUT;;  
	region = eeprom_read_byte((uint8_t *)EE_REGION);
    10d2:	10 e0       	ldi	r17, 0x00	; 0

	while (1) {
		if (just_pressed || pressed) {
    10d4:	80 91 59 02 	lds	r24, 0x0259
    10d8:	88 23       	and	r24, r24
    10da:	21 f4       	brne	.+8      	; 0x10e4 <set_region+0x3e>
    10dc:	80 91 5a 02 	lds	r24, 0x025A
    10e0:	88 23       	and	r24, r24
    10e2:	19 f0       	breq	.+6      	; 0x10ea <set_region+0x44>
			timeoutcounter = INACTIVITYTIMEOUT;;  
    10e4:	00 93 5c 02 	sts	0x025C, r16
    10e8:	04 c0       	rjmp	.+8      	; 0x10f2 <set_region+0x4c>
			// timeout w/no buttons pressed after 3 seconds?
		} else if (!timeoutcounter) {
    10ea:	80 91 5c 02 	lds	r24, 0x025C
    10ee:	88 23       	and	r24, r24
    10f0:	c9 f0       	breq	.+50     	; 0x1124 <set_region+0x7e>
			//timed out!
			displaymode = SHOW_TIME;     
			return;
		}
		if (just_pressed & 0x1) { // mode change
    10f2:	80 91 59 02 	lds	r24, 0x0259
    10f6:	80 fd       	sbrc	r24, 0
    10f8:	3f c0       	rjmp	.+126    	; 0x1178 <set_region+0xd2>
			return;
		}
		if (just_pressed & 0x2) {
    10fa:	80 91 59 02 	lds	r24, 0x0259
    10fe:	81 ff       	sbrs	r24, 1
    1100:	14 c0       	rjmp	.+40     	; 0x112a <set_region+0x84>
			just_pressed = 0;
    1102:	10 92 59 02 	sts	0x0259, r1
			if (mode == SHOW_MENU) {
    1106:	11 23       	and	r17, r17
    1108:	69 f4       	brne	.+26     	; 0x1124 <set_region+0x7e>
				// start!
				mode = SET_REG;
				// display region
				if (region == REGION_US) {
    110a:	80 91 48 02 	lds	r24, 0x0248
    110e:	88 23       	and	r24, r24
    1110:	19 f4       	brne	.+6      	; 0x1118 <set_region+0x72>
					display_str("usa-12hr");
    1112:	87 e7       	ldi	r24, 0x77	; 119
    1114:	91 e0       	ldi	r25, 0x01	; 1
    1116:	02 c0       	rjmp	.+4      	; 0x111c <set_region+0x76>
				} else {
					display_str("eur-24hr");
    1118:	80 e8       	ldi	r24, 0x80	; 128
    111a:	91 e0       	ldi	r25, 0x01	; 1
    111c:	0e 94 9e 06 	call	0xd3c	; 0xd3c <display_str>
    1120:	11 e0       	ldi	r17, 0x01	; 1
    1122:	03 c0       	rjmp	.+6      	; 0x112a <set_region+0x84>
				}
			} else {	
				displaymode = SHOW_TIME;
    1124:	10 92 f4 02 	sts	0x02F4, r1
    1128:	27 c0       	rjmp	.+78     	; 0x1178 <set_region+0xd2>
				return;
			}
		}
		if (just_pressed & 0x4) {
    112a:	80 91 59 02 	lds	r24, 0x0259
    112e:	82 ff       	sbrs	r24, 2
    1130:	d1 cf       	rjmp	.-94     	; 0x10d4 <set_region+0x2e>
			just_pressed = 0;
    1132:	10 92 59 02 	sts	0x0259, r1
			if (mode == SET_REG) {
    1136:	11 30       	cpi	r17, 0x01	; 1
    1138:	61 f6       	brne	.-104    	; 0x10d2 <set_region+0x2c>
				region = !region;
    113a:	90 e0       	ldi	r25, 0x00	; 0
    113c:	80 91 48 02 	lds	r24, 0x0248
    1140:	88 23       	and	r24, r24
    1142:	09 f4       	brne	.+2      	; 0x1146 <set_region+0xa0>
    1144:	91 e0       	ldi	r25, 0x01	; 1
    1146:	90 93 48 02 	sts	0x0248, r25
				if (region == REGION_US) {
    114a:	99 23       	and	r25, r25
    114c:	19 f4       	brne	.+6      	; 0x1154 <set_region+0xae>
					display_str("usa-12hr");
    114e:	87 e7       	ldi	r24, 0x77	; 119
    1150:	91 e0       	ldi	r25, 0x01	; 1
    1152:	02 c0       	rjmp	.+4      	; 0x1158 <set_region+0xb2>
				} else {
					display_str("eur-24hr");
    1154:	80 e8       	ldi	r24, 0x80	; 128
    1156:	91 e0       	ldi	r25, 0x01	; 1
    1158:	0e 94 9e 06 	call	0xd3c	; 0xd3c <display_str>
				}
				eeprom_write_byte((uint8_t *)EE_REGION, region);
    115c:	80 91 48 02 	lds	r24, 0x0248
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1160:	f9 99       	sbic	0x1f, 1	; 31
    1162:	fe cf       	rjmp	.-4      	; 0x1160 <set_region+0xba>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1164:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1166:	d2 bd       	out	0x22, r29	; 34
    1168:	c1 bd       	out	0x21, r28	; 33
#endif
    EEDR = __value;
    116a:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
    116c:	0f b6       	in	r0, 0x3f	; 63
    116e:	f8 94       	cli
    1170:	fa 9a       	sbi	0x1f, 2	; 31
    1172:	f9 9a       	sbi	0x1f, 1	; 31
    1174:	0f be       	out	0x3f, r0	; 63
    1176:	ae cf       	rjmp	.-164    	; 0x10d4 <set_region+0x2e>
			}
		}
	}
}
    1178:	df 91       	pop	r29
    117a:	cf 91       	pop	r28
    117c:	1f 91       	pop	r17
    117e:	0f 91       	pop	r16
    1180:	08 95       	ret

00001182 <set_volume>:
	display[7] = pgm_read_byte(numbertable_p + (brightness / 10)) | 0x1;
	display[8] = pgm_read_byte(numbertable_p + (brightness % 10)) | 0x1;
	set_vfd_brightness(brightness);
}

void set_volume(void) {
    1182:	ef 92       	push	r14
    1184:	ff 92       	push	r15
    1186:	0f 93       	push	r16
    1188:	1f 93       	push	r17
    118a:	cf 93       	push	r28
    118c:	df 93       	push	r29
	uint8_t mode = SHOW_MENU;
	uint8_t volume;

	timeoutcounter = INACTIVITYTIMEOUT;;  
    118e:	8a e0       	ldi	r24, 0x0A	; 10
    1190:	80 93 5c 02 	sts	0x025C, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1194:	f9 99       	sbic	0x1f, 1	; 31
    1196:	fe cf       	rjmp	.-4      	; 0x1194 <set_volume+0x12>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    1198:	8a e0       	ldi	r24, 0x0A	; 10
    119a:	90 e0       	ldi	r25, 0x00	; 0
    119c:	92 bd       	out	0x22, r25	; 34
    119e:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    11a0:	f8 9a       	sbi	0x1f, 0	; 31
    11a2:	f0 b4       	in	r15, 0x20	; 32
    11a4:	00 e0       	ldi	r16, 0x00	; 0
	volume = eeprom_read_byte((uint8_t *)EE_VOLUME);

	while (1) {
		if (just_pressed || pressed) {
			timeoutcounter = INACTIVITYTIMEOUT;;  
    11a6:	1a e0       	ldi	r17, 0x0A	; 10
    11a8:	e1 2e       	mov	r14, r17
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    11aa:	ca e0       	ldi	r28, 0x0A	; 10
    11ac:	d0 e0       	ldi	r29, 0x00	; 0
    11ae:	01 c0       	rjmp	.+2      	; 0x11b2 <set_volume+0x30>
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    11b0:	00 e0       	ldi	r16, 0x00	; 0

	timeoutcounter = INACTIVITYTIMEOUT;;  
	volume = eeprom_read_byte((uint8_t *)EE_VOLUME);

	while (1) {
		if (just_pressed || pressed) {
    11b2:	80 91 59 02 	lds	r24, 0x0259
    11b6:	88 23       	and	r24, r24
    11b8:	21 f4       	brne	.+8      	; 0x11c2 <set_volume+0x40>
    11ba:	80 91 5a 02 	lds	r24, 0x025A
    11be:	88 23       	and	r24, r24
    11c0:	19 f0       	breq	.+6      	; 0x11c8 <set_volume+0x46>
			timeoutcounter = INACTIVITYTIMEOUT;;  
    11c2:	e0 92 5c 02 	sts	0x025C, r14
    11c6:	04 c0       	rjmp	.+8      	; 0x11d0 <set_volume+0x4e>
			// timeout w/no buttons pressed after 3 seconds?
		} else if (!timeoutcounter) {
    11c8:	80 91 5c 02 	lds	r24, 0x025C
    11cc:	88 23       	and	r24, r24
    11ce:	69 f1       	breq	.+90     	; 0x122a <set_volume+0xa8>
			//timed out!
			displaymode = SHOW_TIME;     
			return;
		}
		if (just_pressed & 0x1) { // mode change
    11d0:	80 91 59 02 	lds	r24, 0x0259
    11d4:	80 fd       	sbrc	r24, 0
    11d6:	6c c0       	rjmp	.+216    	; 0x12b0 <set_volume+0x12e>
			return;
		}
		if (just_pressed & 0x2) {
    11d8:	80 91 59 02 	lds	r24, 0x0259
    11dc:	81 ff       	sbrs	r24, 1
    11de:	28 c0       	rjmp	.+80     	; 0x1230 <set_volume+0xae>
			just_pressed = 0;
    11e0:	10 92 59 02 	sts	0x0259, r1
			if (mode == SHOW_MENU) {
    11e4:	00 23       	and	r16, r16
    11e6:	09 f5       	brne	.+66     	; 0x122a <set_volume+0xa8>
				// start!
				mode = SET_VOL;
				// display volume
				if (volume) {
    11e8:	ff 20       	and	r15, r15
    11ea:	51 f0       	breq	.+20     	; 0x1200 <set_volume+0x7e>
					display_str("vol high");
    11ec:	89 e8       	ldi	r24, 0x89	; 137
    11ee:	91 e0       	ldi	r25, 0x01	; 1
    11f0:	0e 94 9e 06 	call	0xd3c	; 0xd3c <display_str>
					display[5] |= 0x1;
    11f4:	80 91 eb 02 	lds	r24, 0x02EB
    11f8:	81 60       	ori	r24, 0x01	; 1
    11fa:	80 93 eb 02 	sts	0x02EB, r24
    11fe:	04 c0       	rjmp	.+8      	; 0x1208 <set_volume+0x86>
				} else {
					display_str("vol  low");
    1200:	82 e9       	ldi	r24, 0x92	; 146
    1202:	91 e0       	ldi	r25, 0x01	; 1
    1204:	0e 94 9e 06 	call	0xd3c	; 0xd3c <display_str>
				}
				display[6] |= 0x1;
    1208:	80 91 ec 02 	lds	r24, 0x02EC
    120c:	81 60       	ori	r24, 0x01	; 1
    120e:	80 93 ec 02 	sts	0x02EC, r24
				display[7] |= 0x1;
    1212:	80 91 ed 02 	lds	r24, 0x02ED
    1216:	81 60       	ori	r24, 0x01	; 1
    1218:	80 93 ed 02 	sts	0x02ED, r24
				display[8] |= 0x1;
    121c:	80 91 ee 02 	lds	r24, 0x02EE
    1220:	81 60       	ori	r24, 0x01	; 1
    1222:	80 93 ee 02 	sts	0x02EE, r24
    1226:	01 e0       	ldi	r16, 0x01	; 1
    1228:	03 c0       	rjmp	.+6      	; 0x1230 <set_volume+0xae>
			} else {	
				displaymode = SHOW_TIME;
    122a:	10 92 f4 02 	sts	0x02F4, r1
    122e:	40 c0       	rjmp	.+128    	; 0x12b0 <set_volume+0x12e>
				return;
			}
		}
		if (just_pressed & 0x4) {
    1230:	80 91 59 02 	lds	r24, 0x0259
    1234:	82 ff       	sbrs	r24, 2
    1236:	bd cf       	rjmp	.-134    	; 0x11b2 <set_volume+0x30>
			just_pressed = 0;
    1238:	10 92 59 02 	sts	0x0259, r1
			if (mode == SET_VOL) {
    123c:	01 30       	cpi	r16, 0x01	; 1
    123e:	09 f0       	breq	.+2      	; 0x1242 <set_volume+0xc0>
    1240:	b7 cf       	rjmp	.-146    	; 0x11b0 <set_volume+0x2e>
				volume = !volume;
    1242:	10 e0       	ldi	r17, 0x00	; 0
    1244:	ff 20       	and	r15, r15
    1246:	09 f4       	brne	.+2      	; 0x124a <set_volume+0xc8>
    1248:	11 e0       	ldi	r17, 0x01	; 1
    124a:	f1 2e       	mov	r15, r17
				if (volume) {
    124c:	11 23       	and	r17, r17
    124e:	51 f0       	breq	.+20     	; 0x1264 <set_volume+0xe2>
					display_str("vol high");
    1250:	89 e8       	ldi	r24, 0x89	; 137
    1252:	91 e0       	ldi	r25, 0x01	; 1
    1254:	0e 94 9e 06 	call	0xd3c	; 0xd3c <display_str>
					display[5] |= 0x1;
    1258:	80 91 eb 02 	lds	r24, 0x02EB
    125c:	81 60       	ori	r24, 0x01	; 1
    125e:	80 93 eb 02 	sts	0x02EB, r24
    1262:	04 c0       	rjmp	.+8      	; 0x126c <set_volume+0xea>
				} else {
					display_str("vol  low");
    1264:	82 e9       	ldi	r24, 0x92	; 146
    1266:	91 e0       	ldi	r25, 0x01	; 1
    1268:	0e 94 9e 06 	call	0xd3c	; 0xd3c <display_str>
				}
				display[6] |= 0x1;
    126c:	80 91 ec 02 	lds	r24, 0x02EC
    1270:	81 60       	ori	r24, 0x01	; 1
    1272:	80 93 ec 02 	sts	0x02EC, r24
				display[7] |= 0x1;
    1276:	80 91 ed 02 	lds	r24, 0x02ED
    127a:	81 60       	ori	r24, 0x01	; 1
    127c:	80 93 ed 02 	sts	0x02ED, r24
				display[8] |= 0x1;
    1280:	80 91 ee 02 	lds	r24, 0x02EE
    1284:	81 60       	ori	r24, 0x01	; 1
    1286:	80 93 ee 02 	sts	0x02EE, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    128a:	f9 99       	sbic	0x1f, 1	; 31
    128c:	fe cf       	rjmp	.-4      	; 0x128a <set_volume+0x108>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    128e:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1290:	d2 bd       	out	0x22, r29	; 34
    1292:	c1 bd       	out	0x21, r28	; 33
#endif
    EEDR = __value;
    1294:	10 bd       	out	0x20, r17	; 32

    __asm__ __volatile__ (
    1296:	0f b6       	in	r0, 0x3f	; 63
    1298:	f8 94       	cli
    129a:	fa 9a       	sbi	0x1f, 2	; 31
    129c:	f9 9a       	sbi	0x1f, 1	; 31
    129e:	0f be       	out	0x3f, r0	; 63
				eeprom_write_byte((uint8_t *)EE_VOLUME, volume);
				speaker_init();
    12a0:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <speaker_init>
				beep(4000, 1);
    12a4:	80 ea       	ldi	r24, 0xA0	; 160
    12a6:	9f e0       	ldi	r25, 0x0F	; 15
    12a8:	61 e0       	ldi	r22, 0x01	; 1
    12aa:	0e 94 40 02 	call	0x480	; 0x480 <beep>
    12ae:	81 cf       	rjmp	.-254    	; 0x11b2 <set_volume+0x30>
			}
		}
	}
}
    12b0:	df 91       	pop	r29
    12b2:	cf 91       	pop	r28
    12b4:	1f 91       	pop	r17
    12b6:	0f 91       	pop	r16
    12b8:	ff 90       	pop	r15
    12ba:	ef 90       	pop	r14
    12bc:	08 95       	ret

000012be <set_brightness>:
				delayms(75);
		}
	}
}

void set_brightness(void) {
    12be:	ff 92       	push	r15
    12c0:	0f 93       	push	r16
    12c2:	1f 93       	push	r17
	uint8_t mode = SHOW_MENU;

	timeoutcounter = INACTIVITYTIMEOUT;;  
    12c4:	8a e0       	ldi	r24, 0x0A	; 10
    12c6:	80 93 5c 02 	sts	0x025C, r24
    12ca:	10 e0       	ldi	r17, 0x00	; 0

	while (1) {
		if (just_pressed || pressed) {
			timeoutcounter = INACTIVITYTIMEOUT;;  
    12cc:	0a e0       	ldi	r16, 0x0A	; 10
    12ce:	f0 2e       	mov	r15, r16
		if ((just_pressed & 0x4) || (pressed & 0x4)) {
			just_pressed = 0;
			if (mode == SET_BRITE) {
				// Increment brightness level. Zero means auto-dim.
				if (brightness_level == 0) {
					brightness_level = BRIGHTNESS_MIN;
    12d0:	0e e1       	ldi	r16, 0x1E	; 30
    12d2:	01 c0       	rjmp	.+2      	; 0x12d6 <set_brightness+0x18>
}

void set_brightness(void) {
	uint8_t mode = SHOW_MENU;

	timeoutcounter = INACTIVITYTIMEOUT;;  
    12d4:	10 e0       	ldi	r17, 0x00	; 0

	while (1) {
		if (just_pressed || pressed) {
    12d6:	80 91 59 02 	lds	r24, 0x0259
    12da:	88 23       	and	r24, r24
    12dc:	21 f4       	brne	.+8      	; 0x12e6 <set_brightness+0x28>
    12de:	80 91 5a 02 	lds	r24, 0x025A
    12e2:	88 23       	and	r24, r24
    12e4:	19 f0       	breq	.+6      	; 0x12ec <set_brightness+0x2e>
			timeoutcounter = INACTIVITYTIMEOUT;;  
    12e6:	f0 92 5c 02 	sts	0x025C, r15
    12ea:	0b c0       	rjmp	.+22     	; 0x1302 <set_brightness+0x44>
			// timeout w/no buttons pressed after 3 seconds?
		} else if (!timeoutcounter) {
    12ec:	80 91 5c 02 	lds	r24, 0x025C
    12f0:	88 23       	and	r24, r24
    12f2:	39 f4       	brne	.+14     	; 0x1302 <set_brightness+0x44>
			//timed out!
			displaymode = SHOW_TIME;     
    12f4:	10 92 f4 02 	sts	0x02F4, r1
			eeprom_write_byte((uint8_t *)EE_BRIGHT, brightness_level);
    12f8:	20 91 f2 02 	lds	r18, 0x02F2
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    12fc:	f9 99       	sbic	0x1f, 1	; 31
    12fe:	fe cf       	rjmp	.-4      	; 0x12fc <set_brightness+0x3e>
    1300:	1d c0       	rjmp	.+58     	; 0x133c <set_brightness+0x7e>
			return;
		}
		if (just_pressed & 0x1) { // mode change
    1302:	80 91 59 02 	lds	r24, 0x0259
    1306:	80 fd       	sbrc	r24, 0
    1308:	4a c0       	rjmp	.+148    	; 0x139e <set_brightness+0xe0>
			return;
		}
		if (just_pressed & 0x2) {
    130a:	80 91 59 02 	lds	r24, 0x0259
    130e:	81 ff       	sbrs	r24, 1
    1310:	21 c0       	rjmp	.+66     	; 0x1354 <set_brightness+0x96>

			just_pressed = 0;
    1312:	10 92 59 02 	sts	0x0259, r1
			if (mode == SHOW_MENU) {
    1316:	11 23       	and	r17, r17
    1318:	59 f4       	brne	.+22     	; 0x1330 <set_brightness+0x72>
				// start!
				mode = SET_BRITE;
				// display brightness
				display_str("brite ");
    131a:	8b e9       	ldi	r24, 0x9B	; 155
    131c:	91 e0       	ldi	r25, 0x01	; 1
    131e:	0e 94 9e 06 	call	0xd3c	; 0xd3c <display_str>
				display_brightness(brightness_level);
    1322:	80 91 f2 02 	lds	r24, 0x02F2
    1326:	90 e0       	ldi	r25, 0x00	; 0
    1328:	0e 94 1a 01 	call	0x234	; 0x234 <display_brightness>
    132c:	11 e0       	ldi	r17, 0x01	; 1
    132e:	12 c0       	rjmp	.+36     	; 0x1354 <set_brightness+0x96>
			} else {	
				displaymode = SHOW_TIME;
    1330:	10 92 f4 02 	sts	0x02F4, r1
				eeprom_write_byte((uint8_t *)EE_BRIGHT, brightness_level);
    1334:	20 91 f2 02 	lds	r18, 0x02F2
    1338:	f9 99       	sbic	0x1f, 1	; 31
    133a:	fe cf       	rjmp	.-4      	; 0x1338 <set_brightness+0x7a>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    133c:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    133e:	89 e0       	ldi	r24, 0x09	; 9
    1340:	90 e0       	ldi	r25, 0x00	; 0
    1342:	92 bd       	out	0x22, r25	; 34
    1344:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    1346:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    1348:	0f b6       	in	r0, 0x3f	; 63
    134a:	f8 94       	cli
    134c:	fa 9a       	sbi	0x1f, 2	; 31
    134e:	f9 9a       	sbi	0x1f, 1	; 31
    1350:	0f be       	out	0x3f, r0	; 63
    1352:	25 c0       	rjmp	.+74     	; 0x139e <set_brightness+0xe0>
				return;
			}
		}
		if ((just_pressed & 0x4) || (pressed & 0x4)) {
    1354:	80 91 59 02 	lds	r24, 0x0259
    1358:	82 fd       	sbrc	r24, 2
    135a:	04 c0       	rjmp	.+8      	; 0x1364 <set_brightness+0xa6>
    135c:	80 91 5a 02 	lds	r24, 0x025A
    1360:	82 ff       	sbrs	r24, 2
    1362:	b9 cf       	rjmp	.-142    	; 0x12d6 <set_brightness+0x18>
			just_pressed = 0;
    1364:	10 92 59 02 	sts	0x0259, r1
			if (mode == SET_BRITE) {
    1368:	11 30       	cpi	r17, 0x01	; 1
    136a:	09 f0       	breq	.+2      	; 0x136e <set_brightness+0xb0>
    136c:	b3 cf       	rjmp	.-154    	; 0x12d4 <set_brightness+0x16>
				// Increment brightness level. Zero means auto-dim.
				if (brightness_level == 0) {
    136e:	80 91 f2 02 	lds	r24, 0x02F2
    1372:	88 23       	and	r24, r24
    1374:	19 f4       	brne	.+6      	; 0x137c <set_brightness+0xbe>
					brightness_level = BRIGHTNESS_MIN;
    1376:	00 93 f2 02 	sts	0x02F2, r16
    137a:	0b c0       	rjmp	.+22     	; 0x1392 <set_brightness+0xd4>
				} else {
					brightness_level += BRIGHTNESS_INCREMENT;
    137c:	80 91 f2 02 	lds	r24, 0x02F2
    1380:	8b 5f       	subi	r24, 0xFB	; 251
    1382:	80 93 f2 02 	sts	0x02F2, r24
					if (brightness_level > BRIGHTNESS_MAX) {
    1386:	80 91 f2 02 	lds	r24, 0x02F2
    138a:	8b 35       	cpi	r24, 0x5B	; 91
    138c:	10 f0       	brcs	.+4      	; 0x1392 <set_brightness+0xd4>
#ifdef FEATURE_AUTODIM
						brightness_level = 0;
    138e:	10 92 f2 02 	sts	0x02F2, r1
#else
						brightness_level = BRIGHTNESS_MIN;
#endif
					}
				}
				display_brightness(brightness_level);
    1392:	80 91 f2 02 	lds	r24, 0x02F2
    1396:	90 e0       	ldi	r25, 0x00	; 0
    1398:	0e 94 1a 01 	call	0x234	; 0x234 <display_brightness>
    139c:	9c cf       	rjmp	.-200    	; 0x12d6 <set_brightness+0x18>
			}
		}
	}
}
    139e:	1f 91       	pop	r17
    13a0:	0f 91       	pop	r16
    13a2:	ff 90       	pop	r15
    13a4:	08 95       	ret

000013a6 <vfd_init>:

/************************* LOW LEVEL DISPLAY ************************/

// Setup SPI
void vfd_init(void) {
	SPCR  = _BV(SPE) | _BV(MSTR) | _BV(SPR0);
    13a6:	81 e5       	ldi	r24, 0x51	; 81
    13a8:	8c bd       	out	0x2c, r24	; 44
}
    13aa:	08 95       	ret

000013ac <vfd_send>:
	vfd_send(d);
}

// send raw data to display, its pretty straightforward. Just send 32 bits via SPI
// the bottom 20 define the segments
void vfd_send(uint32_t d) {
    13ac:	9b 01       	movw	r18, r22
    13ae:	ac 01       	movw	r20, r24
	// send lowest 20 bits
	cli();       // to prevent flicker we turn off interrupts
    13b0:	f8 94       	cli
	spi_xfer(d >> 16);
    13b2:	ca 01       	movw	r24, r20
    13b4:	aa 27       	eor	r26, r26
    13b6:	bb 27       	eor	r27, r27
}

// Send 1 byte via SPI
void spi_xfer(uint8_t c) {

	SPDR = c;
    13b8:	8e bd       	out	0x2e, r24	; 46
	while (! (SPSR & _BV(SPIF)));
    13ba:	0d b4       	in	r0, 0x2d	; 45
    13bc:	07 fe       	sbrs	r0, 7
    13be:	fd cf       	rjmp	.-6      	; 0x13ba <vfd_send+0xe>
// the bottom 20 define the segments
void vfd_send(uint32_t d) {
	// send lowest 20 bits
	cli();       // to prevent flicker we turn off interrupts
	spi_xfer(d >> 16);
	spi_xfer(d >> 8);
    13c0:	bb 27       	eor	r27, r27
    13c2:	a5 2f       	mov	r26, r21
    13c4:	94 2f       	mov	r25, r20
    13c6:	83 2f       	mov	r24, r19
}

// Send 1 byte via SPI
void spi_xfer(uint8_t c) {

	SPDR = c;
    13c8:	8e bd       	out	0x2e, r24	; 46
	while (! (SPSR & _BV(SPIF)));
    13ca:	0d b4       	in	r0, 0x2d	; 45
    13cc:	07 fe       	sbrs	r0, 7
    13ce:	fd cf       	rjmp	.-6      	; 0x13ca <vfd_send+0x1e>
}

// Send 1 byte via SPI
void spi_xfer(uint8_t c) {

	SPDR = c;
    13d0:	2e bd       	out	0x2e, r18	; 46
	while (! (SPSR & _BV(SPIF)));
    13d2:	0d b4       	in	r0, 0x2d	; 45
    13d4:	07 fe       	sbrs	r0, 7
    13d6:	fd cf       	rjmp	.-6      	; 0x13d2 <vfd_send+0x26>
	spi_xfer(d >> 16);
	spi_xfer(d >> 8);
	spi_xfer(d);

	// latch data
	VFDLOAD_PORT |= _BV(VFDLOAD);
    13d8:	40 9a       	sbi	0x08, 0	; 8
	VFDLOAD_PORT &= ~_BV(VFDLOAD);
    13da:	40 98       	cbi	0x08, 0	; 8
	sei();
    13dc:	78 94       	sei
}
    13de:	08 95       	ret

000013e0 <setdisplay>:
}

// This changes and updates the display
// We use the digit/segment table to determine which
// pins on the MAX6921 to turn on
void setdisplay(uint8_t digit, uint8_t segments) {
    13e0:	af 92       	push	r10
    13e2:	bf 92       	push	r11
    13e4:	cf 92       	push	r12
    13e6:	df 92       	push	r13
    13e8:	ef 92       	push	r14
    13ea:	ff 92       	push	r15
    13ec:	0f 93       	push	r16
    13ee:	1f 93       	push	r17
	uint32_t d = 0;  // we only need 20 bits but 32 will do
	uint8_t i;

	// Set the digit selection pin
	d |= _BV(pgm_read_byte(digittable_p + digit));
    13f0:	e8 2f       	mov	r30, r24
    13f2:	f0 e0       	ldi	r31, 0x00	; 0
    13f4:	e0 57       	subi	r30, 0x70	; 112
    13f6:	ff 4f       	sbci	r31, 0xFF	; 255
    13f8:	e4 91       	lpm	r30, Z+
    13fa:	81 e0       	ldi	r24, 0x01	; 1
    13fc:	90 e0       	ldi	r25, 0x00	; 0
    13fe:	02 c0       	rjmp	.+4      	; 0x1404 <setdisplay+0x24>
    1400:	88 0f       	add	r24, r24
    1402:	99 1f       	adc	r25, r25
    1404:	ea 95       	dec	r30
    1406:	e2 f7       	brpl	.-8      	; 0x1400 <setdisplay+0x20>
    1408:	7c 01       	movw	r14, r24
    140a:	00 27       	eor	r16, r16
    140c:	f7 fc       	sbrc	r15, 7
    140e:	00 95       	com	r16
    1410:	10 2f       	mov	r17, r16
    1412:	20 91 5d 02 	lds	r18, 0x025D
    1416:	30 91 5e 02 	lds	r19, 0x025E
    141a:	40 91 5f 02 	lds	r20, 0x025F
    141e:	50 91 60 02 	lds	r21, 0x0260
    1422:	a0 e0       	ldi	r26, 0x00	; 0
    1424:	b0 e0       	ldi	r27, 0x00	; 0


	// Set the individual segments for this digit
	for (i=0; i<8; i++) {
		if (segments & _BV(i)) {
    1426:	70 e0       	ldi	r23, 0x00	; 0
			t = 1;
			t <<= pgm_read_byte(segmenttable_p + i);
    1428:	e1 e0       	ldi	r30, 0x01	; 1
    142a:	ae 2e       	mov	r10, r30
    142c:	b1 2c       	mov	r11, r1
    142e:	c1 2c       	mov	r12, r1
    1430:	d1 2c       	mov	r13, r1
	d |= _BV(pgm_read_byte(digittable_p + digit));


	// Set the individual segments for this digit
	for (i=0; i<8; i++) {
		if (segments & _BV(i)) {
    1432:	cb 01       	movw	r24, r22
    1434:	0a 2e       	mov	r0, r26
    1436:	02 c0       	rjmp	.+4      	; 0x143c <setdisplay+0x5c>
    1438:	95 95       	asr	r25
    143a:	87 95       	ror	r24
    143c:	0a 94       	dec	r0
    143e:	e2 f7       	brpl	.-8      	; 0x1438 <setdisplay+0x58>
    1440:	80 ff       	sbrs	r24, 0
    1442:	11 c0       	rjmp	.+34     	; 0x1466 <setdisplay+0x86>
			t = 1;
			t <<= pgm_read_byte(segmenttable_p + i);
    1444:	fd 01       	movw	r30, r26
    1446:	e5 56       	subi	r30, 0x65	; 101
    1448:	ff 4f       	sbci	r31, 0xFF	; 255
    144a:	e4 91       	lpm	r30, Z+
    144c:	a6 01       	movw	r20, r12
    144e:	95 01       	movw	r18, r10
    1450:	04 c0       	rjmp	.+8      	; 0x145a <setdisplay+0x7a>
    1452:	22 0f       	add	r18, r18
    1454:	33 1f       	adc	r19, r19
    1456:	44 1f       	adc	r20, r20
    1458:	55 1f       	adc	r21, r21
    145a:	ea 95       	dec	r30
    145c:	d2 f7       	brpl	.-12     	; 0x1452 <setdisplay+0x72>
			d |= t;
    145e:	e2 2a       	or	r14, r18
    1460:	f3 2a       	or	r15, r19
    1462:	04 2b       	or	r16, r20
    1464:	15 2b       	or	r17, r21
    1466:	11 96       	adiw	r26, 0x01	; 1
	// Set the digit selection pin
	d |= _BV(pgm_read_byte(digittable_p + digit));


	// Set the individual segments for this digit
	for (i=0; i<8; i++) {
    1468:	a8 30       	cpi	r26, 0x08	; 8
    146a:	b1 05       	cpc	r27, r1
    146c:	11 f7       	brne	.-60     	; 0x1432 <setdisplay+0x52>
    146e:	20 93 5d 02 	sts	0x025D, r18
    1472:	30 93 5e 02 	sts	0x025E, r19
    1476:	40 93 5f 02 	sts	0x025F, r20
    147a:	50 93 60 02 	sts	0x0260, r21
			d |= t;
		}
	}

	// Shift the data out to the display
	vfd_send(d);
    147e:	c8 01       	movw	r24, r16
    1480:	b7 01       	movw	r22, r14
    1482:	0e 94 d6 09 	call	0x13ac	; 0x13ac <vfd_send>
}
    1486:	1f 91       	pop	r17
    1488:	0f 91       	pop	r16
    148a:	ff 90       	pop	r15
    148c:	ef 90       	pop	r14
    148e:	df 90       	pop	r13
    1490:	cf 90       	pop	r12
    1492:	bf 90       	pop	r11
    1494:	af 90       	pop	r10
    1496:	08 95       	ret

00001498 <__vector_16>:
void kickthedog(void) {
	wdt_reset();
}

// called @ (F_CPU/256) = ~30khz (31.25 khz)
SIGNAL (SIG_OVERFLOW0) {
    1498:	1f 92       	push	r1
    149a:	0f 92       	push	r0
    149c:	0f b6       	in	r0, 0x3f	; 63
    149e:	0f 92       	push	r0
    14a0:	11 24       	eor	r1, r1
    14a2:	2f 93       	push	r18
    14a4:	3f 93       	push	r19
    14a6:	4f 93       	push	r20
    14a8:	5f 93       	push	r21
    14aa:	6f 93       	push	r22
    14ac:	7f 93       	push	r23
    14ae:	8f 93       	push	r24
    14b0:	9f 93       	push	r25
    14b2:	af 93       	push	r26
    14b4:	bf 93       	push	r27
    14b6:	ef 93       	push	r30
    14b8:	ff 93       	push	r31
	// allow other interrupts to go off while we're doing display updates
	sei();
    14ba:	78 94       	sei
	displaymode = SHOW_TIME;
}

// we reset the watchdog timer 
void kickthedog(void) {
	wdt_reset();
    14bc:	a8 95       	wdr

	// kick the dog
	kickthedog();

	// divide down to 100Hz * digits
	muxdiv++;
    14be:	80 91 50 02 	lds	r24, 0x0250
    14c2:	90 91 51 02 	lds	r25, 0x0251
    14c6:	01 96       	adiw	r24, 0x01	; 1
    14c8:	90 93 51 02 	sts	0x0251, r25
    14cc:	80 93 50 02 	sts	0x0250, r24
	if (muxdiv < MUX_DIVIDER)
    14d0:	81 97       	sbiw	r24, 0x21	; 33
    14d2:	08 f4       	brcc	.+2      	; 0x14d6 <__vector_16+0x3e>
    14d4:	6c c0       	rjmp	.+216    	; 0x15ae <__vector_16+0x116>
		return;
	muxdiv = 0;
    14d6:	10 92 51 02 	sts	0x0251, r1
    14da:	10 92 50 02 	sts	0x0250, r1
	// now at 100Hz * digits

	// ok its not really 1ms but its like within 10% :)
	milliseconds++;
    14de:	80 91 56 02 	lds	r24, 0x0256
    14e2:	90 91 57 02 	lds	r25, 0x0257
    14e6:	01 96       	adiw	r24, 0x01	; 1
    14e8:	90 93 57 02 	sts	0x0257, r25
    14ec:	80 93 56 02 	sts	0x0256, r24

	// Cycle through each digit in the display
	if (currdigit >= DISPLAYSIZE)
    14f0:	80 91 4f 02 	lds	r24, 0x024F
    14f4:	89 30       	cpi	r24, 0x09	; 9
    14f6:	10 f0       	brcs	.+4      	; 0x14fc <__vector_16+0x64>
		currdigit = 0;
    14f8:	10 92 4f 02 	sts	0x024F, r1

	// Set the current display's segments
	setdisplay(currdigit, display[currdigit]);
    14fc:	80 91 4f 02 	lds	r24, 0x024F
    1500:	e8 2f       	mov	r30, r24
    1502:	f0 e0       	ldi	r31, 0x00	; 0
    1504:	ea 51       	subi	r30, 0x1A	; 26
    1506:	fd 4f       	sbci	r31, 0xFD	; 253
    1508:	60 81       	ld	r22, Z
    150a:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <setdisplay>
	// and go to the next
	currdigit++;
    150e:	80 91 4f 02 	lds	r24, 0x024F
    1512:	8f 5f       	subi	r24, 0xFF	; 255
    1514:	80 93 4f 02 	sts	0x024F, r24

	// check if we should have the alarm on
	if (alarming && !snoozetimer) {
    1518:	80 91 f3 02 	lds	r24, 0x02F3
    151c:	88 23       	and	r24, r24
    151e:	09 f4       	brne	.+2      	; 0x1522 <__vector_16+0x8a>
    1520:	46 c0       	rjmp	.+140    	; 0x15ae <__vector_16+0x116>
    1522:	80 91 54 02 	lds	r24, 0x0254
    1526:	90 91 55 02 	lds	r25, 0x0255
    152a:	89 2b       	or	r24, r25
    152c:	09 f0       	breq	.+2      	; 0x1530 <__vector_16+0x98>
    152e:	3f c0       	rjmp	.+126    	; 0x15ae <__vector_16+0x116>
		alarmdiv++;
    1530:	80 91 52 02 	lds	r24, 0x0252
    1534:	90 91 53 02 	lds	r25, 0x0253
    1538:	01 96       	adiw	r24, 0x01	; 1
    153a:	90 93 53 02 	sts	0x0253, r25
    153e:	80 93 52 02 	sts	0x0252, r24
		if (alarmdiv > ALARM_DIVIDER) {
    1542:	85 36       	cpi	r24, 0x65	; 101
    1544:	91 05       	cpc	r25, r1
    1546:	98 f1       	brcs	.+102    	; 0x15ae <__vector_16+0x116>
			alarmdiv = 0;
    1548:	10 92 53 02 	sts	0x0253, r1
    154c:	10 92 52 02 	sts	0x0252, r1
			return;
		}
		// This part only gets reached at 1Hz

		// This sets the buzzer frequency
		ICR1 = 250;
    1550:	8a ef       	ldi	r24, 0xFA	; 250
    1552:	90 e0       	ldi	r25, 0x00	; 0
    1554:	90 93 87 00 	sts	0x0087, r25
    1558:	80 93 86 00 	sts	0x0086, r24
		OCR1A = OCR1B = ICR1/2;
    155c:	80 91 86 00 	lds	r24, 0x0086
    1560:	90 91 87 00 	lds	r25, 0x0087
    1564:	96 95       	lsr	r25
    1566:	87 95       	ror	r24
    1568:	90 93 8b 00 	sts	0x008B, r25
    156c:	80 93 8a 00 	sts	0x008A, r24
    1570:	80 91 8a 00 	lds	r24, 0x008A
    1574:	90 91 8b 00 	lds	r25, 0x008B
    1578:	90 93 89 00 	sts	0x0089, r25
    157c:	80 93 88 00 	sts	0x0088, r24

		// ok alarm is ringing!
		if (alarming & 0xF0) { // top bit indicates pulsing alarm state
    1580:	80 91 f3 02 	lds	r24, 0x02F3
    1584:	80 7f       	andi	r24, 0xF0	; 240
    1586:	49 f0       	breq	.+18     	; 0x159a <__vector_16+0x102>
			alarming &= ~0xF0;
    1588:	80 91 f3 02 	lds	r24, 0x02F3
    158c:	8f 70       	andi	r24, 0x0F	; 15
    158e:	80 93 f3 02 	sts	0x02F3, r24
			TCCR1B &= ~_BV(CS11); // turn buzzer off!
    1592:	80 91 81 00 	lds	r24, 0x0081
    1596:	8d 7f       	andi	r24, 0xFD	; 253
    1598:	08 c0       	rjmp	.+16     	; 0x15aa <__vector_16+0x112>
		} else {
			alarming |= 0xF0;
    159a:	80 91 f3 02 	lds	r24, 0x02F3
    159e:	80 6f       	ori	r24, 0xF0	; 240
    15a0:	80 93 f3 02 	sts	0x02F3, r24
			TCCR1B |= _BV(CS11); // turn buzzer on!
    15a4:	80 91 81 00 	lds	r24, 0x0081
    15a8:	82 60       	ori	r24, 0x02	; 2
    15aa:	80 93 81 00 	sts	0x0081, r24
		}
	}

}
    15ae:	ff 91       	pop	r31
    15b0:	ef 91       	pop	r30
    15b2:	bf 91       	pop	r27
    15b4:	af 91       	pop	r26
    15b6:	9f 91       	pop	r25
    15b8:	8f 91       	pop	r24
    15ba:	7f 91       	pop	r23
    15bc:	6f 91       	pop	r22
    15be:	5f 91       	pop	r21
    15c0:	4f 91       	pop	r20
    15c2:	3f 91       	pop	r19
    15c4:	2f 91       	pop	r18
    15c6:	0f 90       	pop	r0
    15c8:	0f be       	out	0x3f, r0	; 63
    15ca:	0f 90       	pop	r0
    15cc:	1f 90       	pop	r1
    15ce:	18 95       	reti

000015d0 <spi_xfer>:
}

// Send 1 byte via SPI
void spi_xfer(uint8_t c) {

	SPDR = c;
    15d0:	8e bd       	out	0x2e, r24	; 46
	while (! (SPSR & _BV(SPIF)));
    15d2:	0d b4       	in	r0, 0x2d	; 45
    15d4:	07 fe       	sbrs	r0, 7
    15d6:	fd cf       	rjmp	.-6      	; 0x15d2 <spi_xfer+0x2>
}
    15d8:	08 95       	ret

000015da <gpsdataready>:
//GPS serial data handling functions:

//Check to see if there is any serial data.
uint8_t gpsdataready(void) {

	return (UCSR0A & _BV(RXC0));
    15da:	80 91 c0 00 	lds	r24, 0x00C0

}
    15de:	80 78       	andi	r24, 0x80	; 128
    15e0:	08 95       	ret

000015e2 <setgpstime>:
	}

}

//Set the time with a string taken from GPS data:
void setgpstime(char* str) {
    15e2:	fc 01       	movw	r30, r24

	intTempHr = (str[0] - '0') * 10;
	intTempHr = intTempHr + (str[1] - '0');

	intTempMin = (str[2] - '0') * 10;
	intTempMin = intTempMin + (str[3] - '0');
    15e4:	53 81       	ldd	r21, Z+3	; 0x03
    15e6:	50 51       	subi	r21, 0x10	; 16
    15e8:	82 81       	ldd	r24, Z+2	; 0x02
    15ea:	4a e0       	ldi	r20, 0x0A	; 10
    15ec:	84 9f       	mul	r24, r20
    15ee:	c0 01       	movw	r24, r0
    15f0:	11 24       	eor	r1, r1
    15f2:	58 0f       	add	r21, r24

	intTempSec = (str[4] - '0') * 10;
    15f4:	74 81       	ldd	r23, Z+4	; 0x04
	intTempSec = intTempSec + (str[5] - '0');
    15f6:	65 81       	ldd	r22, Z+5	; 0x05

	time_h = intTempHr + intTimeZoneHour;
    15f8:	30 91 44 02 	lds	r19, 0x0244
    15fc:	23 2f       	mov	r18, r19
    15fe:	20 51       	subi	r18, 0x10	; 16
    1600:	81 81       	ldd	r24, Z+1	; 0x01
    1602:	28 0f       	add	r18, r24
    1604:	80 81       	ld	r24, Z
    1606:	84 9f       	mul	r24, r20
    1608:	c0 01       	movw	r24, r0
    160a:	11 24       	eor	r1, r1
    160c:	28 0f       	add	r18, r24
    160e:	20 93 61 02 	sts	0x0261, r18
    1612:	80 91 4d 02 	lds	r24, 0x024D

	//If the time zone offset is negative, then subtract minutes
	if ( 0 > intTimeZoneHour )
    1616:	37 ff       	sbrs	r19, 7
    1618:	02 c0       	rjmp	.+4      	; 0x161e <setgpstime+0x3c>
		time_m = intTempMin - intTimeZoneMin;
    161a:	58 1b       	sub	r21, r24
    161c:	01 c0       	rjmp	.+2      	; 0x1620 <setgpstime+0x3e>
	else
		time_m = intTempMin + intTimeZoneMin;
    161e:	58 0f       	add	r21, r24
    1620:	50 93 ef 02 	sts	0x02EF, r21

	time_s = intTempSec;
    1624:	60 51       	subi	r22, 0x10	; 16
    1626:	8a e0       	ldi	r24, 0x0A	; 10
    1628:	78 9f       	mul	r23, r24
    162a:	c0 01       	movw	r24, r0
    162c:	11 24       	eor	r1, r1
    162e:	68 0f       	add	r22, r24
    1630:	60 93 f6 02 	sts	0x02F6, r22

	// Adjust forward 1 second to compensate for delayed update
	time_s++;
    1634:	80 91 f6 02 	lds	r24, 0x02F6
    1638:	8f 5f       	subi	r24, 0xFF	; 255
    163a:	80 93 f6 02 	sts	0x02F6, r24

	if (time_s>=60) {
    163e:	80 91 f6 02 	lds	r24, 0x02F6
    1642:	8c 33       	cpi	r24, 0x3C	; 60
    1644:	0c f1       	brlt	.+66     	; 0x1688 <setgpstime+0xa6>
		time_s-=60;
    1646:	80 91 f6 02 	lds	r24, 0x02F6
    164a:	8c 53       	subi	r24, 0x3C	; 60
    164c:	80 93 f6 02 	sts	0x02F6, r24
		time_m++;
    1650:	80 91 ef 02 	lds	r24, 0x02EF
    1654:	8f 5f       	subi	r24, 0xFF	; 255
    1656:	80 93 ef 02 	sts	0x02EF, r24
		if (time_m>=60) {
    165a:	80 91 ef 02 	lds	r24, 0x02EF
    165e:	8c 33       	cpi	r24, 0x3C	; 60
    1660:	9c f0       	brlt	.+38     	; 0x1688 <setgpstime+0xa6>
			time_m-=60;
    1662:	80 91 ef 02 	lds	r24, 0x02EF
    1666:	8c 53       	subi	r24, 0x3C	; 60
    1668:	80 93 ef 02 	sts	0x02EF, r24
			time_h++;
    166c:	80 91 61 02 	lds	r24, 0x0261
    1670:	8f 5f       	subi	r24, 0xFF	; 255
    1672:	80 93 61 02 	sts	0x0261, r24
			if (time_h>=24) {
    1676:	80 91 61 02 	lds	r24, 0x0261
    167a:	88 31       	cpi	r24, 0x18	; 24
    167c:	2c f0       	brlt	.+10     	; 0x1688 <setgpstime+0xa6>
				time_h-=24;
    167e:	80 91 61 02 	lds	r24, 0x0261
    1682:	88 51       	subi	r24, 0x18	; 24
    1684:	80 93 61 02 	sts	0x0261, r24
    1688:	08 95       	ret

0000168a <setgpsdate>:
		}
	}
}

//Set the date with a string taken from GPS data:
void setgpsdate(char* str) {
    168a:	fc 01       	movw	r30, r24
	uint8_t intTempDay = 0;
	uint8_t intTempMon = 0;
	uint8_t intTempYr = 0;

	intTempDay = (str[0] - '0') * 10;
	intTempDay = intTempDay + (str[1] - '0');
    168c:	51 81       	ldd	r21, Z+1	; 0x01
    168e:	50 51       	subi	r21, 0x10	; 16
    1690:	80 81       	ld	r24, Z
    1692:	4a e0       	ldi	r20, 0x0A	; 10
    1694:	84 9f       	mul	r24, r20
    1696:	c0 01       	movw	r24, r0
    1698:	11 24       	eor	r1, r1
    169a:	58 0f       	add	r21, r24

	intTempMon = (str[2] - '0') * 10;
	intTempMon = intTempMon + (str[3] - '0');
    169c:	33 81       	ldd	r19, Z+3	; 0x03
    169e:	30 51       	subi	r19, 0x10	; 16
    16a0:	82 81       	ldd	r24, Z+2	; 0x02
    16a2:	84 9f       	mul	r24, r20
    16a4:	c0 01       	movw	r24, r0
    16a6:	11 24       	eor	r1, r1
    16a8:	38 0f       	add	r19, r24

	intTempYr = (str[4] - '0') * 10;
	intTempYr = intTempYr + (str[5] - '0');
    16aa:	25 81       	ldd	r18, Z+5	; 0x05
    16ac:	20 51       	subi	r18, 0x10	; 16
    16ae:	84 81       	ldd	r24, Z+4	; 0x04
    16b0:	84 9f       	mul	r24, r20
    16b2:	c0 01       	movw	r24, r0
    16b4:	11 24       	eor	r1, r1
    16b6:	28 0f       	add	r18, r24

	timeunknown = 0;
    16b8:	10 92 4a 02 	sts	0x024A, r1
	restored = 0;
    16bc:	10 92 4b 02 	sts	0x024B, r1

	date_d = intTempDay;
    16c0:	50 93 e5 02 	sts	0x02E5, r21
	date_m = intTempMon;
    16c4:	30 93 f5 02 	sts	0x02F5, r19
	date_y = intTempYr;
    16c8:	20 93 e2 02 	sts	0x02E2, r18

}
    16cc:	08 95       	ret

000016ce <fix_time>:

//Fixes the time variables whenever time is changed
void fix_time(void) {

	// a minute!
	if (time_s >= 60) {
    16ce:	80 91 f6 02 	lds	r24, 0x02F6
    16d2:	8c 33       	cpi	r24, 0x3C	; 60
    16d4:	54 f0       	brlt	.+20     	; 0x16ea <fix_time+0x1c>
		time_s = time_s - 60;
    16d6:	80 91 f6 02 	lds	r24, 0x02F6
    16da:	8c 53       	subi	r24, 0x3C	; 60
    16dc:	80 93 f6 02 	sts	0x02F6, r24
		time_m++;
    16e0:	80 91 ef 02 	lds	r24, 0x02EF
    16e4:	8f 5f       	subi	r24, 0xFF	; 255
    16e6:	80 93 ef 02 	sts	0x02EF, r24
	}
	// If someone decides to make offset seconds with a negative number...
	if (time_s < 0) {
    16ea:	80 91 f6 02 	lds	r24, 0x02F6
    16ee:	87 ff       	sbrs	r24, 7
    16f0:	0a c0       	rjmp	.+20     	; 0x1706 <fix_time+0x38>
		time_s =  60 + time_s;
    16f2:	80 91 f6 02 	lds	r24, 0x02F6
    16f6:	84 5c       	subi	r24, 0xC4	; 196
    16f8:	80 93 f6 02 	sts	0x02F6, r24
		time_m--;
    16fc:	80 91 ef 02 	lds	r24, 0x02EF
    1700:	81 50       	subi	r24, 0x01	; 1
    1702:	80 93 ef 02 	sts	0x02EF, r24
	}

	// an hour...
	if (time_m >= 60) {
    1706:	80 91 ef 02 	lds	r24, 0x02EF
    170a:	8c 33       	cpi	r24, 0x3C	; 60
    170c:	44 f1       	brlt	.+80     	; 0x175e <fix_time+0x90>
		time_m = time_m - 60;
    170e:	80 91 ef 02 	lds	r24, 0x02EF
    1712:	8c 53       	subi	r24, 0x3C	; 60
    1714:	80 93 ef 02 	sts	0x02EF, r24
		time_h++; 
    1718:	80 91 61 02 	lds	r24, 0x0261
    171c:	8f 5f       	subi	r24, 0xFF	; 255
    171e:	80 93 61 02 	sts	0x0261, r24
		// let's write the time to the EEPROM
		eeprom_write_byte((uint8_t *)EE_HOUR, time_h);
    1722:	20 91 61 02 	lds	r18, 0x0261
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1726:	f9 99       	sbic	0x1f, 1	; 31
    1728:	fe cf       	rjmp	.-4      	; 0x1726 <fix_time+0x58>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    172a:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    172c:	84 e0       	ldi	r24, 0x04	; 4
    172e:	90 e0       	ldi	r25, 0x00	; 0
    1730:	92 bd       	out	0x22, r25	; 34
    1732:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    1734:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    1736:	0f b6       	in	r0, 0x3f	; 63
    1738:	f8 94       	cli
    173a:	fa 9a       	sbi	0x1f, 2	; 31
    173c:	f9 9a       	sbi	0x1f, 1	; 31
    173e:	0f be       	out	0x3f, r0	; 63
		eeprom_write_byte((uint8_t *)EE_MIN, time_m);
    1740:	20 91 ef 02 	lds	r18, 0x02EF
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1744:	f9 99       	sbic	0x1f, 1	; 31
    1746:	fe cf       	rjmp	.-4      	; 0x1744 <fix_time+0x76>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1748:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    174a:	85 e0       	ldi	r24, 0x05	; 5
    174c:	90 e0       	ldi	r25, 0x00	; 0
    174e:	92 bd       	out	0x22, r25	; 34
    1750:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    1752:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    1754:	0f b6       	in	r0, 0x3f	; 63
    1756:	f8 94       	cli
    1758:	fa 9a       	sbi	0x1f, 2	; 31
    175a:	f9 9a       	sbi	0x1f, 1	; 31
    175c:	0f be       	out	0x3f, r0	; 63
	}
	// When offsets create negative minutes...
	if (time_m < 0) {
    175e:	80 91 ef 02 	lds	r24, 0x02EF
    1762:	87 ff       	sbrs	r24, 7
    1764:	28 c0       	rjmp	.+80     	; 0x17b6 <fix_time+0xe8>
		time_m = 60 + time_m;
    1766:	80 91 ef 02 	lds	r24, 0x02EF
    176a:	84 5c       	subi	r24, 0xC4	; 196
    176c:	80 93 ef 02 	sts	0x02EF, r24
		time_h--; 
    1770:	80 91 61 02 	lds	r24, 0x0261
    1774:	81 50       	subi	r24, 0x01	; 1
    1776:	80 93 61 02 	sts	0x0261, r24
		eeprom_write_byte((uint8_t *)EE_HOUR, time_h);
    177a:	20 91 61 02 	lds	r18, 0x0261
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    177e:	f9 99       	sbic	0x1f, 1	; 31
    1780:	fe cf       	rjmp	.-4      	; 0x177e <fix_time+0xb0>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1782:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1784:	84 e0       	ldi	r24, 0x04	; 4
    1786:	90 e0       	ldi	r25, 0x00	; 0
    1788:	92 bd       	out	0x22, r25	; 34
    178a:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    178c:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    178e:	0f b6       	in	r0, 0x3f	; 63
    1790:	f8 94       	cli
    1792:	fa 9a       	sbi	0x1f, 2	; 31
    1794:	f9 9a       	sbi	0x1f, 1	; 31
    1796:	0f be       	out	0x3f, r0	; 63
		eeprom_write_byte((uint8_t *)EE_MIN, time_m);
    1798:	20 91 ef 02 	lds	r18, 0x02EF
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    179c:	f9 99       	sbic	0x1f, 1	; 31
    179e:	fe cf       	rjmp	.-4      	; 0x179c <fix_time+0xce>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    17a0:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    17a2:	85 e0       	ldi	r24, 0x05	; 5
    17a4:	90 e0       	ldi	r25, 0x00	; 0
    17a6:	92 bd       	out	0x22, r25	; 34
    17a8:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    17aa:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    17ac:	0f b6       	in	r0, 0x3f	; 63
    17ae:	f8 94       	cli
    17b0:	fa 9a       	sbi	0x1f, 2	; 31
    17b2:	f9 9a       	sbi	0x1f, 1	; 31
    17b4:	0f be       	out	0x3f, r0	; 63
	}

	// a day....
	if (time_h >= 24) {
    17b6:	80 91 61 02 	lds	r24, 0x0261
    17ba:	88 31       	cpi	r24, 0x18	; 24
    17bc:	cc f0       	brlt	.+50     	; 0x17f0 <fix_time+0x122>
		time_h = time_h - 24;
    17be:	80 91 61 02 	lds	r24, 0x0261
    17c2:	88 51       	subi	r24, 0x18	; 24
    17c4:	80 93 61 02 	sts	0x0261, r24
		date_d++;
    17c8:	80 91 e5 02 	lds	r24, 0x02E5
    17cc:	8f 5f       	subi	r24, 0xFF	; 255
    17ce:	80 93 e5 02 	sts	0x02E5, r24
		eeprom_write_byte((uint8_t *)EE_DAY, date_d);
    17d2:	20 91 e5 02 	lds	r18, 0x02E5
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    17d6:	f9 99       	sbic	0x1f, 1	; 31
    17d8:	fe cf       	rjmp	.-4      	; 0x17d6 <fix_time+0x108>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    17da:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    17dc:	83 e0       	ldi	r24, 0x03	; 3
    17de:	90 e0       	ldi	r25, 0x00	; 0
    17e0:	92 bd       	out	0x22, r25	; 34
    17e2:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    17e4:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    17e6:	0f b6       	in	r0, 0x3f	; 63
    17e8:	f8 94       	cli
    17ea:	fa 9a       	sbi	0x1f, 2	; 31
    17ec:	f9 9a       	sbi	0x1f, 1	; 31
    17ee:	0f be       	out	0x3f, r0	; 63
	}
	// When offsets create negative hours...
	if (time_h < 0) {
    17f0:	80 91 61 02 	lds	r24, 0x0261
    17f4:	87 ff       	sbrs	r24, 7
    17f6:	19 c0       	rjmp	.+50     	; 0x182a <fix_time+0x15c>
		time_h = 24 + time_h;
    17f8:	80 91 61 02 	lds	r24, 0x0261
    17fc:	88 5e       	subi	r24, 0xE8	; 232
    17fe:	80 93 61 02 	sts	0x0261, r24
		date_d--;
    1802:	80 91 e5 02 	lds	r24, 0x02E5
    1806:	81 50       	subi	r24, 0x01	; 1
    1808:	80 93 e5 02 	sts	0x02E5, r24
		eeprom_write_byte((uint8_t *)EE_DAY, date_d);
    180c:	20 91 e5 02 	lds	r18, 0x02E5
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1810:	f9 99       	sbic	0x1f, 1	; 31
    1812:	fe cf       	rjmp	.-4      	; 0x1810 <fix_time+0x142>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1814:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1816:	83 e0       	ldi	r24, 0x03	; 3
    1818:	90 e0       	ldi	r25, 0x00	; 0
    181a:	92 bd       	out	0x22, r25	; 34
    181c:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    181e:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    1820:	0f b6       	in	r0, 0x3f	; 63
    1822:	f8 94       	cli
    1824:	fa 9a       	sbi	0x1f, 2	; 31
    1826:	f9 9a       	sbi	0x1f, 1	; 31
    1828:	0f be       	out	0x3f, r0	; 63
	//}


	// a full month!
	// we check the leapyear and date to verify when it's time to roll over months
	if ((date_d > 31) ||
    182a:	80 91 e5 02 	lds	r24, 0x02E5
    182e:	80 32       	cpi	r24, 0x20	; 32
    1830:	7c f5       	brge	.+94     	; 0x1890 <fix_time+0x1c2>
    1832:	80 91 e5 02 	lds	r24, 0x02E5
    1836:	8f 31       	cpi	r24, 0x1F	; 31
    1838:	81 f4       	brne	.+32     	; 0x185a <fix_time+0x18c>
    183a:	80 91 f5 02 	lds	r24, 0x02F5
    183e:	84 30       	cpi	r24, 0x04	; 4
    1840:	39 f1       	breq	.+78     	; 0x1890 <fix_time+0x1c2>
    1842:	80 91 f5 02 	lds	r24, 0x02F5
    1846:	86 30       	cpi	r24, 0x06	; 6
    1848:	19 f1       	breq	.+70     	; 0x1890 <fix_time+0x1c2>
    184a:	80 91 f5 02 	lds	r24, 0x02F5
    184e:	89 30       	cpi	r24, 0x09	; 9
    1850:	f9 f0       	breq	.+62     	; 0x1890 <fix_time+0x1c2>
    1852:	80 91 f5 02 	lds	r24, 0x02F5
    1856:	8b 30       	cpi	r24, 0x0B	; 11
    1858:	d9 f0       	breq	.+54     	; 0x1890 <fix_time+0x1c2>
    185a:	80 91 e5 02 	lds	r24, 0x02E5
    185e:	8e 31       	cpi	r24, 0x1E	; 30
    1860:	21 f4       	brne	.+8      	; 0x186a <fix_time+0x19c>
    1862:	80 91 f5 02 	lds	r24, 0x02F5
    1866:	82 30       	cpi	r24, 0x02	; 2
    1868:	99 f0       	breq	.+38     	; 0x1890 <fix_time+0x1c2>
    186a:	80 91 e5 02 	lds	r24, 0x02E5
    186e:	8d 31       	cpi	r24, 0x1D	; 29
    1870:	31 f5       	brne	.+76     	; 0x18be <fix_time+0x1f0>
    1872:	80 91 f5 02 	lds	r24, 0x02F5
    1876:	82 30       	cpi	r24, 0x02	; 2
    1878:	11 f5       	brne	.+68     	; 0x18be <fix_time+0x1f0>
    187a:	80 91 e2 02 	lds	r24, 0x02E2
    187e:	99 27       	eor	r25, r25
    1880:	87 fd       	sbrc	r24, 7
    1882:	90 95       	com	r25
    1884:	80 53       	subi	r24, 0x30	; 48
    1886:	98 4f       	sbci	r25, 0xF8	; 248
    1888:	0e 94 ca 01 	call	0x394	; 0x394 <leapyear>
    188c:	88 23       	and	r24, r24
    188e:	b9 f4       	brne	.+46     	; 0x18be <fix_time+0x1f0>
			((date_d == 31) && ((date_m == 4)||(date_m == 6)||(date_m == 9)||(date_m == 11))) ||
			((date_d == 30) && (date_m == 2)) ||
			((date_d == 29) && (date_m == 2) && !leapyear(2000+date_y))) {
		date_d = 1;
    1890:	81 e0       	ldi	r24, 0x01	; 1
    1892:	80 93 e5 02 	sts	0x02E5, r24
		date_m++;
    1896:	80 91 f5 02 	lds	r24, 0x02F5
    189a:	8f 5f       	subi	r24, 0xFF	; 255
    189c:	80 93 f5 02 	sts	0x02F5, r24
		eeprom_write_byte((uint8_t *)EE_MONTH, date_m);
    18a0:	20 91 f5 02 	lds	r18, 0x02F5
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    18a4:	f9 99       	sbic	0x1f, 1	; 31
    18a6:	fe cf       	rjmp	.-4      	; 0x18a4 <fix_time+0x1d6>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    18a8:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    18aa:	82 e0       	ldi	r24, 0x02	; 2
    18ac:	90 e0       	ldi	r25, 0x00	; 0
    18ae:	92 bd       	out	0x22, r25	; 34
    18b0:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    18b2:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    18b4:	0f b6       	in	r0, 0x3f	; 63
    18b6:	f8 94       	cli
    18b8:	fa 9a       	sbi	0x1f, 2	; 31
    18ba:	f9 9a       	sbi	0x1f, 1	; 31
    18bc:	0f be       	out	0x3f, r0	; 63
	}
	// When offsets create negative days...
	if (date_d < 1) {
    18be:	80 91 e5 02 	lds	r24, 0x02E5
    18c2:	18 16       	cp	r1, r24
    18c4:	0c f4       	brge	.+2      	; 0x18c8 <fix_time+0x1fa>
    18c6:	52 c0       	rjmp	.+164    	; 0x196c <fix_time+0x29e>
		//Find which month we are going back to:
		switch (date_m) {
    18c8:	80 91 f5 02 	lds	r24, 0x02F5
    18cc:	86 30       	cpi	r24, 0x06	; 6
    18ce:	d1 f0       	breq	.+52     	; 0x1904 <fix_time+0x236>
    18d0:	87 30       	cpi	r24, 0x07	; 7
    18d2:	64 f4       	brge	.+24     	; 0x18ec <fix_time+0x21e>
    18d4:	83 30       	cpi	r24, 0x03	; 3
    18d6:	29 f1       	breq	.+74     	; 0x1922 <fix_time+0x254>
    18d8:	84 30       	cpi	r24, 0x04	; 4
    18da:	1c f4       	brge	.+6      	; 0x18e2 <fix_time+0x214>
    18dc:	81 30       	cpi	r24, 0x01	; 1
    18de:	94 f4       	brge	.+36     	; 0x1904 <fix_time+0x236>
    18e0:	33 c0       	rjmp	.+102    	; 0x1948 <fix_time+0x27a>
    18e2:	84 30       	cpi	r24, 0x04	; 4
    18e4:	79 f0       	breq	.+30     	; 0x1904 <fix_time+0x236>
    18e6:	85 30       	cpi	r24, 0x05	; 5
    18e8:	79 f5       	brne	.+94     	; 0x1948 <fix_time+0x27a>
    18ea:	10 c0       	rjmp	.+32     	; 0x190c <fix_time+0x23e>
    18ec:	8a 30       	cpi	r24, 0x0A	; 10
    18ee:	1c f4       	brge	.+6      	; 0x18f6 <fix_time+0x228>
    18f0:	88 30       	cpi	r24, 0x08	; 8
    18f2:	44 f4       	brge	.+16     	; 0x1904 <fix_time+0x236>
    18f4:	0b c0       	rjmp	.+22     	; 0x190c <fix_time+0x23e>
    18f6:	8b 30       	cpi	r24, 0x0B	; 11
    18f8:	29 f0       	breq	.+10     	; 0x1904 <fix_time+0x236>
    18fa:	8b 30       	cpi	r24, 0x0B	; 11
    18fc:	3c f0       	brlt	.+14     	; 0x190c <fix_time+0x23e>
    18fe:	8c 30       	cpi	r24, 0x0C	; 12
    1900:	19 f5       	brne	.+70     	; 0x1948 <fix_time+0x27a>
    1902:	04 c0       	rjmp	.+8      	; 0x190c <fix_time+0x23e>
			case 4: //April -> March
			case 6: //June -> May
			case 8: //August -> July
			case 9: //September -> August
			case 11: //November -> October
				date_d = 31 + date_d;
    1904:	80 91 e5 02 	lds	r24, 0x02E5
    1908:	81 5e       	subi	r24, 0xE1	; 225
    190a:	03 c0       	rjmp	.+6      	; 0x1912 <fix_time+0x244>

			case 5: //May -> April
			case 7: //July -> June
			case 10: //October -> September
			case 12: //December -> November
				date_d = 30 + date_d;
    190c:	80 91 e5 02 	lds	r24, 0x02E5
    1910:	82 5e       	subi	r24, 0xE2	; 226
    1912:	80 93 e5 02 	sts	0x02E5, r24
				date_m--;
    1916:	80 91 f5 02 	lds	r24, 0x02F5
    191a:	81 50       	subi	r24, 0x01	; 1
    191c:	80 93 f5 02 	sts	0x02F5, r24
    1920:	16 c0       	rjmp	.+44     	; 0x194e <fix_time+0x280>
				break;

			case 3: //March -> February, the fun case
				//If we are in a leapyear, February is 29 days long...
				if ( leapyear(2000+date_y) )
    1922:	80 91 e2 02 	lds	r24, 0x02E2
    1926:	99 27       	eor	r25, r25
    1928:	87 fd       	sbrc	r24, 7
    192a:	90 95       	com	r25
    192c:	80 53       	subi	r24, 0x30	; 48
    192e:	98 4f       	sbci	r25, 0xF8	; 248
    1930:	0e 94 ca 01 	call	0x394	; 0x394 <leapyear>
    1934:	88 23       	and	r24, r24
    1936:	21 f0       	breq	.+8      	; 0x1940 <fix_time+0x272>
					date_d = 29 + date_d;
    1938:	80 91 e5 02 	lds	r24, 0x02E5
    193c:	83 5e       	subi	r24, 0xE3	; 227
    193e:	e9 cf       	rjmp	.-46     	; 0x1912 <fix_time+0x244>
				else //otherwise, it is 28 days long...
					date_d = 28 + date_d;
    1940:	80 91 e5 02 	lds	r24, 0x02E5
    1944:	84 5e       	subi	r24, 0xE4	; 228
    1946:	e5 cf       	rjmp	.-54     	; 0x1912 <fix_time+0x244>
				date_m--;
				break;
			default:
				date_d = 1;
    1948:	81 e0       	ldi	r24, 0x01	; 1
    194a:	80 93 e5 02 	sts	0x02E5, r24
				break;
		}

		eeprom_write_byte((uint8_t *)EE_MONTH, date_m);
    194e:	20 91 f5 02 	lds	r18, 0x02F5
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1952:	f9 99       	sbic	0x1f, 1	; 31
    1954:	fe cf       	rjmp	.-4      	; 0x1952 <fix_time+0x284>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1956:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1958:	82 e0       	ldi	r24, 0x02	; 2
    195a:	90 e0       	ldi	r25, 0x00	; 0
    195c:	92 bd       	out	0x22, r25	; 34
    195e:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    1960:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    1962:	0f b6       	in	r0, 0x3f	; 63
    1964:	f8 94       	cli
    1966:	fa 9a       	sbi	0x1f, 2	; 31
    1968:	f9 9a       	sbi	0x1f, 1	; 31
    196a:	0f be       	out	0x3f, r0	; 63
	}

	// HAPPY NEW YEAR!
	if (date_m >= 13) {
    196c:	80 91 f5 02 	lds	r24, 0x02F5
    1970:	8d 30       	cpi	r24, 0x0D	; 13
    1972:	bc f0       	brlt	.+46     	; 0x19a2 <fix_time+0x2d4>
		date_y++;
    1974:	80 91 e2 02 	lds	r24, 0x02E2
    1978:	8f 5f       	subi	r24, 0xFF	; 255
    197a:	80 93 e2 02 	sts	0x02E2, r24
		date_m = 1;
    197e:	81 e0       	ldi	r24, 0x01	; 1
    1980:	80 93 f5 02 	sts	0x02F5, r24
		eeprom_write_byte((uint8_t *)EE_YEAR, date_y);
    1984:	20 91 e2 02 	lds	r18, 0x02E2
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1988:	f9 99       	sbic	0x1f, 1	; 31
    198a:	fe cf       	rjmp	.-4      	; 0x1988 <fix_time+0x2ba>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    198c:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    198e:	81 e0       	ldi	r24, 0x01	; 1
    1990:	90 e0       	ldi	r25, 0x00	; 0
    1992:	92 bd       	out	0x22, r25	; 34
    1994:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    1996:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    1998:	0f b6       	in	r0, 0x3f	; 63
    199a:	f8 94       	cli
    199c:	fa 9a       	sbi	0x1f, 2	; 31
    199e:	f9 9a       	sbi	0x1f, 1	; 31
    19a0:	0f be       	out	0x3f, r0	; 63
	}
	//This takes away the years and is cheaper than any cream you can buy...
	if (date_m < 1) {
    19a2:	80 91 f5 02 	lds	r24, 0x02F5
    19a6:	18 16       	cp	r1, r24
    19a8:	44 f1       	brlt	.+80     	; 0x19fa <fix_time+0x32c>
		date_m = 12 + date_m;
    19aa:	80 91 f5 02 	lds	r24, 0x02F5
    19ae:	84 5f       	subi	r24, 0xF4	; 244
    19b0:	80 93 f5 02 	sts	0x02F5, r24
		date_y--;
    19b4:	80 91 e2 02 	lds	r24, 0x02E2
    19b8:	81 50       	subi	r24, 0x01	; 1
    19ba:	80 93 e2 02 	sts	0x02E2, r24
		eeprom_write_byte((uint8_t *)EE_MONTH, date_m);
    19be:	20 91 f5 02 	lds	r18, 0x02F5
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    19c2:	f9 99       	sbic	0x1f, 1	; 31
    19c4:	fe cf       	rjmp	.-4      	; 0x19c2 <fix_time+0x2f4>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    19c6:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    19c8:	82 e0       	ldi	r24, 0x02	; 2
    19ca:	90 e0       	ldi	r25, 0x00	; 0
    19cc:	92 bd       	out	0x22, r25	; 34
    19ce:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    19d0:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    19d2:	0f b6       	in	r0, 0x3f	; 63
    19d4:	f8 94       	cli
    19d6:	fa 9a       	sbi	0x1f, 2	; 31
    19d8:	f9 9a       	sbi	0x1f, 1	; 31
    19da:	0f be       	out	0x3f, r0	; 63
		eeprom_write_byte((uint8_t *)EE_YEAR, date_y);
    19dc:	20 91 e2 02 	lds	r18, 0x02E2
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    19e0:	f9 99       	sbic	0x1f, 1	; 31
    19e2:	fe cf       	rjmp	.-4      	; 0x19e0 <fix_time+0x312>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    19e4:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    19e6:	81 e0       	ldi	r24, 0x01	; 1
    19e8:	90 e0       	ldi	r25, 0x00	; 0
    19ea:	92 bd       	out	0x22, r25	; 34
    19ec:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    19ee:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    19f0:	0f b6       	in	r0, 0x3f	; 63
    19f2:	f8 94       	cli
    19f4:	fa 9a       	sbi	0x1f, 2	; 31
    19f6:	f9 9a       	sbi	0x1f, 1	; 31
    19f8:	0f be       	out	0x3f, r0	; 63
    19fa:	08 95       	ret

000019fc <check_alarm>:
	date_y = intTempYr;

}

//Checks the alarm against the passed time.
void check_alarm(uint8_t h, uint8_t m, uint8_t s) {
    19fc:	98 2f       	mov	r25, r24

	if (alarm_on && (alarm_h == h) && (alarm_m == m) && (0 == s)) {
    19fe:	80 91 f0 02 	lds	r24, 0x02F0
    1a02:	88 23       	and	r24, r24
    1a04:	b1 f0       	breq	.+44     	; 0x1a32 <check_alarm+0x36>
    1a06:	80 91 f1 02 	lds	r24, 0x02F1
    1a0a:	89 17       	cp	r24, r25
    1a0c:	91 f4       	brne	.+36     	; 0x1a32 <check_alarm+0x36>
    1a0e:	80 91 e3 02 	lds	r24, 0x02E3
    1a12:	86 17       	cp	r24, r22
    1a14:	71 f4       	brne	.+28     	; 0x1a32 <check_alarm+0x36>
    1a16:	44 23       	and	r20, r20
    1a18:	61 f4       	brne	.+24     	; 0x1a32 <check_alarm+0x36>
		DEBUGP("alarm on!");
    1a1a:	85 ea       	ldi	r24, 0xA5	; 165
    1a1c:	90 e0       	ldi	r25, 0x00	; 0
    1a1e:	61 e0       	ldi	r22, 0x01	; 1
    1a20:	0e 94 38 15 	call	0x2a70	; 0x2a70 <ROM_putstring>
		alarming = 1;
    1a24:	81 e0       	ldi	r24, 0x01	; 1
    1a26:	80 93 f3 02 	sts	0x02F3, r24
		snoozetimer = 0;
    1a2a:	10 92 55 02 	sts	0x0255, r1
    1a2e:	10 92 54 02 	sts	0x0254, r1
    1a32:	08 95       	ret

00001a34 <__vector_9>:
// This variable keeps track of whether we have not pressed any
// buttons in a few seconds, and turns off the menu display
volatile uint8_t timeoutcounter = 0;

// this goes off once a second
SIGNAL (TIMER2_OVF_vect) {
    1a34:	1f 92       	push	r1
    1a36:	0f 92       	push	r0
    1a38:	0f b6       	in	r0, 0x3f	; 63
    1a3a:	0f 92       	push	r0
    1a3c:	11 24       	eor	r1, r1
    1a3e:	2f 93       	push	r18
    1a40:	3f 93       	push	r19
    1a42:	4f 93       	push	r20
    1a44:	5f 93       	push	r21
    1a46:	6f 93       	push	r22
    1a48:	7f 93       	push	r23
    1a4a:	8f 93       	push	r24
    1a4c:	9f 93       	push	r25
    1a4e:	af 93       	push	r26
    1a50:	bf 93       	push	r27
    1a52:	ef 93       	push	r30
    1a54:	ff 93       	push	r31
	CLKPR = _BV(CLKPCE);  //MEME
    1a56:	80 e8       	ldi	r24, 0x80	; 128
    1a58:	80 93 61 00 	sts	0x0061, r24
	CLKPR = 0;
    1a5c:	10 92 61 00 	sts	0x0061, r1

	time_s++;             // one second has gone by
    1a60:	80 91 f6 02 	lds	r24, 0x02F6
    1a64:	8f 5f       	subi	r24, 0xFF	; 255
    1a66:	80 93 f6 02 	sts	0x02F6, r24

	fix_time();
    1a6a:	0e 94 67 0b 	call	0x16ce	; 0x16ce <fix_time>

	// If we're in low power mode we should get out now since the display is off
	if (sleepmode)
    1a6e:	80 91 49 02 	lds	r24, 0x0249
    1a72:	88 23       	and	r24, r24
    1a74:	09 f0       	breq	.+2      	; 0x1a78 <__vector_9+0x44>
    1a76:	5f c0       	rjmp	.+190    	; 0x1b36 <__vector_9+0x102>
		return;


	if (displaymode == SHOW_TIME) {
    1a78:	80 91 f4 02 	lds	r24, 0x02F4
    1a7c:	88 23       	and	r24, r24
    1a7e:	11 f5       	brne	.+68     	; 0x1ac4 <__vector_9+0x90>
		if (timeunknown && (time_s % 2)) {
    1a80:	80 91 4a 02 	lds	r24, 0x024A
    1a84:	88 23       	and	r24, r24
    1a86:	49 f0       	breq	.+18     	; 0x1a9a <__vector_9+0x66>
    1a88:	80 91 f6 02 	lds	r24, 0x02F6
    1a8c:	80 ff       	sbrs	r24, 0
    1a8e:	05 c0       	rjmp	.+10     	; 0x1a9a <__vector_9+0x66>
			display_str("        ");
    1a90:	82 ea       	ldi	r24, 0xA2	; 162
    1a92:	91 e0       	ldi	r25, 0x01	; 1
    1a94:	0e 94 9e 06 	call	0xd3c	; 0xd3c <display_str>
    1a98:	08 c0       	rjmp	.+16     	; 0x1aaa <__vector_9+0x76>
		} else {
			display_time(time_h, time_m, time_s);
    1a9a:	80 91 61 02 	lds	r24, 0x0261
    1a9e:	60 91 ef 02 	lds	r22, 0x02EF
    1aa2:	40 91 f6 02 	lds	r20, 0x02F6
    1aa6:	0e 94 2e 03 	call	0x65c	; 0x65c <display_time>
		}
		if (alarm_on)
    1aaa:	80 91 f0 02 	lds	r24, 0x02F0
    1aae:	88 23       	and	r24, r24
    1ab0:	21 f0       	breq	.+8      	; 0x1aba <__vector_9+0x86>
			display[0] |= 0x2;
    1ab2:	80 91 e6 02 	lds	r24, 0x02E6
    1ab6:	82 60       	ori	r24, 0x02	; 2
    1ab8:	03 c0       	rjmp	.+6      	; 0x1ac0 <__vector_9+0x8c>
		else 
			display[0] &= ~0x2;
    1aba:	80 91 e6 02 	lds	r24, 0x02E6
    1abe:	8d 7f       	andi	r24, 0xFD	; 253
    1ac0:	80 93 e6 02 	sts	0x02E6, r24
	ADCSRA |= _BV(ADIE);  // Enable ADC interrupt
}

// Start ADC conversion for dimmer
void dimmer_update(void) {
	if (brightness_level == 0) 
    1ac4:	80 91 f2 02 	lds	r24, 0x02F2
    1ac8:	88 23       	and	r24, r24
    1aca:	29 f4       	brne	.+10     	; 0x1ad6 <__vector_9+0xa2>
		ADCSRA |= _BV(ADSC);
    1acc:	80 91 7a 00 	lds	r24, 0x007A
    1ad0:	80 64       	ori	r24, 0x40	; 64
    1ad2:	80 93 7a 00 	sts	0x007A, r24
	}

#ifdef FEATURE_AUTODIM
	dimmer_update();
#endif
	check_alarm(time_h, time_m, time_s);
    1ad6:	80 91 61 02 	lds	r24, 0x0261
    1ada:	60 91 ef 02 	lds	r22, 0x02EF
    1ade:	40 91 f6 02 	lds	r20, 0x02F6
    1ae2:	0e 94 fe 0c 	call	0x19fc	; 0x19fc <check_alarm>

	if (timeoutcounter)
    1ae6:	80 91 5c 02 	lds	r24, 0x025C
    1aea:	88 23       	and	r24, r24
    1aec:	29 f0       	breq	.+10     	; 0x1af8 <__vector_9+0xc4>
		timeoutcounter--;
    1aee:	80 91 5c 02 	lds	r24, 0x025C
    1af2:	81 50       	subi	r24, 0x01	; 1
    1af4:	80 93 5c 02 	sts	0x025C, r24
	if (buttonholdcounter)
    1af8:	80 91 5b 02 	lds	r24, 0x025B
    1afc:	88 23       	and	r24, r24
    1afe:	29 f0       	breq	.+10     	; 0x1b0a <__vector_9+0xd6>
		buttonholdcounter--;
    1b00:	80 91 5b 02 	lds	r24, 0x025B
    1b04:	81 50       	subi	r24, 0x01	; 1
    1b06:	80 93 5b 02 	sts	0x025B, r24
	if (snoozetimer) {
    1b0a:	80 91 54 02 	lds	r24, 0x0254
    1b0e:	90 91 55 02 	lds	r25, 0x0255
    1b12:	00 97       	sbiw	r24, 0x00	; 0
    1b14:	81 f0       	breq	.+32     	; 0x1b36 <__vector_9+0x102>
		snoozetimer--;
    1b16:	01 97       	sbiw	r24, 0x01	; 1
    1b18:	90 93 55 02 	sts	0x0255, r25
    1b1c:	80 93 54 02 	sts	0x0254, r24
		if (snoozetimer % 2) 
    1b20:	80 ff       	sbrs	r24, 0
    1b22:	04 c0       	rjmp	.+8      	; 0x1b2c <__vector_9+0xf8>
			display[0] |= 0x2;
    1b24:	80 91 e6 02 	lds	r24, 0x02E6
    1b28:	82 60       	ori	r24, 0x02	; 2
    1b2a:	03 c0       	rjmp	.+6      	; 0x1b32 <__vector_9+0xfe>
		else
			display[0] &= ~0x2;
    1b2c:	80 91 e6 02 	lds	r24, 0x02E6
    1b30:	8d 7f       	andi	r24, 0xFD	; 253
    1b32:	80 93 e6 02 	sts	0x02E6, r24
	}
}
    1b36:	ff 91       	pop	r31
    1b38:	ef 91       	pop	r30
    1b3a:	bf 91       	pop	r27
    1b3c:	af 91       	pop	r26
    1b3e:	9f 91       	pop	r25
    1b40:	8f 91       	pop	r24
    1b42:	7f 91       	pop	r23
    1b44:	6f 91       	pop	r22
    1b46:	5f 91       	pop	r21
    1b48:	4f 91       	pop	r20
    1b4a:	3f 91       	pop	r19
    1b4c:	2f 91       	pop	r18
    1b4e:	0f 90       	pop	r0
    1b50:	0f be       	out	0x3f, r0	; 63
    1b52:	0f 90       	pop	r0
    1b54:	1f 90       	pop	r1
    1b56:	18 95       	reti

00001b58 <setalarmstate>:
}

// This turns on/off the alarm when the switch has been
// set. It also displays the alarm time
void setalarmstate(void) {
	if (ALARM_PIN & _BV(ALARM)) { 
    1b58:	4a 9b       	sbis	0x09, 2	; 9
    1b5a:	34 c0       	rjmp	.+104    	; 0x1bc4 <setalarmstate+0x6c>
		// Don't display the alarm/beep if we already have
		if  (!alarm_on) {
    1b5c:	80 91 f0 02 	lds	r24, 0x02F0
    1b60:	88 23       	and	r24, r24
    1b62:	09 f0       	breq	.+2      	; 0x1b66 <setalarmstate+0xe>
    1b64:	4c c0       	rjmp	.+152    	; 0x1bfe <setalarmstate+0xa6>
			// alarm on!
			alarm_on = 1;
    1b66:	81 e0       	ldi	r24, 0x01	; 1
    1b68:	80 93 f0 02 	sts	0x02F0, r24
			// reset snoozing
			snoozetimer = 0;
    1b6c:	10 92 55 02 	sts	0x0255, r1
    1b70:	10 92 54 02 	sts	0x0254, r1
			// show the status on the VFD tube
			display_str("alarm on");
    1b74:	8b ea       	ldi	r24, 0xAB	; 171
    1b76:	91 e0       	ldi	r25, 0x01	; 1
    1b78:	0e 94 9e 06 	call	0xd3c	; 0xd3c <display_str>
			// its not actually SHOW_SNOOZE but just anything but SHOW_TIME
			displaymode = SHOW_SNOOZE;
    1b7c:	89 e0       	ldi	r24, 0x09	; 9
    1b7e:	80 93 f4 02 	sts	0x02F4, r24

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    1b82:	78 94       	sei

	milliseconds = 0;
    1b84:	10 92 57 02 	sts	0x0257, r1
    1b88:	10 92 56 02 	sts	0x0256, r1
	while (milliseconds < ms);
    1b8c:	80 91 56 02 	lds	r24, 0x0256
    1b90:	90 91 57 02 	lds	r25, 0x0257
    1b94:	88 5e       	subi	r24, 0xE8	; 232
    1b96:	93 40       	sbci	r25, 0x03	; 3
    1b98:	c8 f3       	brcs	.-14     	; 0x1b8c <setalarmstate+0x34>
			display_str("alarm on");
			// its not actually SHOW_SNOOZE but just anything but SHOW_TIME
			displaymode = SHOW_SNOOZE;
			delayms(1000);
			// show the current alarm time set
			display_alarm(alarm_h, alarm_m);
    1b9a:	80 91 f1 02 	lds	r24, 0x02F1
    1b9e:	60 91 e3 02 	lds	r22, 0x02E3
    1ba2:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <display_alarm>

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    1ba6:	78 94       	sei

	milliseconds = 0;
    1ba8:	10 92 57 02 	sts	0x0257, r1
    1bac:	10 92 56 02 	sts	0x0256, r1
	while (milliseconds < ms);
    1bb0:	80 91 56 02 	lds	r24, 0x0256
    1bb4:	90 91 57 02 	lds	r25, 0x0257
    1bb8:	88 5e       	subi	r24, 0xE8	; 232
    1bba:	93 40       	sbci	r25, 0x03	; 3
    1bbc:	c8 f3       	brcs	.-14     	; 0x1bb0 <setalarmstate+0x58>
			delayms(1000);
			// show the current alarm time set
			display_alarm(alarm_h, alarm_m);
			delayms(1000);
			// after a second, go back to clock mode
			displaymode = SHOW_TIME;
    1bbe:	10 92 f4 02 	sts	0x02F4, r1
    1bc2:	08 95       	ret
		}
	} else {
		if (alarm_on) {
    1bc4:	80 91 f0 02 	lds	r24, 0x02F0
    1bc8:	88 23       	and	r24, r24
    1bca:	c9 f0       	breq	.+50     	; 0x1bfe <setalarmstate+0xa6>
			// turn off the alarm
			alarm_on = 0;
    1bcc:	10 92 f0 02 	sts	0x02F0, r1
			snoozetimer = 0;
    1bd0:	10 92 55 02 	sts	0x0255, r1
    1bd4:	10 92 54 02 	sts	0x0254, r1
			if (alarming) {
    1bd8:	80 91 f3 02 	lds	r24, 0x02F3
    1bdc:	88 23       	and	r24, r24
    1bde:	79 f0       	breq	.+30     	; 0x1bfe <setalarmstate+0xa6>
				// if the alarm is going off, we should turn it off
				// and quiet the speaker
				DEBUGP("alarm off");
    1be0:	8f ea       	ldi	r24, 0xAF	; 175
    1be2:	90 e0       	ldi	r25, 0x00	; 0
    1be4:	61 e0       	ldi	r22, 0x01	; 1
    1be6:	0e 94 38 15 	call	0x2a70	; 0x2a70 <ROM_putstring>
				alarming = 0;
    1bea:	10 92 f3 02 	sts	0x02F3, r1
				TCCR1B &= ~_BV(CS11); // turn it off!
    1bee:	80 91 81 00 	lds	r24, 0x0081
    1bf2:	8d 7f       	andi	r24, 0xFD	; 253
    1bf4:	80 93 81 00 	sts	0x0081, r24
				PORTB |= _BV(SPK1) | _BV(SPK2);
    1bf8:	85 b1       	in	r24, 0x05	; 5
    1bfa:	86 60       	ori	r24, 0x06	; 6
    1bfc:	85 b9       	out	0x05, r24	; 5
    1bfe:	08 95       	ret

00001c00 <set_date>:
	}
}



void set_date(void) {
    1c00:	bf 92       	push	r11
    1c02:	cf 92       	push	r12
    1c04:	df 92       	push	r13
    1c06:	ef 92       	push	r14
    1c08:	ff 92       	push	r15
    1c0a:	0f 93       	push	r16
    1c0c:	1f 93       	push	r17
    1c0e:	cf 93       	push	r28
    1c10:	df 93       	push	r29
	uint8_t mode = SHOW_MENU;

	timeoutcounter = INACTIVITYTIMEOUT;;  
    1c12:	8a e0       	ldi	r24, 0x0A	; 10
    1c14:	80 93 5c 02 	sts	0x025C, r24
    1c18:	10 e0       	ldi	r17, 0x00	; 0

	while (1) {
		if (just_pressed || pressed) {
			timeoutcounter = INACTIVITYTIMEOUT;;  
    1c1a:	0a e0       	ldi	r16, 0x0A	; 10
				display_date(DATE);
				display[1] |= 0x1;
				display[2] |= 0x1;
			} else if (((mode == SET_MONTH) && (region == REGION_US)) ||
					((mode == SET_DAY) && (region == REGION_EU))) {
				if (region == REGION_US)
    1c1c:	bb 24       	eor	r11, r11
    1c1e:	b3 94       	inc	r11
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1c20:	b1 e0       	ldi	r27, 0x01	; 1
    1c22:	eb 2e       	mov	r14, r27
    1c24:	f1 2c       	mov	r15, r1
	uint8_t mode = SHOW_MENU;

	timeoutcounter = INACTIVITYTIMEOUT;;  

	while (1) {
		if (just_pressed || pressed) {
    1c26:	a3 e0       	ldi	r26, 0x03	; 3
    1c28:	ca 2e       	mov	r12, r26
    1c2a:	d1 2c       	mov	r13, r1
    1c2c:	c2 e0       	ldi	r28, 0x02	; 2
    1c2e:	d0 e0       	ldi	r29, 0x00	; 0
    1c30:	80 91 59 02 	lds	r24, 0x0259
    1c34:	88 23       	and	r24, r24
    1c36:	21 f4       	brne	.+8      	; 0x1c40 <set_date+0x40>
    1c38:	80 91 5a 02 	lds	r24, 0x025A
    1c3c:	88 23       	and	r24, r24
    1c3e:	19 f0       	breq	.+6      	; 0x1c46 <set_date+0x46>
			timeoutcounter = INACTIVITYTIMEOUT;;  
    1c40:	00 93 5c 02 	sts	0x025C, r16
    1c44:	05 c0       	rjmp	.+10     	; 0x1c50 <set_date+0x50>
			// timeout w/no buttons pressed after 3 seconds?
		} else if (!timeoutcounter) {
    1c46:	80 91 5c 02 	lds	r24, 0x025C
    1c4a:	88 23       	and	r24, r24
    1c4c:	09 f4       	brne	.+2      	; 0x1c50 <set_date+0x50>
    1c4e:	72 c0       	rjmp	.+228    	; 0x1d34 <set_date+0x134>
			//timed out!
			displaymode = SHOW_TIME;     
			return;
		}
		if (just_pressed & 0x1) { // mode change
    1c50:	80 91 59 02 	lds	r24, 0x0259
    1c54:	80 fd       	sbrc	r24, 0
    1c56:	15 c1       	rjmp	.+554    	; 0x1e82 <set_date+0x282>
			return;
		}
		if (just_pressed & 0x2) {
    1c58:	80 91 59 02 	lds	r24, 0x0259
    1c5c:	81 ff       	sbrs	r24, 1
    1c5e:	6d c0       	rjmp	.+218    	; 0x1d3a <set_date+0x13a>

			just_pressed = 0;
    1c60:	10 92 59 02 	sts	0x0259, r1
			if (mode == SHOW_MENU) {
    1c64:	11 23       	and	r17, r17
    1c66:	d1 f4       	brne	.+52     	; 0x1c9c <set_date+0x9c>
				// start!
				if (region == REGION_US) {
    1c68:	80 91 48 02 	lds	r24, 0x0248
    1c6c:	88 23       	and	r24, r24
    1c6e:	11 f4       	brne	.+4      	; 0x1c74 <set_date+0x74>
    1c70:	11 e0       	ldi	r17, 0x01	; 1
    1c72:	06 c0       	rjmp	.+12     	; 0x1c80 <set_date+0x80>
					mode = SET_MONTH;
				}
				else {
					DEBUGP("Set day");
    1c74:	89 eb       	ldi	r24, 0xB9	; 185
    1c76:	90 e0       	ldi	r25, 0x00	; 0
    1c78:	61 e0       	ldi	r22, 0x01	; 1
    1c7a:	0e 94 38 15 	call	0x2a70	; 0x2a70 <ROM_putstring>
    1c7e:	12 e0       	ldi	r17, 0x02	; 2
					mode = SET_DAY;
				}
				display_date(DATE);
    1c80:	80 e0       	ldi	r24, 0x00	; 0
    1c82:	0e 94 c5 06 	call	0xd8a	; 0xd8a <display_date>
				display[1] |= 0x1;
    1c86:	80 91 e7 02 	lds	r24, 0x02E7
    1c8a:	81 60       	ori	r24, 0x01	; 1
    1c8c:	80 93 e7 02 	sts	0x02E7, r24
				display[2] |= 0x1;
    1c90:	80 91 e8 02 	lds	r24, 0x02E8
    1c94:	81 60       	ori	r24, 0x01	; 1
    1c96:	80 93 e8 02 	sts	0x02E8, r24
    1c9a:	4f c0       	rjmp	.+158    	; 0x1d3a <set_date+0x13a>
			} else if (((mode == SET_MONTH) && (region == REGION_US)) ||
    1c9c:	11 30       	cpi	r17, 0x01	; 1
    1c9e:	29 f4       	brne	.+10     	; 0x1caa <set_date+0xaa>
    1ca0:	80 91 48 02 	lds	r24, 0x0248
    1ca4:	88 23       	and	r24, r24
    1ca6:	39 f0       	breq	.+14     	; 0x1cb6 <set_date+0xb6>
    1ca8:	20 c0       	rjmp	.+64     	; 0x1cea <set_date+0xea>
    1caa:	12 30       	cpi	r17, 0x02	; 2
    1cac:	e1 f4       	brne	.+56     	; 0x1ce6 <set_date+0xe6>
    1cae:	80 91 48 02 	lds	r24, 0x0248
    1cb2:	81 30       	cpi	r24, 0x01	; 1
    1cb4:	a9 f4       	brne	.+42     	; 0x1ce0 <set_date+0xe0>
					((mode == SET_DAY) && (region == REGION_EU))) {
				if (region == REGION_US)
    1cb6:	80 91 48 02 	lds	r24, 0x0248
    1cba:	88 23       	and	r24, r24
    1cbc:	11 f0       	breq	.+4      	; 0x1cc2 <set_date+0xc2>
    1cbe:	11 e0       	ldi	r17, 0x01	; 1
    1cc0:	01 c0       	rjmp	.+2      	; 0x1cc4 <set_date+0xc4>
    1cc2:	12 e0       	ldi	r17, 0x02	; 2
					mode = SET_DAY;
				else
					mode = SET_MONTH;
				display_date(DATE);
    1cc4:	80 e0       	ldi	r24, 0x00	; 0
    1cc6:	0e 94 c5 06 	call	0xd8a	; 0xd8a <display_date>
				display[4] |= 0x1;
    1cca:	80 91 ea 02 	lds	r24, 0x02EA
    1cce:	81 60       	ori	r24, 0x01	; 1
    1cd0:	80 93 ea 02 	sts	0x02EA, r24
				display[5] |= 0x1;
    1cd4:	80 91 eb 02 	lds	r24, 0x02EB
    1cd8:	81 60       	ori	r24, 0x01	; 1
    1cda:	80 93 eb 02 	sts	0x02EB, r24
    1cde:	2d c0       	rjmp	.+90     	; 0x1d3a <set_date+0x13a>
			} else if (((mode == SET_DAY) && (region == REGION_US)) ||
    1ce0:	88 23       	and	r24, r24
    1ce2:	39 f0       	breq	.+14     	; 0x1cf2 <set_date+0xf2>
    1ce4:	15 c0       	rjmp	.+42     	; 0x1d10 <set_date+0x110>
    1ce6:	11 30       	cpi	r17, 0x01	; 1
    1ce8:	99 f4       	brne	.+38     	; 0x1d10 <set_date+0x110>
    1cea:	80 91 48 02 	lds	r24, 0x0248
    1cee:	81 30       	cpi	r24, 0x01	; 1
    1cf0:	79 f4       	brne	.+30     	; 0x1d10 <set_date+0x110>
					((mode == SET_MONTH) && (region == REGION_EU))) {
				mode = SET_YEAR;
				display_date(DATE);
    1cf2:	80 e0       	ldi	r24, 0x00	; 0
    1cf4:	0e 94 c5 06 	call	0xd8a	; 0xd8a <display_date>
				display[7] |= 0x1;
    1cf8:	80 91 ed 02 	lds	r24, 0x02ED
    1cfc:	81 60       	ori	r24, 0x01	; 1
    1cfe:	80 93 ed 02 	sts	0x02ED, r24
				display[8] |= 0x1;
    1d02:	80 91 ee 02 	lds	r24, 0x02EE
    1d06:	81 60       	ori	r24, 0x01	; 1
    1d08:	80 93 ee 02 	sts	0x02EE, r24
    1d0c:	13 e0       	ldi	r17, 0x03	; 3
    1d0e:	15 c0       	rjmp	.+42     	; 0x1d3a <set_date+0x13a>
			} else {
				displaymode = NONE;
    1d10:	83 e6       	ldi	r24, 0x63	; 99
    1d12:	80 93 f4 02 	sts	0x02F4, r24
				display_date(DATE);
    1d16:	80 e0       	ldi	r24, 0x00	; 0
    1d18:	0e 94 c5 06 	call	0xd8a	; 0xd8a <display_date>

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    1d1c:	78 94       	sei

	milliseconds = 0;
    1d1e:	10 92 57 02 	sts	0x0257, r1
    1d22:	10 92 56 02 	sts	0x0256, r1
	while (milliseconds < ms);
    1d26:	80 91 56 02 	lds	r24, 0x0256
    1d2a:	90 91 57 02 	lds	r25, 0x0257
    1d2e:	8c 5d       	subi	r24, 0xDC	; 220
    1d30:	95 40       	sbci	r25, 0x05	; 5
    1d32:	c8 f3       	brcs	.-14     	; 0x1d26 <set_date+0x126>
				display[8] |= 0x1;
			} else {
				displaymode = NONE;
				display_date(DATE);
				delayms(1500);
				displaymode = SHOW_TIME;
    1d34:	10 92 f4 02 	sts	0x02F4, r1
    1d38:	a4 c0       	rjmp	.+328    	; 0x1e82 <set_date+0x282>
				return;
			}
		}
		if ((just_pressed & 0x4) || (pressed & 0x4)) {
    1d3a:	80 91 59 02 	lds	r24, 0x0259
    1d3e:	82 fd       	sbrc	r24, 2
    1d40:	04 c0       	rjmp	.+8      	; 0x1d4a <set_date+0x14a>
    1d42:	80 91 5a 02 	lds	r24, 0x025A
    1d46:	82 ff       	sbrs	r24, 2
    1d48:	73 cf       	rjmp	.-282    	; 0x1c30 <set_date+0x30>
			just_pressed = 0;
    1d4a:	10 92 59 02 	sts	0x0259, r1
			if (mode == SET_MONTH) {
    1d4e:	11 30       	cpi	r17, 0x01	; 1
    1d50:	79 f5       	brne	.+94     	; 0x1db0 <set_date+0x1b0>
				date_m++;
    1d52:	80 91 f5 02 	lds	r24, 0x02F5
    1d56:	8f 5f       	subi	r24, 0xFF	; 255
    1d58:	80 93 f5 02 	sts	0x02F5, r24
				if (date_m >= 13)
    1d5c:	80 91 f5 02 	lds	r24, 0x02F5
    1d60:	8d 30       	cpi	r24, 0x0D	; 13
    1d62:	14 f0       	brlt	.+4      	; 0x1d68 <set_date+0x168>
					date_m = 1;
    1d64:	10 93 f5 02 	sts	0x02F5, r17
				display_date(DATE);
    1d68:	80 e0       	ldi	r24, 0x00	; 0
    1d6a:	0e 94 c5 06 	call	0xd8a	; 0xd8a <display_date>
				if (region == REGION_US) {
    1d6e:	80 91 48 02 	lds	r24, 0x0248
    1d72:	88 23       	and	r24, r24
    1d74:	59 f4       	brne	.+22     	; 0x1d8c <set_date+0x18c>
					display[1] |= 0x1;
    1d76:	80 91 e7 02 	lds	r24, 0x02E7
    1d7a:	81 60       	ori	r24, 0x01	; 1
    1d7c:	80 93 e7 02 	sts	0x02E7, r24
					display[2] |= 0x1;
    1d80:	80 91 e8 02 	lds	r24, 0x02E8
    1d84:	81 60       	ori	r24, 0x01	; 1
    1d86:	80 93 e8 02 	sts	0x02E8, r24
    1d8a:	0a c0       	rjmp	.+20     	; 0x1da0 <set_date+0x1a0>
				} else {
					display[4] |= 0x1;
    1d8c:	80 91 ea 02 	lds	r24, 0x02EA
    1d90:	81 60       	ori	r24, 0x01	; 1
    1d92:	80 93 ea 02 	sts	0x02EA, r24
					display[5] |= 0x1;
    1d96:	80 91 eb 02 	lds	r24, 0x02EB
    1d9a:	81 60       	ori	r24, 0x01	; 1
    1d9c:	80 93 eb 02 	sts	0x02EB, r24
				}
				eeprom_write_byte((uint8_t *)EE_MONTH, date_m);    
    1da0:	80 91 f5 02 	lds	r24, 0x02F5
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1da4:	f9 99       	sbic	0x1f, 1	; 31
    1da6:	fe cf       	rjmp	.-4      	; 0x1da4 <set_date+0x1a4>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1da8:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1daa:	d2 bd       	out	0x22, r29	; 34
    1dac:	c1 bd       	out	0x21, r28	; 33
    1dae:	53 c0       	rjmp	.+166    	; 0x1e56 <set_date+0x256>
			}
			if (mode == SET_DAY) {
    1db0:	12 30       	cpi	r17, 0x02	; 2
    1db2:	79 f5       	brne	.+94     	; 0x1e12 <set_date+0x212>
				date_d++;
    1db4:	80 91 e5 02 	lds	r24, 0x02E5
    1db8:	8f 5f       	subi	r24, 0xFF	; 255
    1dba:	80 93 e5 02 	sts	0x02E5, r24
				if (date_d > 31)
    1dbe:	80 91 e5 02 	lds	r24, 0x02E5
    1dc2:	80 32       	cpi	r24, 0x20	; 32
    1dc4:	14 f0       	brlt	.+4      	; 0x1dca <set_date+0x1ca>
					date_d = 1;
    1dc6:	b0 92 e5 02 	sts	0x02E5, r11
				display_date(DATE);
    1dca:	80 e0       	ldi	r24, 0x00	; 0
    1dcc:	0e 94 c5 06 	call	0xd8a	; 0xd8a <display_date>

				if (region == REGION_EU) {
    1dd0:	80 91 48 02 	lds	r24, 0x0248
    1dd4:	81 30       	cpi	r24, 0x01	; 1
    1dd6:	59 f4       	brne	.+22     	; 0x1dee <set_date+0x1ee>
					display[1] |= 0x1;
    1dd8:	80 91 e7 02 	lds	r24, 0x02E7
    1ddc:	81 60       	ori	r24, 0x01	; 1
    1dde:	80 93 e7 02 	sts	0x02E7, r24
					display[2] |= 0x1;
    1de2:	80 91 e8 02 	lds	r24, 0x02E8
    1de6:	81 60       	ori	r24, 0x01	; 1
    1de8:	80 93 e8 02 	sts	0x02E8, r24
    1dec:	0a c0       	rjmp	.+20     	; 0x1e02 <set_date+0x202>
				} else {
					display[4] |= 0x1;
    1dee:	80 91 ea 02 	lds	r24, 0x02EA
    1df2:	81 60       	ori	r24, 0x01	; 1
    1df4:	80 93 ea 02 	sts	0x02EA, r24
					display[5] |= 0x1;
    1df8:	80 91 eb 02 	lds	r24, 0x02EB
    1dfc:	81 60       	ori	r24, 0x01	; 1
    1dfe:	80 93 eb 02 	sts	0x02EB, r24
				}
				eeprom_write_byte((uint8_t *)EE_DAY, date_d);    
    1e02:	80 91 e5 02 	lds	r24, 0x02E5
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1e06:	f9 99       	sbic	0x1f, 1	; 31
    1e08:	fe cf       	rjmp	.-4      	; 0x1e06 <set_date+0x206>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1e0a:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1e0c:	d2 bc       	out	0x22, r13	; 34
    1e0e:	c1 bc       	out	0x21, r12	; 33
    1e10:	22 c0       	rjmp	.+68     	; 0x1e56 <set_date+0x256>
			}
			if (mode == SET_YEAR) {
    1e12:	13 30       	cpi	r17, 0x03	; 3
    1e14:	31 f5       	brne	.+76     	; 0x1e62 <set_date+0x262>
				date_y++;
    1e16:	80 91 e2 02 	lds	r24, 0x02E2
    1e1a:	8f 5f       	subi	r24, 0xFF	; 255
    1e1c:	80 93 e2 02 	sts	0x02E2, r24
				date_y %= 100;
    1e20:	80 91 e2 02 	lds	r24, 0x02E2
    1e24:	64 e6       	ldi	r22, 0x64	; 100
    1e26:	0e 94 a5 16 	call	0x2d4a	; 0x2d4a <__divmodqi4>
    1e2a:	90 93 e2 02 	sts	0x02E2, r25
				display_date(DATE);
    1e2e:	80 e0       	ldi	r24, 0x00	; 0
    1e30:	0e 94 c5 06 	call	0xd8a	; 0xd8a <display_date>
				display[7] |= 0x1;
    1e34:	80 91 ed 02 	lds	r24, 0x02ED
    1e38:	81 60       	ori	r24, 0x01	; 1
    1e3a:	80 93 ed 02 	sts	0x02ED, r24
				display[8] |= 0x1;
    1e3e:	80 91 ee 02 	lds	r24, 0x02EE
    1e42:	81 60       	ori	r24, 0x01	; 1
    1e44:	80 93 ee 02 	sts	0x02EE, r24
				eeprom_write_byte((uint8_t *)EE_YEAR, date_y);    
    1e48:	80 91 e2 02 	lds	r24, 0x02E2
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1e4c:	f9 99       	sbic	0x1f, 1	; 31
    1e4e:	fe cf       	rjmp	.-4      	; 0x1e4c <set_date+0x24c>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1e50:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1e52:	f2 bc       	out	0x22, r15	; 34
    1e54:	e1 bc       	out	0x21, r14	; 33
#endif
    EEDR = __value;
    1e56:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
    1e58:	0f b6       	in	r0, 0x3f	; 63
    1e5a:	f8 94       	cli
    1e5c:	fa 9a       	sbi	0x1f, 2	; 31
    1e5e:	f9 9a       	sbi	0x1f, 1	; 31
    1e60:	0f be       	out	0x3f, r0	; 63
			}

			if (pressed & 0x4)
    1e62:	80 91 5a 02 	lds	r24, 0x025A
    1e66:	82 ff       	sbrs	r24, 2
    1e68:	e3 ce       	rjmp	.-570    	; 0x1c30 <set_date+0x30>

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    1e6a:	78 94       	sei

	milliseconds = 0;
    1e6c:	10 92 57 02 	sts	0x0257, r1
    1e70:	10 92 56 02 	sts	0x0256, r1
	while (milliseconds < ms);
    1e74:	80 91 56 02 	lds	r24, 0x0256
    1e78:	90 91 57 02 	lds	r25, 0x0257
    1e7c:	cc 97       	sbiw	r24, 0x3c	; 60
    1e7e:	d0 f3       	brcs	.-12     	; 0x1e74 <set_date+0x274>
    1e80:	d7 ce       	rjmp	.-594    	; 0x1c30 <set_date+0x30>

			if (pressed & 0x4)
				delayms(60);
		}
	}
}
    1e82:	df 91       	pop	r29
    1e84:	cf 91       	pop	r28
    1e86:	1f 91       	pop	r17
    1e88:	0f 91       	pop	r16
    1e8a:	ff 90       	pop	r15
    1e8c:	ef 90       	pop	r14
    1e8e:	df 90       	pop	r13
    1e90:	cf 90       	pop	r12
    1e92:	bf 90       	pop	r11
    1e94:	08 95       	ret

00001e96 <wakeup>:
	CLKPR = 0;
	PORTC &= ~_BV(4);
}

void wakeup(void) {
	if (!sleepmode)
    1e96:	80 91 49 02 	lds	r24, 0x0249
    1e9a:	88 23       	and	r24, r24
    1e9c:	09 f4       	brne	.+2      	; 0x1ea0 <wakeup+0xa>
    1e9e:	58 c0       	rjmp	.+176    	; 0x1f50 <wakeup+0xba>
		return;
	CLKPR = _BV(CLKPCE);
    1ea0:	80 e8       	ldi	r24, 0x80	; 128
    1ea2:	80 93 61 00 	sts	0x0061, r24
	CLKPR = 0;
    1ea6:	10 92 61 00 	sts	0x0061, r1
	DEBUGP("waketime");
    1eaa:	80 e3       	ldi	r24, 0x30	; 48
    1eac:	91 e0       	ldi	r25, 0x01	; 1
    1eae:	61 e0       	ldi	r22, 0x01	; 1
    1eb0:	0e 94 38 15 	call	0x2a70	; 0x2a70 <ROM_putstring>
	sleepmode = 0;
    1eb4:	10 92 49 02 	sts	0x0249, r1
    1eb8:	80 e4       	ldi	r24, 0x40	; 64
    1eba:	9c e9       	ldi	r25, 0x9C	; 156
    1ebc:	01 97       	sbiw	r24, 0x01	; 1
    1ebe:	f1 f7       	brne	.-4      	; 0x1ebc <wakeup+0x26>
	// plugged in
	// wait to verify
	_delay_ms(20);
	if (ACSR & _BV(ACO)) 
    1ec0:	00 b6       	in	r0, 0x30	; 48
    1ec2:	05 fc       	sbrc	r0, 5
    1ec4:	45 c0       	rjmp	.+138    	; 0x1f50 <wakeup+0xba>
	kickthedog();
}


void initbuttons(void) {
	DDRB =  _BV(VFDCLK) | _BV(VFDDATA) | _BV(SPK1) | _BV(SPK2);
    1ec6:	8e e2       	ldi	r24, 0x2E	; 46
    1ec8:	84 b9       	out	0x04, r24	; 4
	DDRD = _BV(BOOST) | _BV(VFDSWITCH);
    1eca:	88 e4       	ldi	r24, 0x48	; 72
    1ecc:	8a b9       	out	0x0a, r24	; 10
	DDRC = _BV(VFDLOAD) | _BV(VFDBLANK);
    1ece:	89 e0       	ldi	r24, 0x09	; 9
    1ed0:	87 b9       	out	0x07, r24	; 7
	PORTD = _BV(BUTTON1) | _BV(BUTTON3) | _BV(ALARM);
    1ed2:	84 e3       	ldi	r24, 0x34	; 52
    1ed4:	8b b9       	out	0x0b, r24	; 11
	PORTB = _BV(BUTTON2);
    1ed6:	91 e0       	ldi	r25, 0x01	; 1
    1ed8:	95 b9       	out	0x05, r25	; 5

	PCICR = _BV(PCIE0) | _BV(PCIE2);
    1eda:	85 e0       	ldi	r24, 0x05	; 5
    1edc:	80 93 68 00 	sts	0x0068, r24
	PCMSK0 = _BV(PCINT0);
    1ee0:	90 93 6b 00 	sts	0x006B, r25
	PCMSK2 = _BV(PCINT21) | _BV(PCINT20);    
    1ee4:	80 e3       	ldi	r24, 0x30	; 48
    1ee6:	80 93 6d 00 	sts	0x006D, r24

	// turn on pullups
	initbuttons();

#ifdef FEATURE_AUTODIM
	dimmer_init();
    1eea:	0e 94 87 02 	call	0x50e	; 0x50e <dimmer_init>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1eee:	f9 99       	sbic	0x1f, 1	; 31
    1ef0:	fe cf       	rjmp	.-4      	; 0x1eee <wakeup+0x58>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    1ef2:	89 e0       	ldi	r24, 0x09	; 9
    1ef4:	90 e0       	ldi	r25, 0x00	; 0
    1ef6:	92 bd       	out	0x22, r25	; 34
    1ef8:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1efa:	f8 9a       	sbi	0x1f, 0	; 31
    1efc:	80 b5       	in	r24, 0x20	; 32
#endif

	// turn on boost
	brightness_level = eeprom_read_byte((uint8_t *)EE_BRIGHT);
    1efe:	80 93 f2 02 	sts	0x02F2, r24
	boost_init(brightness_level);
    1f02:	80 91 f2 02 	lds	r24, 0x02F2
    1f06:	0e 94 09 03 	call	0x612	; 0x612 <boost_init>

/************************* LOW LEVEL DISPLAY ************************/

// Setup SPI
void vfd_init(void) {
	SPCR  = _BV(SPE) | _BV(MSTR) | _BV(SPR0);
    1f0a:	81 e5       	ldi	r24, 0x51	; 81
    1f0c:	8c bd       	out	0x2c, r24	; 44

	// turn on vfd control
	vfd_init();

	// turn on display
	VFDSWITCH_PORT &= ~_BV(VFDSWITCH); 
    1f0e:	5b 98       	cbi	0x0b, 3	; 11
	VFDBLANK_PORT &= ~_BV(VFDBLANK);
    1f10:	43 98       	cbi	0x08, 3	; 8
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1f12:	f9 99       	sbic	0x1f, 1	; 31
    1f14:	fe cf       	rjmp	.-4      	; 0x1f12 <wakeup+0x7c>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    1f16:	8a e0       	ldi	r24, 0x0A	; 10
    1f18:	90 e0       	ldi	r25, 0x00	; 0
    1f1a:	92 bd       	out	0x22, r25	; 34
    1f1c:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1f1e:	f8 9a       	sbi	0x1f, 0	; 31
    1f20:	80 b5       	in	r24, 0x20	; 32
	volume = eeprom_read_byte((uint8_t *)EE_VOLUME); // reset
    1f22:	80 93 e4 02 	sts	0x02E4, r24

	speaker_init();
    1f26:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <speaker_init>
	displaymode = SHOW_TIME;
}

// we reset the watchdog timer 
void kickthedog(void) {
	wdt_reset();
    1f2a:	a8 95       	wdr

	speaker_init();

	kickthedog();

	setalarmstate();
    1f2c:	0e 94 ac 0d 	call	0x1b58	; 0x1b58 <setalarmstate>

	// wake up sound
	beep(880, 1);
    1f30:	80 e7       	ldi	r24, 0x70	; 112
    1f32:	93 e0       	ldi	r25, 0x03	; 3
    1f34:	61 e0       	ldi	r22, 0x01	; 1
    1f36:	0e 94 40 02 	call	0x480	; 0x480 <beep>
	beep(1760, 1);
    1f3a:	80 ee       	ldi	r24, 0xE0	; 224
    1f3c:	96 e0       	ldi	r25, 0x06	; 6
    1f3e:	61 e0       	ldi	r22, 0x01	; 1
    1f40:	0e 94 40 02 	call	0x480	; 0x480 <beep>
	beep(3520, 1);
    1f44:	80 ec       	ldi	r24, 0xC0	; 192
    1f46:	9d e0       	ldi	r25, 0x0D	; 13
    1f48:	61 e0       	ldi	r22, 0x01	; 1
    1f4a:	0e 94 40 02 	call	0x480	; 0x480 <beep>
	displaymode = SHOW_TIME;
}

// we reset the watchdog timer 
void kickthedog(void) {
	wdt_reset();
    1f4e:	a8 95       	wdr
    1f50:	08 95       	ret

00001f52 <__vector_23>:
	EIMSK = _BV(INT0);  //And reenable it before exiting.
}



SIGNAL(SIG_COMPARATOR) {
    1f52:	1f 92       	push	r1
    1f54:	0f 92       	push	r0
    1f56:	0f b6       	in	r0, 0x3f	; 63
    1f58:	0f 92       	push	r0
    1f5a:	11 24       	eor	r1, r1
    1f5c:	2f 93       	push	r18
    1f5e:	3f 93       	push	r19
    1f60:	4f 93       	push	r20
    1f62:	5f 93       	push	r21
    1f64:	6f 93       	push	r22
    1f66:	7f 93       	push	r23
    1f68:	8f 93       	push	r24
    1f6a:	9f 93       	push	r25
    1f6c:	af 93       	push	r26
    1f6e:	bf 93       	push	r27
    1f70:	ef 93       	push	r30
    1f72:	ff 93       	push	r31
	//DEBUGP("COMP");
	if (ACSR & _BV(ACO)) {
    1f74:	00 b6       	in	r0, 0x30	; 48
    1f76:	05 fe       	sbrs	r0, 5
    1f78:	3b c0       	rjmp	.+118    	; 0x1ff0 <__vector_23+0x9e>
		//DEBUGP("HIGH");
		if (!sleepmode) {
    1f7a:	80 91 49 02 	lds	r24, 0x0249
    1f7e:	88 23       	and	r24, r24
    1f80:	09 f0       	breq	.+2      	; 0x1f84 <__vector_23+0x32>
    1f82:	66 c0       	rjmp	.+204    	; 0x2050 <__vector_23+0xfe>
			VFDSWITCH_PORT |= _BV(VFDSWITCH); // turn off display
    1f84:	5b 9a       	sbi	0x0b, 3	; 11
			VFDCLK_PORT &= ~_BV(VFDCLK) & ~_BV(VFDDATA); // no power to vfdchip
    1f86:	85 b1       	in	r24, 0x05	; 5
    1f88:	87 7d       	andi	r24, 0xD7	; 215
    1f8a:	85 b9       	out	0x05, r24	; 5
			BOOST_PORT &= ~_BV(BOOST); // pull boost fet low
    1f8c:	5e 98       	cbi	0x0b, 6	; 11
			SPCR  &= ~_BV(SPE); // turn off spi
    1f8e:	8c b5       	in	r24, 0x2c	; 44
    1f90:	8f 7b       	andi	r24, 0xBF	; 191
    1f92:	8c bd       	out	0x2c, r24	; 44
			if (restored) {
    1f94:	80 91 4b 02 	lds	r24, 0x024B
    1f98:	88 23       	and	r24, r24
    1f9a:	f1 f0       	breq	.+60     	; 0x1fd8 <__vector_23+0x86>
				eeprom_write_byte((uint8_t *)EE_MIN, time_m);
    1f9c:	20 91 ef 02 	lds	r18, 0x02EF
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1fa0:	f9 99       	sbic	0x1f, 1	; 31
    1fa2:	fe cf       	rjmp	.-4      	; 0x1fa0 <__vector_23+0x4e>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1fa4:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1fa6:	85 e0       	ldi	r24, 0x05	; 5
    1fa8:	90 e0       	ldi	r25, 0x00	; 0
    1faa:	92 bd       	out	0x22, r25	; 34
    1fac:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    1fae:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    1fb0:	0f b6       	in	r0, 0x3f	; 63
    1fb2:	f8 94       	cli
    1fb4:	fa 9a       	sbi	0x1f, 2	; 31
    1fb6:	f9 9a       	sbi	0x1f, 1	; 31
    1fb8:	0f be       	out	0x3f, r0	; 63
				eeprom_write_byte((uint8_t *)EE_SEC, time_s);
    1fba:	20 91 f6 02 	lds	r18, 0x02F6
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1fbe:	f9 99       	sbic	0x1f, 1	; 31
    1fc0:	fe cf       	rjmp	.-4      	; 0x1fbe <__vector_23+0x6c>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1fc2:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    1fc4:	86 e0       	ldi	r24, 0x06	; 6
    1fc6:	90 e0       	ldi	r25, 0x00	; 0
    1fc8:	92 bd       	out	0x22, r25	; 34
    1fca:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    1fcc:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    1fce:	0f b6       	in	r0, 0x3f	; 63
    1fd0:	f8 94       	cli
    1fd2:	fa 9a       	sbi	0x1f, 2	; 31
    1fd4:	f9 9a       	sbi	0x1f, 1	; 31
    1fd6:	0f be       	out	0x3f, r0	; 63
			}
			DEBUGP("z");
    1fd8:	83 e4       	ldi	r24, 0x43	; 67
    1fda:	91 e0       	ldi	r25, 0x01	; 1
    1fdc:	61 e0       	ldi	r22, 0x01	; 1
    1fde:	0e 94 38 15 	call	0x2a70	; 0x2a70 <ROM_putstring>
			TCCR0B = 0; // no boost
    1fe2:	15 bc       	out	0x25, r1	; 37
			volume = 0; // low power buzzer
    1fe4:	10 92 e4 02 	sts	0x02E4, r1
			PCICR = 0;  // ignore buttons
    1fe8:	10 92 68 00 	sts	0x0068, r1
#ifdef FEATURE_AUTODIM
			DIMMER_POWER_PORT &= ~_BV(DIMMER_POWER_PIN); // no power to photoresistor
    1fec:	45 98       	cbi	0x08, 5	; 8
    1fee:	2b c0       	rjmp	.+86     	; 0x2046 <__vector_23+0xf4>

			app_start();
		}
	} else {
		//DEBUGP("LOW");
		if (sleepmode) {
    1ff0:	80 91 49 02 	lds	r24, 0x0249
    1ff4:	88 23       	and	r24, r24
    1ff6:	61 f1       	breq	.+88     	; 0x2050 <__vector_23+0xfe>
			if (restored) {
    1ff8:	80 91 4b 02 	lds	r24, 0x024B
    1ffc:	88 23       	and	r24, r24
    1ffe:	f1 f0       	breq	.+60     	; 0x203c <__vector_23+0xea>
				eeprom_write_byte((uint8_t *)EE_MIN, time_m);
    2000:	20 91 ef 02 	lds	r18, 0x02EF
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2004:	f9 99       	sbic	0x1f, 1	; 31
    2006:	fe cf       	rjmp	.-4      	; 0x2004 <__vector_23+0xb2>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    2008:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    200a:	85 e0       	ldi	r24, 0x05	; 5
    200c:	90 e0       	ldi	r25, 0x00	; 0
    200e:	92 bd       	out	0x22, r25	; 34
    2010:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    2012:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    2014:	0f b6       	in	r0, 0x3f	; 63
    2016:	f8 94       	cli
    2018:	fa 9a       	sbi	0x1f, 2	; 31
    201a:	f9 9a       	sbi	0x1f, 1	; 31
    201c:	0f be       	out	0x3f, r0	; 63
				eeprom_write_byte((uint8_t *)EE_SEC, time_s);
    201e:	20 91 f6 02 	lds	r18, 0x02F6
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2022:	f9 99       	sbic	0x1f, 1	; 31
    2024:	fe cf       	rjmp	.-4      	; 0x2022 <__vector_23+0xd0>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    2026:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    2028:	86 e0       	ldi	r24, 0x06	; 6
    202a:	90 e0       	ldi	r25, 0x00	; 0
    202c:	92 bd       	out	0x22, r25	; 34
    202e:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    2030:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    2032:	0f b6       	in	r0, 0x3f	; 63
    2034:	f8 94       	cli
    2036:	fa 9a       	sbi	0x1f, 2	; 31
    2038:	f9 9a       	sbi	0x1f, 1	; 31
    203a:	0f be       	out	0x3f, r0	; 63
			}
			DEBUGP("WAKERESET"); 
    203c:	89 e3       	ldi	r24, 0x39	; 57
    203e:	91 e0       	ldi	r25, 0x01	; 1
    2040:	61 e0       	ldi	r22, 0x01	; 1
    2042:	0e 94 38 15 	call	0x2a70	; 0x2a70 <ROM_putstring>
			app_start();
    2046:	e0 91 46 02 	lds	r30, 0x0246
    204a:	f0 91 47 02 	lds	r31, 0x0247
    204e:	09 95       	icall
		}
	}
}
    2050:	ff 91       	pop	r31
    2052:	ef 91       	pop	r30
    2054:	bf 91       	pop	r27
    2056:	af 91       	pop	r26
    2058:	9f 91       	pop	r25
    205a:	8f 91       	pop	r24
    205c:	7f 91       	pop	r23
    205e:	6f 91       	pop	r22
    2060:	5f 91       	pop	r21
    2062:	4f 91       	pop	r20
    2064:	3f 91       	pop	r19
    2066:	2f 91       	pop	r18
    2068:	0f 90       	pop	r0
    206a:	0f be       	out	0x3f, r0	; 63
    206c:	0f 90       	pop	r0
    206e:	1f 90       	pop	r1
    2070:	18 95       	reti

00002072 <setsnooze>:
// this sets the snoozetimer off in MAXSNOOZE seconds - which turns on
// the alarm again
void setsnooze(void) {
	//snoozetimer = eeprom_read_byte((uint8_t *)EE_SNOOZE);
	//snoozetimer *= 60; // convert minutes to seconds
	snoozetimer = MAXSNOOZE;
    2072:	88 e5       	ldi	r24, 0x58	; 88
    2074:	92 e0       	ldi	r25, 0x02	; 2
    2076:	90 93 55 02 	sts	0x0255, r25
    207a:	80 93 54 02 	sts	0x0254, r24
	DEBUGP("snooze");
    207e:	8e e4       	ldi	r24, 0x4E	; 78
    2080:	91 e0       	ldi	r25, 0x01	; 1
    2082:	61 e0       	ldi	r22, 0x01	; 1
    2084:	0e 94 38 15 	call	0x2a70	; 0x2a70 <ROM_putstring>
	display_str("snoozing");
    2088:	84 eb       	ldi	r24, 0xB4	; 180
    208a:	91 e0       	ldi	r25, 0x01	; 1
    208c:	0e 94 9e 06 	call	0xd3c	; 0xd3c <display_str>
	displaymode = SHOW_SNOOZE;
    2090:	89 e0       	ldi	r24, 0x09	; 9
    2092:	80 93 f4 02 	sts	0x02F4, r24

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    2096:	78 94       	sei

	milliseconds = 0;
    2098:	10 92 57 02 	sts	0x0257, r1
    209c:	10 92 56 02 	sts	0x0256, r1
	while (milliseconds < ms);
    20a0:	80 91 56 02 	lds	r24, 0x0256
    20a4:	90 91 57 02 	lds	r25, 0x0257
    20a8:	88 5e       	subi	r24, 0xE8	; 232
    20aa:	93 40       	sbci	r25, 0x03	; 3
    20ac:	c8 f3       	brcs	.-14     	; 0x20a0 <setsnooze+0x2e>
	snoozetimer = MAXSNOOZE;
	DEBUGP("snooze");
	display_str("snoozing");
	displaymode = SHOW_SNOOZE;
	delayms(1000);
	displaymode = SHOW_TIME;
    20ae:	10 92 f4 02 	sts	0x02F4, r1
}
    20b2:	08 95       	ret

000020b4 <__vector_3>:
	}
	PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
}

// Just button #2
SIGNAL(SIG_PIN_CHANGE0) {
    20b4:	1f 92       	push	r1
    20b6:	0f 92       	push	r0
    20b8:	0f b6       	in	r0, 0x3f	; 63
    20ba:	0f 92       	push	r0
    20bc:	11 24       	eor	r1, r1
    20be:	2f 93       	push	r18
    20c0:	3f 93       	push	r19
    20c2:	4f 93       	push	r20
    20c4:	5f 93       	push	r21
    20c6:	6f 93       	push	r22
    20c8:	7f 93       	push	r23
    20ca:	8f 93       	push	r24
    20cc:	9f 93       	push	r25
    20ce:	af 93       	push	r26
    20d0:	bf 93       	push	r27
    20d2:	ef 93       	push	r30
    20d4:	ff 93       	push	r31
	PCMSK0 = 0;
    20d6:	10 92 6b 00 	sts	0x006B, r1
	sei();
    20da:	78 94       	sei
	if (! (PINB & _BV(BUTTON2))) {
    20dc:	18 99       	sbic	0x03, 0	; 3
    20de:	2a c0       	rjmp	.+84     	; 0x2134 <__vector_3+0x80>
		// button2 is pressed
		if (! (last_buttonstate & 0x2)) { // was not pressed before
    20e0:	80 91 58 02 	lds	r24, 0x0258
    20e4:	81 fd       	sbrc	r24, 1
    20e6:	2b c0       	rjmp	.+86     	; 0x213e <__vector_3+0x8a>

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    20e8:	78 94       	sei

	milliseconds = 0;
    20ea:	10 92 57 02 	sts	0x0257, r1
    20ee:	10 92 56 02 	sts	0x0256, r1
	while (milliseconds < ms);
    20f2:	80 91 56 02 	lds	r24, 0x0256
    20f6:	90 91 57 02 	lds	r25, 0x0257
    20fa:	0a 97       	sbiw	r24, 0x0a	; 10
    20fc:	d0 f3       	brcs	.-12     	; 0x20f2 <__vector_3+0x3e>
	sei();
	if (! (PINB & _BV(BUTTON2))) {
		// button2 is pressed
		if (! (last_buttonstate & 0x2)) { // was not pressed before
			delayms(10);                    // debounce
			if (PINB & _BV(BUTTON2))        // filter out bounces
    20fe:	18 99       	sbic	0x03, 0	; 3
    2100:	1e c0       	rjmp	.+60     	; 0x213e <__vector_3+0x8a>
			{
				PCMSK0 = _BV(PCINT0);
				return;
			}
			tick();                         // make a noise
    2102:	0e 94 18 02 	call	0x430	; 0x430 <tick>
			// check if we will snag this button press for snoozing
			if (alarming) {
    2106:	80 91 f3 02 	lds	r24, 0x02F3
    210a:	88 23       	and	r24, r24
    210c:	19 f0       	breq	.+6      	; 0x2114 <__vector_3+0x60>
				setsnooze(); 	// turn on snooze
    210e:	0e 94 39 10 	call	0x2072	; 0x2072 <setsnooze>
    2112:	15 c0       	rjmp	.+42     	; 0x213e <__vector_3+0x8a>
				PCMSK0 = _BV(PCINT0);
				return;
			}
			last_buttonstate |= 0x2;
    2114:	80 91 58 02 	lds	r24, 0x0258
    2118:	82 60       	ori	r24, 0x02	; 2
    211a:	80 93 58 02 	sts	0x0258, r24
			just_pressed |= 0x2;
    211e:	80 91 59 02 	lds	r24, 0x0259
    2122:	82 60       	ori	r24, 0x02	; 2
    2124:	80 93 59 02 	sts	0x0259, r24
			DEBUGP("b2");
    2128:	85 e4       	ldi	r24, 0x45	; 69
    212a:	91 e0       	ldi	r25, 0x01	; 1
    212c:	61 e0       	ldi	r22, 0x01	; 1
    212e:	0e 94 38 15 	call	0x2a70	; 0x2a70 <ROM_putstring>
    2132:	05 c0       	rjmp	.+10     	; 0x213e <__vector_3+0x8a>
		}
	} else {
		last_buttonstate &= ~0x2;
    2134:	80 91 58 02 	lds	r24, 0x0258
    2138:	8d 7f       	andi	r24, 0xFD	; 253
    213a:	80 93 58 02 	sts	0x0258, r24
	}
	PCMSK0 = _BV(PCINT0);
    213e:	81 e0       	ldi	r24, 0x01	; 1
    2140:	80 93 6b 00 	sts	0x006B, r24
}
    2144:	ff 91       	pop	r31
    2146:	ef 91       	pop	r30
    2148:	bf 91       	pop	r27
    214a:	af 91       	pop	r26
    214c:	9f 91       	pop	r25
    214e:	8f 91       	pop	r24
    2150:	7f 91       	pop	r23
    2152:	6f 91       	pop	r22
    2154:	5f 91       	pop	r21
    2156:	4f 91       	pop	r20
    2158:	3f 91       	pop	r19
    215a:	2f 91       	pop	r18
    215c:	0f 90       	pop	r0
    215e:	0f be       	out	0x3f, r0	; 63
    2160:	0f 90       	pop	r0
    2162:	1f 90       	pop	r1
    2164:	18 95       	reti

00002166 <__vector_5>:
// This allows for 'high speed incrementing' when setting the time
volatile uint8_t last_buttonstate = 0, just_pressed = 0, pressed = 0;
volatile uint8_t buttonholdcounter = 0;

// This interrupt detects switches 1 and 3
SIGNAL(SIG_PIN_CHANGE2) {
    2166:	1f 92       	push	r1
    2168:	0f 92       	push	r0
    216a:	0f b6       	in	r0, 0x3f	; 63
    216c:	0f 92       	push	r0
    216e:	11 24       	eor	r1, r1
    2170:	2f 93       	push	r18
    2172:	3f 93       	push	r19
    2174:	4f 93       	push	r20
    2176:	5f 93       	push	r21
    2178:	6f 93       	push	r22
    217a:	7f 93       	push	r23
    217c:	8f 93       	push	r24
    217e:	9f 93       	push	r25
    2180:	af 93       	push	r26
    2182:	bf 93       	push	r27
    2184:	ef 93       	push	r30
    2186:	ff 93       	push	r31
	// allow interrupts while we're doing this
	PCMSK2 = 0;
    2188:	10 92 6d 00 	sts	0x006D, r1
	sei();
    218c:	78 94       	sei
	displaymode = SHOW_TIME;
}

// we reset the watchdog timer 
void kickthedog(void) {
	wdt_reset();
    218e:	a8 95       	wdr
	PCMSK2 = 0;
	sei();
	// kick the dog
	kickthedog();

	if (! (PIND & _BV(BUTTON1))) {
    2190:	4d 99       	sbic	0x09, 5	; 9
    2192:	27 c0       	rjmp	.+78     	; 0x21e2 <__vector_5+0x7c>
		// button1 is pressed
		if (! (last_buttonstate & 0x1)) { // was not pressed before
    2194:	80 91 58 02 	lds	r24, 0x0258
    2198:	80 fd       	sbrc	r24, 0
    219a:	28 c0       	rjmp	.+80     	; 0x21ec <__vector_5+0x86>

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    219c:	78 94       	sei

	milliseconds = 0;
    219e:	10 92 57 02 	sts	0x0257, r1
    21a2:	10 92 56 02 	sts	0x0256, r1
	while (milliseconds < ms);
    21a6:	80 91 56 02 	lds	r24, 0x0256
    21aa:	90 91 57 02 	lds	r25, 0x0257
    21ae:	0a 97       	sbiw	r24, 0x0a	; 10
    21b0:	d0 f3       	brcs	.-12     	; 0x21a6 <__vector_5+0x40>

	if (! (PIND & _BV(BUTTON1))) {
		// button1 is pressed
		if (! (last_buttonstate & 0x1)) { // was not pressed before
			delayms(10);                    // debounce
			if (PIND & _BV(BUTTON1))        // filter out bounces
    21b2:	4d 99       	sbic	0x09, 5	; 9
    21b4:	63 c0       	rjmp	.+198    	; 0x227c <__vector_5+0x116>
			{
				PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
				return;
			}
			tick();                         // make a noise
    21b6:	0e 94 18 02 	call	0x430	; 0x430 <tick>
			// check if we will snag this button press for snoozing
			if (alarming) {
    21ba:	80 91 f3 02 	lds	r24, 0x02F3
    21be:	88 23       	and	r24, r24
    21c0:	c9 f5       	brne	.+114    	; 0x2234 <__vector_5+0xce>
				// turn on snooze
				setsnooze();
				PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
				return;
			}
			last_buttonstate |= 0x1;
    21c2:	80 91 58 02 	lds	r24, 0x0258
    21c6:	81 60       	ori	r24, 0x01	; 1
    21c8:	80 93 58 02 	sts	0x0258, r24
			just_pressed |= 0x1;
    21cc:	80 91 59 02 	lds	r24, 0x0259
    21d0:	81 60       	ori	r24, 0x01	; 1
    21d2:	80 93 59 02 	sts	0x0259, r24
			DEBUGP("b1");
    21d6:	8b e4       	ldi	r24, 0x4B	; 75
    21d8:	91 e0       	ldi	r25, 0x01	; 1
    21da:	61 e0       	ldi	r22, 0x01	; 1
    21dc:	0e 94 38 15 	call	0x2a70	; 0x2a70 <ROM_putstring>
    21e0:	05 c0       	rjmp	.+10     	; 0x21ec <__vector_5+0x86>
		}
	} else {
		last_buttonstate &= ~0x1;
    21e2:	80 91 58 02 	lds	r24, 0x0258
    21e6:	8e 7f       	andi	r24, 0xFE	; 254
    21e8:	80 93 58 02 	sts	0x0258, r24
	}

	if (! (PIND & _BV(BUTTON3))) {
    21ec:	4c 99       	sbic	0x09, 4	; 9
    21ee:	3f c0       	rjmp	.+126    	; 0x226e <__vector_5+0x108>
		// button3 is pressed
		if (! (last_buttonstate & 0x4)) { // was not pressed before
    21f0:	80 91 58 02 	lds	r24, 0x0258
    21f4:	82 fd       	sbrc	r24, 2
    21f6:	42 c0       	rjmp	.+132    	; 0x227c <__vector_5+0x116>

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    21f8:	78 94       	sei

	milliseconds = 0;
    21fa:	10 92 57 02 	sts	0x0257, r1
    21fe:	10 92 56 02 	sts	0x0256, r1
	while (milliseconds < ms);
    2202:	80 91 56 02 	lds	r24, 0x0256
    2206:	90 91 57 02 	lds	r25, 0x0257
    220a:	0a 97       	sbiw	r24, 0x0a	; 10
    220c:	d0 f3       	brcs	.-12     	; 0x2202 <__vector_5+0x9c>

	if (! (PIND & _BV(BUTTON3))) {
		// button3 is pressed
		if (! (last_buttonstate & 0x4)) { // was not pressed before
			delayms(10);                    // debounce
			if (PIND & _BV(BUTTON3))        // filter out bounces
    220e:	4c 99       	sbic	0x09, 4	; 9
    2210:	35 c0       	rjmp	.+106    	; 0x227c <__vector_5+0x116>
			{
				PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
				return;
			}
			buttonholdcounter = 2;          // see if we're press-and-holding
    2212:	82 e0       	ldi	r24, 0x02	; 2
    2214:	80 93 5b 02 	sts	0x025B, r24
    2218:	1b c0       	rjmp	.+54     	; 0x2250 <__vector_5+0xea>
			while (buttonholdcounter) {
				if (PIND & _BV(BUTTON3)) {        // released
    221a:	4c 9b       	sbis	0x09, 4	; 9
    221c:	19 c0       	rjmp	.+50     	; 0x2250 <__vector_5+0xea>
					tick();                         // make a noise
    221e:	0e 94 18 02 	call	0x430	; 0x430 <tick>
					last_buttonstate &= ~0x4;
    2222:	80 91 58 02 	lds	r24, 0x0258
    2226:	8b 7f       	andi	r24, 0xFB	; 251
    2228:	80 93 58 02 	sts	0x0258, r24
					// check if we will snag this button press for snoozing
					if (alarming) {
    222c:	80 91 f3 02 	lds	r24, 0x02F3
    2230:	88 23       	and	r24, r24
    2232:	19 f0       	breq	.+6      	; 0x223a <__vector_5+0xd4>
						// turn on snooze
						setsnooze();
    2234:	0e 94 39 10 	call	0x2072	; 0x2072 <setsnooze>
    2238:	21 c0       	rjmp	.+66     	; 0x227c <__vector_5+0x116>
						PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
						return;
					}
					DEBUGP("b3");
    223a:	88 e4       	ldi	r24, 0x48	; 72
    223c:	91 e0       	ldi	r25, 0x01	; 1
    223e:	61 e0       	ldi	r22, 0x01	; 1
    2240:	0e 94 38 15 	call	0x2a70	; 0x2a70 <ROM_putstring>
					just_pressed |= 0x4;
    2244:	80 91 59 02 	lds	r24, 0x0259
    2248:	84 60       	ori	r24, 0x04	; 4
    224a:	80 93 59 02 	sts	0x0259, r24
    224e:	16 c0       	rjmp	.+44     	; 0x227c <__vector_5+0x116>
			{
				PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
				return;
			}
			buttonholdcounter = 2;          // see if we're press-and-holding
			while (buttonholdcounter) {
    2250:	80 91 5b 02 	lds	r24, 0x025B
    2254:	88 23       	and	r24, r24
    2256:	09 f7       	brne	.-62     	; 0x221a <__vector_5+0xb4>
					just_pressed |= 0x4;
					PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
					return;
				}
			}
			last_buttonstate |= 0x4;
    2258:	80 91 58 02 	lds	r24, 0x0258
    225c:	84 60       	ori	r24, 0x04	; 4
    225e:	80 93 58 02 	sts	0x0258, r24
			pressed |= 0x4;                 // held down
    2262:	80 91 5a 02 	lds	r24, 0x025A
    2266:	84 60       	ori	r24, 0x04	; 4
    2268:	80 93 5a 02 	sts	0x025A, r24
    226c:	07 c0       	rjmp	.+14     	; 0x227c <__vector_5+0x116>
		}
	} else {
		pressed = 0;                      // button released
    226e:	10 92 5a 02 	sts	0x025A, r1
		last_buttonstate &= ~0x4;
    2272:	80 91 58 02 	lds	r24, 0x0258
    2276:	8b 7f       	andi	r24, 0xFB	; 251
    2278:	80 93 58 02 	sts	0x0258, r24
	}
	PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
    227c:	80 e3       	ldi	r24, 0x30	; 48
    227e:	80 93 6d 00 	sts	0x006D, r24
}
    2282:	ff 91       	pop	r31
    2284:	ef 91       	pop	r30
    2286:	bf 91       	pop	r27
    2288:	af 91       	pop	r26
    228a:	9f 91       	pop	r25
    228c:	8f 91       	pop	r24
    228e:	7f 91       	pop	r23
    2290:	6f 91       	pop	r22
    2292:	5f 91       	pop	r21
    2294:	4f 91       	pop	r20
    2296:	3f 91       	pop	r19
    2298:	2f 91       	pop	r18
    229a:	0f 90       	pop	r0
    229c:	0f be       	out	0x3f, r0	; 63
    229e:	0f 90       	pop	r0
    22a0:	1f 90       	pop	r1
    22a2:	18 95       	reti

000022a4 <getgpstime>:
	return (UCSR0A & _BV(RXC0));

}


void getgpstime(void) {
    22a4:	8f 92       	push	r8
    22a6:	9f 92       	push	r9
    22a8:	bf 92       	push	r11
    22aa:	cf 92       	push	r12
    22ac:	df 92       	push	r13
    22ae:	ef 92       	push	r14
    22b0:	ff 92       	push	r15
    22b2:	0f 93       	push	r16
    22b4:	1f 93       	push	r17
    22b6:	df 93       	push	r29
    22b8:	cf 93       	push	r28
    22ba:	cd b7       	in	r28, 0x3d	; 61
    22bc:	de b7       	in	r29, 0x3e	; 62
    22be:	2f 97       	sbiw	r28, 0x0f	; 15
    22c0:	0f b6       	in	r0, 0x3f	; 63
    22c2:	f8 94       	cli
    22c4:	de bf       	out	0x3e, r29	; 62
    22c6:	0f be       	out	0x3f, r0	; 63
    22c8:	cd bf       	out	0x3d, r28	; 61

	uint8_t intOldHr = 0;
	uint8_t intOldMin = 0;
	uint8_t intOldSec = 0;

	char charReceived = UDR0;
    22ca:	80 91 c6 00 	lds	r24, 0x00C6
    22ce:	89 83       	std	Y+1, r24	; 0x01
	char strTime[7];
	char strDate[7];

	//If the buffer has not been started because a '$' has not been encountered
	//but a '$' is just now encountered, then start filling the buffer.
	if ( ( 0 == intBufferStatus ) && ( '$' == charReceived ) ) {
    22d0:	90 91 4c 02 	lds	r25, 0x024C
    22d4:	99 23       	and	r25, r25
    22d6:	49 f4       	brne	.+18     	; 0x22ea <getgpstime+0x46>
    22d8:	84 32       	cpi	r24, 0x24	; 36
    22da:	09 f0       	breq	.+2      	; 0x22de <getgpstime+0x3a>
    22dc:	e4 c0       	rjmp	.+456    	; 0x24a6 <getgpstime+0x202>
		intBufferStatus = 1;
    22de:	81 e0       	ldi	r24, 0x01	; 1
    22e0:	80 93 4c 02 	sts	0x024C, r24
		strncat(strBuffer, &charReceived, 1);
    22e4:	82 e6       	ldi	r24, 0x62	; 98
    22e6:	92 e0       	ldi	r25, 0x02	; 2
    22e8:	d7 c0       	rjmp	.+430    	; 0x2498 <getgpstime+0x1f4>
	}

	//If the buffer has started to fill...
	if ( 0 != intBufferStatus ) {
		//If for some reason, the buffer is full, clear it, and start over.
		if ( ! ( ( strlen(strBuffer) < BUFFERSIZE ) ) ) {
    22ea:	02 e6       	ldi	r16, 0x62	; 98
    22ec:	12 e0       	ldi	r17, 0x02	; 2
    22ee:	f8 01       	movw	r30, r16
    22f0:	01 90       	ld	r0, Z+
    22f2:	00 20       	and	r0, r0
    22f4:	e9 f7       	brne	.-6      	; 0x22f0 <getgpstime+0x4c>
    22f6:	31 97       	sbiw	r30, 0x01	; 1
    22f8:	e0 1b       	sub	r30, r16
    22fa:	f1 0b       	sbc	r31, r17
    22fc:	e0 38       	cpi	r30, 0x80	; 128
    22fe:	f1 05       	cpc	r31, r1
    2300:	c0 f4       	brcc	.+48     	; 0x2332 <getgpstime+0x8e>
			intBufferStatus = 0;
			return;
		}
		//If the buffer has 6 characters in it, it is time to check to see if it is 
		//the line we are looking for that starts with "$GPRMC"
		else if ( 6 == strlen(strBuffer) ) {
    2302:	36 97       	sbiw	r30, 0x06	; 6
    2304:	89 f4       	brne	.+34     	; 0x2328 <getgpstime+0x84>
			//If the buffer does contain the characters we are looking for,
			//then update the status, add to the buffer, and then return for more.
			if ( 0 == strcmp( strBuffer, "$GPRMC" ) ) {
    2306:	c8 01       	movw	r24, r16
    2308:	6d eb       	ldi	r22, 0xBD	; 189
    230a:	71 e0       	ldi	r23, 0x01	; 1
    230c:	0e 94 61 16 	call	0x2cc2	; 0x2cc2 <strcmp>
    2310:	00 97       	sbiw	r24, 0x00	; 0
    2312:	21 f4       	brne	.+8      	; 0x231c <getgpstime+0x78>
				//uart_puts("\n\r$GPRMC Found \n\r");
				intBufferStatus = 2;
    2314:	82 e0       	ldi	r24, 0x02	; 2
    2316:	80 93 4c 02 	sts	0x024C, r24
    231a:	bd c0       	rjmp	.+378    	; 0x2496 <getgpstime+0x1f2>
			//If the buffer does not contain the characters we are looking for,
			//then clear the buffer and start over..
			else {
				//uart_puts("\n\r$GPRMC Not Found:\t\t");
				//uart_puts(strBuffer);
				memset( strBuffer, 0, BUFFERSIZE );
    231c:	80 e8       	ldi	r24, 0x80	; 128
    231e:	f8 01       	movw	r30, r16
    2320:	11 92       	st	Z+, r1
    2322:	8a 95       	dec	r24
    2324:	e9 f7       	brne	.-6      	; 0x2320 <getgpstime+0x7c>
    2326:	b4 c0       	rjmp	.+360    	; 0x2490 <getgpstime+0x1ec>
			}
		}

		//If the asterix at the start of the checksum at the end of the line is encountered,
		//then parse the buffer.
		else if ( '*' == charReceived ) {
    2328:	8a 32       	cpi	r24, 0x2A	; 42
    232a:	09 f0       	breq	.+2      	; 0x232e <getgpstime+0x8a>
    232c:	b4 c0       	rjmp	.+360    	; 0x2496 <getgpstime+0x1f2>
			//If the buffer status indicates we have not already found the
			//needed start of the string, then start over.
			if ( 2 != intBufferStatus ) {
    232e:	92 30       	cpi	r25, 0x02	; 2
    2330:	19 f0       	breq	.+6      	; 0x2338 <getgpstime+0x94>
				memset( strBuffer, 0, BUFFERSIZE );
    2332:	80 e8       	ldi	r24, 0x80	; 128
    2334:	d8 01       	movw	r26, r16
    2336:	a9 c0       	rjmp	.+338    	; 0x248a <getgpstime+0x1e6>
			//If the buffer status indicates we have already found the needed start of the string,
			//then go on to parse the buffer.
			else {
				//Parse the buffer here...
				//Let's test to see if this works:
				uart_puts("\n\r");
    2338:	84 ec       	ldi	r24, 0xC4	; 196
    233a:	91 e0       	ldi	r25, 0x01	; 1
    233c:	0e 94 59 15 	call	0x2ab2	; 0x2ab2 <uart_puts>
				uart_puts(strBuffer);
    2340:	c8 01       	movw	r24, r16
    2342:	0e 94 59 15 	call	0x2ab2	; 0x2ab2 <uart_puts>

				//Find the first comma:
				strPointer1 = strchr( strBuffer, ',');
    2346:	c8 01       	movw	r24, r16
    2348:	6c e2       	ldi	r22, 0x2C	; 44
    234a:	70 e0       	ldi	r23, 0x00	; 0
    234c:	0e 94 56 16 	call	0x2cac	; 0x2cac <strchr>

				//Copy the section of memory in the buffer that contains the time.
				memcpy( strTime, strPointer1 + 1, 6 );
    2350:	de 01       	movw	r26, r28
    2352:	12 96       	adiw	r26, 0x02	; 2
    2354:	fc 01       	movw	r30, r24
    2356:	31 96       	adiw	r30, 0x01	; 1
    2358:	26 e0       	ldi	r18, 0x06	; 6
    235a:	01 90       	ld	r0, Z+
    235c:	0d 92       	st	X+, r0
    235e:	21 50       	subi	r18, 0x01	; 1
    2360:	e1 f7       	brne	.-8      	; 0x235a <getgpstime+0xb6>
				//add a null character to the end of the time string.
				strTime[6] = 0;
    2362:	18 86       	std	Y+8, r1	; 0x08
    2364:	00 e0       	ldi	r16, 0x00	; 0
    2366:	10 e0       	ldi	r17, 0x00	; 0



				//Find eight more commas to get the date:
				for ( int i = 0; i < 8; i++ ) {
					strPointer1 = strchr( strPointer1 + 1, ',');
    2368:	01 96       	adiw	r24, 0x01	; 1
    236a:	6c e2       	ldi	r22, 0x2C	; 44
    236c:	70 e0       	ldi	r23, 0x00	; 0
    236e:	0e 94 56 16 	call	0x2cac	; 0x2cac <strchr>
				strTime[6] = 0;



				//Find eight more commas to get the date:
				for ( int i = 0; i < 8; i++ ) {
    2372:	0f 5f       	subi	r16, 0xFF	; 255
    2374:	1f 4f       	sbci	r17, 0xFF	; 255
    2376:	08 30       	cpi	r16, 0x08	; 8
    2378:	11 05       	cpc	r17, r1
    237a:	b1 f7       	brne	.-20     	; 0x2368 <getgpstime+0xc4>
					strPointer1 = strchr( strPointer1 + 1, ',');
				}

				//Copy the section of memory in the buffer that contains the date.
				memcpy( strDate, strPointer1 + 1, 6 );
    237c:	de 01       	movw	r26, r28
    237e:	19 96       	adiw	r26, 0x09	; 9
    2380:	fc 01       	movw	r30, r24
    2382:	31 96       	adiw	r30, 0x01	; 1
    2384:	86 e0       	ldi	r24, 0x06	; 6
    2386:	01 90       	ld	r0, Z+
    2388:	0d 92       	st	X+, r0
    238a:	81 50       	subi	r24, 0x01	; 1
    238c:	e1 f7       	brne	.-8      	; 0x2386 <getgpstime+0xe2>
				//add a null character to the end of the date string.
				strDate[6] = 0;
    238e:	1f 86       	std	Y+15, r1	; 0x0f

				//The GPS unit will not have the proper date unless it has received a time update.
				//NOTE: at the turn of the century, the clock will not get updates from GPS
				//for as many years as the value of PROGRAMMING_YEAR
				if ( PROGRAMMING_YEAR <= ( ( (strDate[4] - '0') * 10 ) ) + (strDate[5] - '0') ) {
    2390:	8e 85       	ldd	r24, Y+14	; 0x0e
    2392:	90 e0       	ldi	r25, 0x00	; 0
    2394:	80 51       	subi	r24, 0x10	; 16
    2396:	92 40       	sbci	r25, 0x02	; 2
    2398:	2d 85       	ldd	r18, Y+13	; 0x0d
    239a:	4a e0       	ldi	r20, 0x0A	; 10
    239c:	24 9f       	mul	r18, r20
    239e:	90 01       	movw	r18, r0
    23a0:	11 24       	eor	r1, r1
    23a2:	82 0f       	add	r24, r18
    23a4:	93 1f       	adc	r25, r19
    23a6:	0a 97       	sbiw	r24, 0x0a	; 10
    23a8:	0c f4       	brge	.+2      	; 0x23ac <getgpstime+0x108>
    23aa:	6b c0       	rjmp	.+214    	; 0x2482 <getgpstime+0x1de>
					//Get the 'old' values of the time:
					intOldHr = time_h;
    23ac:	10 91 61 02 	lds	r17, 0x0261
					intOldMin = time_m;
    23b0:	00 91 ef 02 	lds	r16, 0x02EF
					intOldSec = time_s;
    23b4:	80 91 f6 02 	lds	r24, 0x02F6

					//Change the time:
					setgpstime(strTime);
    23b8:	ce 01       	movw	r24, r28
    23ba:	02 96       	adiw	r24, 0x02	; 2
    23bc:	0e 94 f1 0a 	call	0x15e2	; 0x15e2 <setgpstime>
					//Change the date:
					setgpsdate(strDate);
    23c0:	ce 01       	movw	r24, r28
    23c2:	09 96       	adiw	r24, 0x09	; 9
    23c4:	0e 94 45 0b 	call	0x168a	; 0x168a <setgpsdate>

					//Gussy up the time and date, make the numbers come out right:
					fix_time();
    23c8:	0e 94 67 0b 	call	0x16ce	; 0x16ce <fix_time>

					//Turn the two time values into minutes past midnight
					uint16_t timeMinutes = ((time_h * 60) + (time_m));
    23cc:	30 91 61 02 	lds	r19, 0x0261
    23d0:	80 91 ef 02 	lds	r24, 0x02EF
    23d4:	2c e3       	ldi	r18, 0x3C	; 60
    23d6:	32 02       	muls	r19, r18
    23d8:	d0 01       	movw	r26, r0
    23da:	11 24       	eor	r1, r1
    23dc:	99 27       	eor	r25, r25
    23de:	87 fd       	sbrc	r24, 7
    23e0:	90 95       	com	r25
    23e2:	a8 0f       	add	r26, r24
    23e4:	b9 1f       	adc	r27, r25
					uint16_t oldTimeMinutes = ((intOldHr * 60) + (intOldMin));
    23e6:	81 2e       	mov	r8, r17
    23e8:	99 24       	eor	r9, r9
    23ea:	8c e3       	ldi	r24, 0x3C	; 60
    23ec:	90 e0       	ldi	r25, 0x00	; 0
    23ee:	88 9e       	mul	r8, r24
    23f0:	f0 01       	movw	r30, r0
    23f2:	89 9e       	mul	r8, r25
    23f4:	f0 0d       	add	r31, r0
    23f6:	98 9e       	mul	r9, r24
    23f8:	f0 0d       	add	r31, r0
    23fa:	11 24       	eor	r1, r1
    23fc:	e0 0f       	add	r30, r16
    23fe:	f1 1d       	adc	r31, r1

					int8_t intTempHr = time_h;
    2400:	e0 90 61 02 	lds	r14, 0x0261
					int8_t intTempMin = time_m;
    2404:	f0 90 ef 02 	lds	r15, 0x02EF

					//If midnight happened between the old time and the new time
					//and we did not just go back in time...
					if ( ( 0 > (int16_t)( timeMinutes - oldTimeMinutes ) )
    2408:	ad 01       	movw	r20, r26
    240a:	4e 1b       	sub	r20, r30
    240c:	5f 0b       	sbc	r21, r31
    240e:	57 ff       	sbrs	r21, 7
    2410:	18 c0       	rjmp	.+48     	; 0x2442 <getgpstime+0x19e>
    2412:	bd 01       	movw	r22, r26
    2414:	60 56       	subi	r22, 0x60	; 96
    2416:	7a 4f       	sbci	r23, 0xFA	; 250
    2418:	6e 17       	cp	r22, r30
    241a:	7f 07       	cpc	r23, r31
    241c:	90 f0       	brcs	.+36     	; 0x2442 <getgpstime+0x19e>
    241e:	9a 01       	movw	r18, r20
    2420:	20 56       	subi	r18, 0x60	; 96
    2422:	3a 4f       	sbci	r19, 0xFA	; 250
    2424:	37 ff       	sbrs	r19, 7
    2426:	03 c0       	rjmp	.+6      	; 0x242e <getgpstime+0x18a>
    2428:	30 95       	com	r19
    242a:	21 95       	neg	r18
    242c:	3f 4f       	sbci	r19, 0xFF	; 255
    242e:	88 27       	eor	r24, r24
    2430:	99 27       	eor	r25, r25
    2432:	84 1b       	sub	r24, r20
    2434:	95 0b       	sbc	r25, r21
    2436:	28 17       	cp	r18, r24
    2438:	39 07       	cpc	r19, r25
    243a:	1c f4       	brge	.+6      	; 0x2442 <getgpstime+0x19e>
							&& ( (timeMinutes + 1440) >= oldTimeMinutes )
							&& ( abs( timeMinutes + 1440 - oldTimeMinutes ) < abs( timeMinutes - oldTimeMinutes ) ) ) {
						timeMinutes += 1440;
						intTempHr += 24;
    243c:	b8 e1       	ldi	r27, 0x18	; 24
    243e:	eb 0e       	add	r14, r27
    2440:	01 c0       	rjmp	.+2      	; 0x2444 <getgpstime+0x1a0>
    2442:	bd 01       	movw	r22, r26
					}

					if ( timeMinutes > oldTimeMinutes ) {
    2444:	e6 17       	cp	r30, r22
    2446:	f7 07       	cpc	r31, r23
    2448:	e0 f4       	brcc	.+56     	; 0x2482 <getgpstime+0x1de>
    244a:	00 e0       	ldi	r16, 0x00	; 0
    244c:	10 e0       	ldi	r17, 0x00	; 0

						//Count backwards in time to the old time, checking the alarm for each minute.
						for ( ; intTempHr >= intOldHr; intTempHr-- ) {
    244e:	ce 2c       	mov	r12, r14
    2450:	dd 24       	eor	r13, r13
    2452:	c7 fc       	sbrc	r12, 7
    2454:	d0 94       	com	r13
    2456:	0f c0       	rjmp	.+30     	; 0x2476 <getgpstime+0x1d2>
							for ( ; intTempMin >= 0; intTempMin-- ) {
								check_alarm( (uint8_t)intTempHr, (uint8_t)intTempMin, 0 );
    2458:	8b 2d       	mov	r24, r11
    245a:	6f 2d       	mov	r22, r15
    245c:	40 e0       	ldi	r20, 0x00	; 0
    245e:	0e 94 fe 0c 	call	0x19fc	; 0x19fc <check_alarm>

					if ( timeMinutes > oldTimeMinutes ) {

						//Count backwards in time to the old time, checking the alarm for each minute.
						for ( ; intTempHr >= intOldHr; intTempHr-- ) {
							for ( ; intTempMin >= 0; intTempMin-- ) {
    2462:	fa 94       	dec	r15
    2464:	02 c0       	rjmp	.+4      	; 0x246a <getgpstime+0x1c6>
								check_alarm( (uint8_t)intTempHr, (uint8_t)intTempMin, 0 );
    2466:	be 2c       	mov	r11, r14
    2468:	b0 1a       	sub	r11, r16

					if ( timeMinutes > oldTimeMinutes ) {

						//Count backwards in time to the old time, checking the alarm for each minute.
						for ( ; intTempHr >= intOldHr; intTempHr-- ) {
							for ( ; intTempMin >= 0; intTempMin-- ) {
    246a:	f7 fe       	sbrs	r15, 7
    246c:	f5 cf       	rjmp	.-22     	; 0x2458 <getgpstime+0x1b4>
    246e:	0f 5f       	subi	r16, 0xFF	; 255
    2470:	1f 4f       	sbci	r17, 0xFF	; 255
    2472:	8b e3       	ldi	r24, 0x3B	; 59
    2474:	f8 2e       	mov	r15, r24
					}

					if ( timeMinutes > oldTimeMinutes ) {

						//Count backwards in time to the old time, checking the alarm for each minute.
						for ( ; intTempHr >= intOldHr; intTempHr-- ) {
    2476:	c6 01       	movw	r24, r12
    2478:	80 1b       	sub	r24, r16
    247a:	91 0b       	sbc	r25, r17
    247c:	88 15       	cp	r24, r8
    247e:	99 05       	cpc	r25, r9
    2480:	94 f7       	brge	.-28     	; 0x2466 <getgpstime+0x1c2>
					}

				}

				//We've done what we needed to do, so start over.
				memset( strBuffer, 0, BUFFERSIZE );
    2482:	80 e8       	ldi	r24, 0x80	; 128
    2484:	e2 e6       	ldi	r30, 0x62	; 98
    2486:	f2 e0       	ldi	r31, 0x02	; 2
    2488:	df 01       	movw	r26, r30
    248a:	1d 92       	st	X+, r1
    248c:	8a 95       	dec	r24
    248e:	e9 f7       	brne	.-6      	; 0x248a <getgpstime+0x1e6>
				intBufferStatus = 0;
    2490:	10 92 4c 02 	sts	0x024C, r1
    2494:	08 c0       	rjmp	.+16     	; 0x24a6 <getgpstime+0x202>
				return;
			}
		}
		//If nothing else was found, add to the buffer.
		else {
			strncat(strBuffer, &charReceived, 1);
    2496:	c8 01       	movw	r24, r16
    2498:	be 01       	movw	r22, r28
    249a:	6f 5f       	subi	r22, 0xFF	; 255
    249c:	7f 4f       	sbci	r23, 0xFF	; 255
    249e:	41 e0       	ldi	r20, 0x01	; 1
    24a0:	50 e0       	ldi	r21, 0x00	; 0
    24a2:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <strncat>
		}


	}

}
    24a6:	2f 96       	adiw	r28, 0x0f	; 15
    24a8:	0f b6       	in	r0, 0x3f	; 63
    24aa:	f8 94       	cli
    24ac:	de bf       	out	0x3e, r29	; 62
    24ae:	0f be       	out	0x3f, r0	; 63
    24b0:	cd bf       	out	0x3d, r28	; 61
    24b2:	cf 91       	pop	r28
    24b4:	df 91       	pop	r29
    24b6:	1f 91       	pop	r17
    24b8:	0f 91       	pop	r16
    24ba:	ff 90       	pop	r15
    24bc:	ef 90       	pop	r14
    24be:	df 90       	pop	r13
    24c0:	cf 90       	pop	r12
    24c2:	bf 90       	pop	r11
    24c4:	9f 90       	pop	r9
    24c6:	8f 90       	pop	r8
    24c8:	08 95       	ret

000024ca <set_timezone>:
		}
	}
}

//Function to set the time zone
void set_timezone(void) {
    24ca:	cf 92       	push	r12
    24cc:	df 92       	push	r13
    24ce:	ef 92       	push	r14
    24d0:	ff 92       	push	r15
    24d2:	0f 93       	push	r16
    24d4:	1f 93       	push	r17
    24d6:	cf 93       	push	r28
    24d8:	df 93       	push	r29
	int8_t hour = intTimeZoneHour;
    24da:	10 91 44 02 	lds	r17, 0x0244
	uint8_t min = intTimeZoneMin;
    24de:	00 91 4d 02 	lds	r16, 0x024D
	uint8_t mode = SHOW_MENU;
	timeoutcounter = INACTIVITYTIMEOUT;
    24e2:	8a e0       	ldi	r24, 0x0A	; 10
    24e4:	80 93 5c 02 	sts	0x025C, r24
    24e8:	ff 24       	eor	r15, r15
	while (1) {
		if (just_pressed & 0x1) { // mode change
			return;
		}
		if (just_pressed || pressed) {
			timeoutcounter = INACTIVITYTIMEOUT;  
    24ea:	3a e0       	ldi	r19, 0x0A	; 10
    24ec:	e3 2e       	mov	r14, r19
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    24ee:	2e e0       	ldi	r18, 0x0E	; 14
    24f0:	c2 2e       	mov	r12, r18
    24f2:	d1 2c       	mov	r13, r1
	uint8_t min = intTimeZoneMin;
	uint8_t mode = SHOW_MENU;
	timeoutcounter = INACTIVITYTIMEOUT;

	while (1) {
		if (just_pressed & 0x1) { // mode change
    24f4:	cd e0       	ldi	r28, 0x0D	; 13
    24f6:	d0 e0       	ldi	r29, 0x00	; 0
    24f8:	80 91 59 02 	lds	r24, 0x0259
    24fc:	80 fd       	sbrc	r24, 0
    24fe:	c4 c0       	rjmp	.+392    	; 0x2688 <set_timezone+0x1be>
			return;
		}
		if (just_pressed || pressed) {
    2500:	80 91 59 02 	lds	r24, 0x0259
    2504:	88 23       	and	r24, r24
    2506:	21 f4       	brne	.+8      	; 0x2510 <set_timezone+0x46>
    2508:	80 91 5a 02 	lds	r24, 0x025A
    250c:	88 23       	and	r24, r24
    250e:	19 f0       	breq	.+6      	; 0x2516 <set_timezone+0x4c>
			timeoutcounter = INACTIVITYTIMEOUT;  
    2510:	e0 92 5c 02 	sts	0x025C, r14
    2514:	04 c0       	rjmp	.+8      	; 0x251e <set_timezone+0x54>
			// timeout w/no buttons pressed after 3 seconds?
		} else if (!timeoutcounter) {
    2516:	80 91 5c 02 	lds	r24, 0x025C
    251a:	88 23       	and	r24, r24
    251c:	a9 f1       	breq	.+106    	; 0x2588 <set_timezone+0xbe>
			//timed out!
			displaymode = SHOW_TIME;     
			return;
		}
		if (just_pressed & 0x2) {
    251e:	80 91 59 02 	lds	r24, 0x0259
    2522:	81 ff       	sbrs	r24, 1
    2524:	34 c0       	rjmp	.+104    	; 0x258e <set_timezone+0xc4>
			just_pressed = 0;
    2526:	10 92 59 02 	sts	0x0259, r1
			if (mode == SHOW_MENU) {
    252a:	ff 20       	and	r15, r15
    252c:	a9 f4       	brne	.+42     	; 0x2558 <set_timezone+0x8e>
				// ok now its selected
				mode = SET_HOUR;
				display_timezone(hour, min);
    252e:	81 2f       	mov	r24, r17
    2530:	99 27       	eor	r25, r25
    2532:	87 fd       	sbrc	r24, 7
    2534:	90 95       	com	r25
    2536:	60 2f       	mov	r22, r16
    2538:	70 e0       	ldi	r23, 0x00	; 0
    253a:	0e 94 4d 06 	call	0xc9a	; 0xc9a <display_timezone>
				display[1] |= 0x1;
    253e:	80 91 e7 02 	lds	r24, 0x02E7
    2542:	81 60       	ori	r24, 0x01	; 1
    2544:	80 93 e7 02 	sts	0x02E7, r24
				display[2] |= 0x1;	
    2548:	80 91 e8 02 	lds	r24, 0x02E8
    254c:	81 60       	ori	r24, 0x01	; 1
    254e:	80 93 e8 02 	sts	0x02E8, r24
    2552:	ff 24       	eor	r15, r15
    2554:	f3 94       	inc	r15
    2556:	1b c0       	rjmp	.+54     	; 0x258e <set_timezone+0xc4>
			} else if (mode == SET_HOUR) {
    2558:	81 e0       	ldi	r24, 0x01	; 1
    255a:	f8 16       	cp	r15, r24
    255c:	a9 f4       	brne	.+42     	; 0x2588 <set_timezone+0xbe>
				mode = SET_MIN;
				display_timezone(hour, min);
    255e:	81 2f       	mov	r24, r17
    2560:	99 27       	eor	r25, r25
    2562:	87 fd       	sbrc	r24, 7
    2564:	90 95       	com	r25
    2566:	60 2f       	mov	r22, r16
    2568:	70 e0       	ldi	r23, 0x00	; 0
    256a:	0e 94 4d 06 	call	0xc9a	; 0xc9a <display_timezone>
				display[4] |= 0x1;
    256e:	80 91 ea 02 	lds	r24, 0x02EA
    2572:	81 60       	ori	r24, 0x01	; 1
    2574:	80 93 ea 02 	sts	0x02EA, r24
				display[5] |= 0x1;
    2578:	80 91 eb 02 	lds	r24, 0x02EB
    257c:	81 60       	ori	r24, 0x01	; 1
    257e:	80 93 eb 02 	sts	0x02EB, r24
    2582:	92 e0       	ldi	r25, 0x02	; 2
    2584:	f9 2e       	mov	r15, r25
    2586:	03 c0       	rjmp	.+6      	; 0x258e <set_timezone+0xc4>
			} else {
				// done!
				displaymode = SHOW_TIME;
    2588:	10 92 f4 02 	sts	0x02F4, r1
    258c:	7d c0       	rjmp	.+250    	; 0x2688 <set_timezone+0x1be>
				return;
			}
		}
		if ((just_pressed & 0x4) || (pressed & 0x4)) {
    258e:	80 91 59 02 	lds	r24, 0x0259
    2592:	82 fd       	sbrc	r24, 2
    2594:	04 c0       	rjmp	.+8      	; 0x259e <set_timezone+0xd4>
    2596:	80 91 5a 02 	lds	r24, 0x025A
    259a:	82 ff       	sbrs	r24, 2
    259c:	ad cf       	rjmp	.-166    	; 0x24f8 <set_timezone+0x2e>
			just_pressed = 0;
    259e:	10 92 59 02 	sts	0x0259, r1

			if (mode == SET_HOUR) {
    25a2:	81 e0       	ldi	r24, 0x01	; 1
    25a4:	f8 16       	cp	r15, r24
    25a6:	a9 f5       	brne	.+106    	; 0x2612 <set_timezone+0x148>
				hour = ( ( hour + 1 + 12 ) % 25 ) - 12;
    25a8:	81 2f       	mov	r24, r17
    25aa:	99 27       	eor	r25, r25
    25ac:	87 fd       	sbrc	r24, 7
    25ae:	90 95       	com	r25
    25b0:	0d 96       	adiw	r24, 0x0d	; 13
    25b2:	69 e1       	ldi	r22, 0x19	; 25
    25b4:	70 e0       	ldi	r23, 0x00	; 0
    25b6:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__divmodhi4>
    25ba:	18 2f       	mov	r17, r24
    25bc:	1c 50       	subi	r17, 0x0C	; 12
				display_timezone(hour, min);
    25be:	81 2f       	mov	r24, r17
    25c0:	99 27       	eor	r25, r25
    25c2:	87 fd       	sbrc	r24, 7
    25c4:	90 95       	com	r25
    25c6:	60 2f       	mov	r22, r16
    25c8:	70 e0       	ldi	r23, 0x00	; 0
    25ca:	0e 94 4d 06 	call	0xc9a	; 0xc9a <display_timezone>
				display[1] |= 0x1;
    25ce:	80 91 e7 02 	lds	r24, 0x02E7
    25d2:	81 60       	ori	r24, 0x01	; 1
    25d4:	80 93 e7 02 	sts	0x02E7, r24
				display[2] |= 0x1;
    25d8:	80 91 e8 02 	lds	r24, 0x02E8
    25dc:	81 60       	ori	r24, 0x01	; 1
    25de:	80 93 e8 02 	sts	0x02E8, r24
				intTimeZoneHour = hour;
    25e2:	10 93 44 02 	sts	0x0244, r17
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    25e6:	f9 99       	sbic	0x1f, 1	; 31
    25e8:	fe cf       	rjmp	.-4      	; 0x25e6 <set_timezone+0x11c>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    25ea:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    25ec:	d2 bd       	out	0x22, r29	; 34
    25ee:	c1 bd       	out	0x21, r28	; 33
#endif
    EEDR = __value;
    25f0:	10 bd       	out	0x20, r17	; 32

    __asm__ __volatile__ (
    25f2:	0f b6       	in	r0, 0x3f	; 63
    25f4:	f8 94       	cli
    25f6:	fa 9a       	sbi	0x1f, 2	; 31
    25f8:	f9 9a       	sbi	0x1f, 1	; 31
    25fa:	0f be       	out	0x3f, r0	; 63
				eeprom_write_byte((uint8_t *)EE_ZONE_HOUR, hour);
				//Debugging:
				uart_puts("\n\rTimezone offset hour:\t");
    25fc:	87 ec       	ldi	r24, 0xC7	; 199
    25fe:	91 e0       	ldi	r25, 0x01	; 1
    2600:	0e 94 59 15 	call	0x2ab2	; 0x2ab2 <uart_puts>
				uart_putw_dec(hour);
    2604:	81 2f       	mov	r24, r17
    2606:	99 27       	eor	r25, r25
    2608:	87 fd       	sbrc	r24, 7
    260a:	90 95       	com	r25
    260c:	0e 94 ac 15 	call	0x2b58	; 0x2b58 <uart_putw_dec>
    2610:	2a c0       	rjmp	.+84     	; 0x2666 <set_timezone+0x19c>
			}
			if (mode == SET_MIN) {
    2612:	82 e0       	ldi	r24, 0x02	; 2
    2614:	f8 16       	cp	r15, r24
    2616:	39 f5       	brne	.+78     	; 0x2666 <set_timezone+0x19c>
				min = ( min + 1 ) % 60;
    2618:	80 2f       	mov	r24, r16
    261a:	90 e0       	ldi	r25, 0x00	; 0
    261c:	01 96       	adiw	r24, 0x01	; 1
    261e:	6c e3       	ldi	r22, 0x3C	; 60
    2620:	70 e0       	ldi	r23, 0x00	; 0
    2622:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__divmodhi4>
    2626:	08 2f       	mov	r16, r24
				display_timezone(hour, min);
    2628:	81 2f       	mov	r24, r17
    262a:	99 27       	eor	r25, r25
    262c:	87 fd       	sbrc	r24, 7
    262e:	90 95       	com	r25
    2630:	60 2f       	mov	r22, r16
    2632:	70 e0       	ldi	r23, 0x00	; 0
    2634:	0e 94 4d 06 	call	0xc9a	; 0xc9a <display_timezone>
				display[4] |= 0x1;
    2638:	80 91 ea 02 	lds	r24, 0x02EA
    263c:	81 60       	ori	r24, 0x01	; 1
    263e:	80 93 ea 02 	sts	0x02EA, r24
				display[5] |= 0x1;
    2642:	80 91 eb 02 	lds	r24, 0x02EB
    2646:	81 60       	ori	r24, 0x01	; 1
    2648:	80 93 eb 02 	sts	0x02EB, r24
				intTimeZoneMin = min;
    264c:	00 93 4d 02 	sts	0x024D, r16
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2650:	f9 99       	sbic	0x1f, 1	; 31
    2652:	fe cf       	rjmp	.-4      	; 0x2650 <set_timezone+0x186>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    2654:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    2656:	d2 bc       	out	0x22, r13	; 34
    2658:	c1 bc       	out	0x21, r12	; 33
#endif
    EEDR = __value;
    265a:	00 bd       	out	0x20, r16	; 32

    __asm__ __volatile__ (
    265c:	0f b6       	in	r0, 0x3f	; 63
    265e:	f8 94       	cli
    2660:	fa 9a       	sbi	0x1f, 2	; 31
    2662:	f9 9a       	sbi	0x1f, 1	; 31
    2664:	0f be       	out	0x3f, r0	; 63
				eeprom_write_byte((uint8_t *)EE_ZONE_MIN, min);
			}

			if (pressed & 0x4)
    2666:	80 91 5a 02 	lds	r24, 0x025A
    266a:	82 ff       	sbrs	r24, 2
    266c:	45 cf       	rjmp	.-374    	; 0x24f8 <set_timezone+0x2e>

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    266e:	78 94       	sei

	milliseconds = 0;
    2670:	10 92 57 02 	sts	0x0257, r1
    2674:	10 92 56 02 	sts	0x0256, r1
	while (milliseconds < ms);
    2678:	80 91 56 02 	lds	r24, 0x0256
    267c:	90 91 57 02 	lds	r25, 0x0257
    2680:	8b 34       	cpi	r24, 0x4B	; 75
    2682:	91 05       	cpc	r25, r1
    2684:	c8 f3       	brcs	.-14     	; 0x2678 <set_timezone+0x1ae>
    2686:	38 cf       	rjmp	.-400    	; 0x24f8 <set_timezone+0x2e>

			if (pressed & 0x4)
				delayms(75);
		}
	}
}
    2688:	df 91       	pop	r29
    268a:	cf 91       	pop	r28
    268c:	1f 91       	pop	r17
    268e:	0f 91       	pop	r16
    2690:	ff 90       	pop	r15
    2692:	ef 90       	pop	r14
    2694:	df 90       	pop	r13
    2696:	cf 90       	pop	r12
    2698:	08 95       	ret

0000269a <main>:
	PCMSK2 = _BV(PCINT21) | _BV(PCINT20);    
}



int main(void) {
    269a:	af 92       	push	r10
    269c:	bf 92       	push	r11
    269e:	cf 92       	push	r12
    26a0:	df 92       	push	r13
    26a2:	ef 92       	push	r14
    26a4:	ff 92       	push	r15
    26a6:	0f 93       	push	r16
    26a8:	1f 93       	push	r17
	//  uint8_t i;
	uint8_t mcustate;

	// turn boost off
	TCCR0B = 0;
    26aa:	15 bc       	out	0x25, r1	; 37
	BOOST_DDR |= _BV(BOOST);
    26ac:	56 9a       	sbi	0x0a, 6	; 10
	BOOST_PORT &= ~_BV(BOOST); // pull boost fet low
    26ae:	5e 98       	cbi	0x0b, 6	; 11

	// check if we were reset
	mcustate = MCUSR;
    26b0:	84 b7       	in	r24, 0x34	; 52
	MCUSR = 0;
    26b2:	14 be       	out	0x34, r1	; 52

	uart_putw_hex(mcustate);
    26b4:	90 e0       	ldi	r25, 0x00	; 0
    26b6:	0e 94 8f 15 	call	0x2b1e	; 0x2b1e <uart_putw_hex>

	wdt_disable();
    26ba:	88 e1       	ldi	r24, 0x18	; 24
    26bc:	0f b6       	in	r0, 0x3f	; 63
    26be:	f8 94       	cli
    26c0:	80 93 60 00 	sts	0x0060, r24
    26c4:	10 92 60 00 	sts	0x0060, r1
    26c8:	0f be       	out	0x3f, r0	; 63
	// now turn it back on... 2 second time out
	//WDTCSR |= _BV(WDP0) | _BV(WDP1) | _BV(WDP2);
	//WDTCSR = _BV(WDE);
	wdt_enable(WDTO_2S);
    26ca:	2f e0       	ldi	r18, 0x0F	; 15
    26cc:	88 e1       	ldi	r24, 0x18	; 24
    26ce:	90 e0       	ldi	r25, 0x00	; 0
    26d0:	0f b6       	in	r0, 0x3f	; 63
    26d2:	f8 94       	cli
    26d4:	a8 95       	wdr
    26d6:	80 93 60 00 	sts	0x0060, r24
    26da:	0f be       	out	0x3f, r0	; 63
    26dc:	20 93 60 00 	sts	0x0060, r18
	displaymode = SHOW_TIME;
}

// we reset the watchdog timer 
void kickthedog(void) {
	wdt_reset();
    26e0:	a8 95       	wdr
	wdt_enable(WDTO_2S);
	kickthedog();

	// we lost power at some point so lets alert the user
	// that the time may be wrong (the clock still works)
	timeunknown = 1;
    26e2:	11 e0       	ldi	r17, 0x01	; 1
    26e4:	10 93 4a 02 	sts	0x024A, r17

	// have we read the time & date from eeprom?
	restored = 0;
    26e8:	10 92 4b 02 	sts	0x024B, r1

	// setup uart
	uart_init(BRRL_4800);
    26ec:	87 e6       	ldi	r24, 0x67	; 103
    26ee:	90 e0       	ldi	r25, 0x00	; 0
    26f0:	0e 94 16 15 	call	0x2a2c	; 0x2a2c <uart_init>

	//DEBUGP("VFD Clock");
	DEBUGP("!");
    26f4:	8e e2       	ldi	r24, 0x2E	; 46
    26f6:	91 e0       	ldi	r25, 0x01	; 1
    26f8:	61 e0       	ldi	r22, 0x01	; 1
    26fa:	0e 94 38 15 	call	0x2a70	; 0x2a70 <ROM_putstring>
	uart_puts("\n\rHello World!\n\r");
    26fe:	80 ee       	ldi	r24, 0xE0	; 224
    2700:	91 e0       	ldi	r25, 0x01	; 1
    2702:	0e 94 59 15 	call	0x2ab2	; 0x2ab2 <uart_puts>
	uart_puts("\n\rBuffer size is:\t");
    2706:	81 ef       	ldi	r24, 0xF1	; 241
    2708:	91 e0       	ldi	r25, 0x01	; 1
    270a:	0e 94 59 15 	call	0x2ab2	; 0x2ab2 <uart_puts>
	uart_putw_dec(BUFFERSIZE);
    270e:	80 e8       	ldi	r24, 0x80	; 128
    2710:	90 e0       	ldi	r25, 0x00	; 0
    2712:	0e 94 ac 15 	call	0x2b58	; 0x2b58 <uart_putw_dec>
	uart_puts("\n\r");
    2716:	84 ec       	ldi	r24, 0xC4	; 196
    2718:	91 e0       	ldi	r25, 0x01	; 1
    271a:	0e 94 59 15 	call	0x2ab2	; 0x2ab2 <uart_puts>

	//DEBUGP("turning on anacomp");
	// set up analog comparator
	ACSR = _BV(ACBG) | _BV(ACIE); // use bandgap, intr. on toggle!
    271e:	28 e4       	ldi	r18, 0x48	; 72
    2720:	20 bf       	out	0x30, r18	; 48
    2722:	80 ed       	ldi	r24, 0xD0	; 208
    2724:	97 e0       	ldi	r25, 0x07	; 7
    2726:	01 97       	sbiw	r24, 0x01	; 1
    2728:	f1 f7       	brne	.-4      	; 0x2726 <main+0x8c>
	_delay_ms(1);
	// settle!
	if (ACSR & _BV(ACO)) {
    272a:	00 b6       	in	r0, 0x30	; 48
    272c:	05 fe       	sbrs	r0, 5
    272e:	0b c0       	rjmp	.+22     	; 0x2746 <main+0xac>
		// hmm we should not interrupt here
		ACSR |= _BV(ACI);
    2730:	80 b7       	in	r24, 0x30	; 48
    2732:	80 61       	ori	r24, 0x10	; 16
    2734:	80 bf       	out	0x30, r24	; 48

		// even in low power mode, we run the clock 
		DEBUGP("clock init");
    2736:	83 e2       	ldi	r24, 0x23	; 35
    2738:	91 e0       	ldi	r25, 0x01	; 1
    273a:	61 e0       	ldi	r22, 0x01	; 1
    273c:	0e 94 38 15 	call	0x2a70	; 0x2a70 <ROM_putstring>
		clock_init();  
    2740:	0e 94 55 01 	call	0x2aa	; 0x2aa <clock_init>
    2744:	7e c0       	rjmp	.+252    	; 0x2842 <main+0x1a8>
	kickthedog();
}


void initbuttons(void) {
	DDRB =  _BV(VFDCLK) | _BV(VFDDATA) | _BV(SPK1) | _BV(SPK2);
    2746:	8e e2       	ldi	r24, 0x2E	; 46
    2748:	84 b9       	out	0x04, r24	; 4
	DDRD = _BV(BOOST) | _BV(VFDSWITCH);
    274a:	2a b9       	out	0x0a, r18	; 10
	DDRC = _BV(VFDLOAD) | _BV(VFDBLANK);
    274c:	89 e0       	ldi	r24, 0x09	; 9
    274e:	87 b9       	out	0x07, r24	; 7
	PORTD = _BV(BUTTON1) | _BV(BUTTON3) | _BV(ALARM);
    2750:	84 e3       	ldi	r24, 0x34	; 52
    2752:	8b b9       	out	0x0b, r24	; 11
	PORTB = _BV(BUTTON2);
    2754:	15 b9       	out	0x05, r17	; 5

	PCICR = _BV(PCIE0) | _BV(PCIE2);
    2756:	85 e0       	ldi	r24, 0x05	; 5
    2758:	80 93 68 00 	sts	0x0068, r24
	PCMSK0 = _BV(PCINT0);
    275c:	10 93 6b 00 	sts	0x006B, r17
	PCMSK2 = _BV(PCINT21) | _BV(PCINT20);    
    2760:	80 e3       	ldi	r24, 0x30	; 48
    2762:	80 93 6d 00 	sts	0x006D, r24
		// we aren't in low power mode so init stuff

		// init IOs
		initbuttons();

		VFDSWITCH_PORT &= ~_BV(VFDSWITCH);
    2766:	5b 98       	cbi	0x0b, 3	; 11

		DEBUGP("turning on buttons");
    2768:	80 e1       	ldi	r24, 0x10	; 16
    276a:	91 e0       	ldi	r25, 0x01	; 1
    276c:	61 e0       	ldi	r22, 0x01	; 1
    276e:	0e 94 38 15 	call	0x2a70	; 0x2a70 <ROM_putstring>
		// set up button interrupts
		DEBUGP("turning on alarmsw");
    2772:	8d ef       	ldi	r24, 0xFD	; 253
    2774:	90 e0       	ldi	r25, 0x00	; 0
    2776:	61 e0       	ldi	r22, 0x01	; 1
    2778:	0e 94 38 15 	call	0x2a70	; 0x2a70 <ROM_putstring>
		// set off an interrupt if alarm is set or unset
		EICRA = _BV(ISC00);
    277c:	10 93 69 00 	sts	0x0069, r17
		EIMSK = _BV(INT0);
    2780:	1d bb       	out	0x1d, r17	; 29

		displaymode = SHOW_TIME;
    2782:	10 92 f4 02 	sts	0x02F4, r1
		DEBUGP("vfd init");
    2786:	84 ef       	ldi	r24, 0xF4	; 244
    2788:	90 e0       	ldi	r25, 0x00	; 0
    278a:	61 e0       	ldi	r22, 0x01	; 1
    278c:	0e 94 38 15 	call	0x2a70	; 0x2a70 <ROM_putstring>

/************************* LOW LEVEL DISPLAY ************************/

// Setup SPI
void vfd_init(void) {
	SPCR  = _BV(SPE) | _BV(MSTR) | _BV(SPR0);
    2790:	81 e5       	ldi	r24, 0x51	; 81
    2792:	8c bd       	out	0x2c, r24	; 44
		displaymode = SHOW_TIME;
		DEBUGP("vfd init");
		vfd_init();

#ifdef FEATURE_AUTODIM
		dimmer_init();
    2794:	0e 94 87 02 	call	0x50e	; 0x50e <dimmer_init>
#endif

		DEBUGP("boost init");
    2798:	89 ee       	ldi	r24, 0xE9	; 233
    279a:	90 e0       	ldi	r25, 0x00	; 0
    279c:	61 e0       	ldi	r22, 0x01	; 1
    279e:	0e 94 38 15 	call	0x2a70	; 0x2a70 <ROM_putstring>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    27a2:	f9 99       	sbic	0x1f, 1	; 31
    27a4:	fe cf       	rjmp	.-4      	; 0x27a2 <main+0x108>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    27a6:	89 e0       	ldi	r24, 0x09	; 9
    27a8:	90 e0       	ldi	r25, 0x00	; 0
    27aa:	92 bd       	out	0x22, r25	; 34
    27ac:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    27ae:	f8 9a       	sbi	0x1f, 0	; 31
    27b0:	80 b5       	in	r24, 0x20	; 32
		brightness_level = eeprom_read_byte((uint8_t *)EE_BRIGHT);
    27b2:	80 93 f2 02 	sts	0x02F2, r24
		boost_init(brightness_level);
    27b6:	80 91 f2 02 	lds	r24, 0x02F2
    27ba:	0e 94 09 03 	call	0x612	; 0x612 <boost_init>
		sei();
    27be:	78 94       	sei
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    27c0:	f9 99       	sbic	0x1f, 1	; 31
    27c2:	fe cf       	rjmp	.-4      	; 0x27c0 <main+0x126>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    27c4:	8d e0       	ldi	r24, 0x0D	; 13
    27c6:	90 e0       	ldi	r25, 0x00	; 0
    27c8:	92 bd       	out	0x22, r25	; 34
    27ca:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    27cc:	f8 9a       	sbi	0x1f, 0	; 31
    27ce:	80 b5       	in	r24, 0x20	; 32

		//Load and check the timezone information
		intTimeZoneHour = eeprom_read_byte((uint8_t *)EE_ZONE_HOUR);
    27d0:	80 93 44 02 	sts	0x0244, r24
		if ( ( 12 < intTimeZoneHour ) || ( -12 > intTimeZoneHour ) )
    27d4:	84 5f       	subi	r24, 0xF4	; 244
    27d6:	89 31       	cpi	r24, 0x19	; 25
    27d8:	10 f0       	brcs	.+4      	; 0x27de <main+0x144>
			intTimeZoneHour = 0;
    27da:	10 92 44 02 	sts	0x0244, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    27de:	f9 99       	sbic	0x1f, 1	; 31
    27e0:	fe cf       	rjmp	.-4      	; 0x27de <main+0x144>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    27e2:	8e e0       	ldi	r24, 0x0E	; 14
    27e4:	90 e0       	ldi	r25, 0x00	; 0
    27e6:	92 bd       	out	0x22, r25	; 34
    27e8:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    27ea:	f8 9a       	sbi	0x1f, 0	; 31
    27ec:	80 b5       	in	r24, 0x20	; 32

		intTimeZoneMin = eeprom_read_byte((uint8_t *)EE_ZONE_MIN);
    27ee:	80 93 4d 02 	sts	0x024D, r24
		if ( ( 60 < intTimeZoneMin ) || ( 0 > intTimeZoneMin ) )
    27f2:	8d 33       	cpi	r24, 0x3D	; 61
    27f4:	10 f0       	brcs	.+4      	; 0x27fa <main+0x160>
			intTimeZoneMin = 0;
    27f6:	10 92 4d 02 	sts	0x024D, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    27fa:	f9 99       	sbic	0x1f, 1	; 31
    27fc:	fe cf       	rjmp	.-4      	; 0x27fa <main+0x160>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    27fe:	8b e0       	ldi	r24, 0x0B	; 11
    2800:	90 e0       	ldi	r25, 0x00	; 0
    2802:	92 bd       	out	0x22, r25	; 34
    2804:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2806:	f8 9a       	sbi	0x1f, 0	; 31
    2808:	80 b5       	in	r24, 0x20	; 32

		region = eeprom_read_byte((uint8_t *)EE_REGION);
    280a:	80 93 48 02 	sts	0x0248, r24

		DEBUGP("speaker init");
    280e:	8c ed       	ldi	r24, 0xDC	; 220
    2810:	90 e0       	ldi	r25, 0x00	; 0
    2812:	61 e0       	ldi	r22, 0x01	; 1
    2814:	0e 94 38 15 	call	0x2a70	; 0x2a70 <ROM_putstring>
		speaker_init();
    2818:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <speaker_init>

		beep(4000, 1);
    281c:	80 ea       	ldi	r24, 0xA0	; 160
    281e:	9f e0       	ldi	r25, 0x0F	; 15
    2820:	61 e0       	ldi	r22, 0x01	; 1
    2822:	0e 94 40 02 	call	0x480	; 0x480 <beep>

		DEBUGP("clock init");
    2826:	81 ed       	ldi	r24, 0xD1	; 209
    2828:	90 e0       	ldi	r25, 0x00	; 0
    282a:	61 e0       	ldi	r22, 0x01	; 1
    282c:	0e 94 38 15 	call	0x2a70	; 0x2a70 <ROM_putstring>
		clock_init();  
    2830:	0e 94 55 01 	call	0x2aa	; 0x2aa <clock_init>

		DEBUGP("alarm init");
    2834:	86 ec       	ldi	r24, 0xC6	; 198
    2836:	90 e0       	ldi	r25, 0x00	; 0
    2838:	61 e0       	ldi	r22, 0x01	; 1
    283a:	0e 94 38 15 	call	0x2a70	; 0x2a70 <ROM_putstring>
		setalarmstate();
    283e:	0e 94 ac 0d 	call	0x1b58	; 0x1b58 <setalarmstate>
	}
	DEBUGP("done");
    2842:	81 ec       	ldi	r24, 0xC1	; 193
    2844:	90 e0       	ldi	r25, 0x00	; 0
    2846:	61 e0       	ldi	r22, 0x01	; 1
    2848:	0e 94 38 15 	call	0x2a70	; 0x2a70 <ROM_putstring>
				default:
					displaymode = SHOW_TIME;
			}
		} else if ((just_pressed & 0x2) || (just_pressed & 0x4)) {
			just_pressed = 0;
			displaymode = NONE;
    284c:	f3 e6       	ldi	r31, 0x63	; 99
    284e:	af 2e       	mov	r10, r31
					break;
				case (SET_DATE):
					//displaymode = SET_BRIGHTNESS;
					//display_str("set brit");
					//set_brightness();
					displaymode = SET_ZONE;
    2850:	eb e0       	ldi	r30, 0x0B	; 11
    2852:	be 2e       	mov	r11, r30
					displaymode = SET_VOLUME;
					display_str("set vol ");
					set_volume();
					break;
				case (SET_VOLUME):
					displaymode = SET_REGION;
    2854:	78 e0       	ldi	r23, 0x08	; 8
    2856:	c7 2e       	mov	r12, r23
					displaymode = SET_BRIGHTNESS;
					display_str("set brit");
					set_brightness();
					break;
				case (SET_BRIGHTNESS):
					displaymode = SET_VOLUME;
    2858:	67 e0       	ldi	r22, 0x07	; 7
    285a:	d6 2e       	mov	r13, r22
					displaymode = SET_ZONE;
					display_str("set zone");
					set_timezone();
					break;
				case (SET_ZONE):
					displaymode = SET_BRIGHTNESS;
    285c:	56 e0       	ldi	r21, 0x06	; 6
    285e:	e5 2e       	mov	r14, r21
					display_str("set time");
					set_time();
					timeunknown = 0;
					break;
				case (SET_TIME):
					displaymode = SET_DATE;
    2860:	45 e0       	ldi	r20, 0x05	; 5
    2862:	f4 2e       	mov	r15, r20
					displaymode = SET_ALARM;
					display_str("set alarm");
					set_alarm();
					break;
				case (SET_ALARM):
					displaymode = SET_TIME;
    2864:	03 e0       	ldi	r16, 0x03	; 3
		//DEBUGP(".");
		if (just_pressed & 0x1) {
			just_pressed = 0;
			switch(displaymode) {
				case (SHOW_TIME):
					displaymode = SET_ALARM;
    2866:	14 e0       	ldi	r17, 0x04	; 4
	displaymode = SHOW_TIME;
}

// we reset the watchdog timer 
void kickthedog(void) {
	wdt_reset();
    2868:	a8 95       	wdr
	DEBUGP("done");
	while (1) {
		//_delay_ms(100);
		kickthedog();
		//uart_putc_hex(ACSR);
		if (ACSR & _BV(ACO)) {
    286a:	00 b6       	in	r0, 0x30	; 48
    286c:	05 fe       	sbrs	r0, 5
    286e:	03 c0       	rjmp	.+6      	; 0x2876 <main+0x1dc>
			// DEBUGP("SLEEPYTIME");
			gotosleep();
    2870:	0e 94 da 00 	call	0x1b4	; 0x1b4 <gotosleep>
    2874:	f9 cf       	rjmp	.-14     	; 0x2868 <main+0x1ce>
			continue;
		}
		//DEBUGP(".");
		if (just_pressed & 0x1) {
    2876:	80 91 59 02 	lds	r24, 0x0259
    287a:	80 ff       	sbrs	r24, 0
    287c:	58 c0       	rjmp	.+176    	; 0x292e <main+0x294>
			just_pressed = 0;
    287e:	10 92 59 02 	sts	0x0259, r1
			switch(displaymode) {
    2882:	80 91 f4 02 	lds	r24, 0x02F4
    2886:	85 30       	cpi	r24, 0x05	; 5
    2888:	71 f1       	breq	.+92     	; 0x28e6 <main+0x24c>
    288a:	86 30       	cpi	r24, 0x06	; 6
    288c:	38 f4       	brcc	.+14     	; 0x289c <main+0x202>
    288e:	83 30       	cpi	r24, 0x03	; 3
    2890:	09 f1       	breq	.+66     	; 0x28d4 <main+0x23a>
    2892:	84 30       	cpi	r24, 0x04	; 4
    2894:	a0 f4       	brcc	.+40     	; 0x28be <main+0x224>
    2896:	88 23       	and	r24, r24
    2898:	49 f0       	breq	.+18     	; 0x28ac <main+0x212>
    289a:	66 c0       	rjmp	.+204    	; 0x2968 <main+0x2ce>
    289c:	87 30       	cpi	r24, 0x07	; 7
    289e:	f1 f1       	breq	.+124    	; 0x291c <main+0x282>
    28a0:	87 30       	cpi	r24, 0x07	; 7
    28a2:	98 f1       	brcs	.+102    	; 0x290a <main+0x270>
    28a4:	8b 30       	cpi	r24, 0x0B	; 11
    28a6:	09 f0       	breq	.+2      	; 0x28aa <main+0x210>
    28a8:	5f c0       	rjmp	.+190    	; 0x2968 <main+0x2ce>
    28aa:	26 c0       	rjmp	.+76     	; 0x28f8 <main+0x25e>
				case (SHOW_TIME):
					displaymode = SET_ALARM;
    28ac:	10 93 f4 02 	sts	0x02F4, r17
					display_str("set alarm");
    28b0:	84 e0       	ldi	r24, 0x04	; 4
    28b2:	92 e0       	ldi	r25, 0x02	; 2
    28b4:	0e 94 9e 06 	call	0xd3c	; 0xd3c <display_str>
					set_alarm();
    28b8:	0e 94 63 05 	call	0xac6	; 0xac6 <set_alarm>
    28bc:	57 c0       	rjmp	.+174    	; 0x296c <main+0x2d2>
					break;
				case (SET_ALARM):
					displaymode = SET_TIME;
    28be:	00 93 f4 02 	sts	0x02F4, r16
					display_str("set time");
    28c2:	8e e0       	ldi	r24, 0x0E	; 14
    28c4:	92 e0       	ldi	r25, 0x02	; 2
    28c6:	0e 94 9e 06 	call	0xd3c	; 0xd3c <display_str>
					set_time();
    28ca:	0e 94 d6 03 	call	0x7ac	; 0x7ac <set_time>
					timeunknown = 0;
    28ce:	10 92 4a 02 	sts	0x024A, r1
    28d2:	4c c0       	rjmp	.+152    	; 0x296c <main+0x2d2>
					break;
				case (SET_TIME):
					displaymode = SET_DATE;
    28d4:	f0 92 f4 02 	sts	0x02F4, r15
					display_str("set date");
    28d8:	87 e1       	ldi	r24, 0x17	; 23
    28da:	92 e0       	ldi	r25, 0x02	; 2
    28dc:	0e 94 9e 06 	call	0xd3c	; 0xd3c <display_str>
					set_date();
    28e0:	0e 94 00 0e 	call	0x1c00	; 0x1c00 <set_date>
    28e4:	43 c0       	rjmp	.+134    	; 0x296c <main+0x2d2>
					break;
				case (SET_DATE):
					//displaymode = SET_BRIGHTNESS;
					//display_str("set brit");
					//set_brightness();
					displaymode = SET_ZONE;
    28e6:	b0 92 f4 02 	sts	0x02F4, r11
					display_str("set zone");
    28ea:	80 e2       	ldi	r24, 0x20	; 32
    28ec:	92 e0       	ldi	r25, 0x02	; 2
    28ee:	0e 94 9e 06 	call	0xd3c	; 0xd3c <display_str>
					set_timezone();
    28f2:	0e 94 65 12 	call	0x24ca	; 0x24ca <set_timezone>
    28f6:	3a c0       	rjmp	.+116    	; 0x296c <main+0x2d2>
					break;
				case (SET_ZONE):
					displaymode = SET_BRIGHTNESS;
    28f8:	e0 92 f4 02 	sts	0x02F4, r14
					display_str("set brit");
    28fc:	89 e2       	ldi	r24, 0x29	; 41
    28fe:	92 e0       	ldi	r25, 0x02	; 2
    2900:	0e 94 9e 06 	call	0xd3c	; 0xd3c <display_str>
					set_brightness();
    2904:	0e 94 5f 09 	call	0x12be	; 0x12be <set_brightness>
    2908:	31 c0       	rjmp	.+98     	; 0x296c <main+0x2d2>
					break;
				case (SET_BRIGHTNESS):
					displaymode = SET_VOLUME;
    290a:	d0 92 f4 02 	sts	0x02F4, r13
					display_str("set vol ");
    290e:	82 e3       	ldi	r24, 0x32	; 50
    2910:	92 e0       	ldi	r25, 0x02	; 2
    2912:	0e 94 9e 06 	call	0xd3c	; 0xd3c <display_str>
					set_volume();
    2916:	0e 94 c1 08 	call	0x1182	; 0x1182 <set_volume>
    291a:	28 c0       	rjmp	.+80     	; 0x296c <main+0x2d2>
					break;
				case (SET_VOLUME):
					displaymode = SET_REGION;
    291c:	c0 92 f4 02 	sts	0x02F4, r12
					display_str("set regn");
    2920:	8b e3       	ldi	r24, 0x3B	; 59
    2922:	92 e0       	ldi	r25, 0x02	; 2
    2924:	0e 94 9e 06 	call	0xd3c	; 0xd3c <display_str>
					set_region();
    2928:	0e 94 53 08 	call	0x10a6	; 0x10a6 <set_region>
    292c:	1f c0       	rjmp	.+62     	; 0x296c <main+0x2d2>
					   break;
					   */
				default:
					displaymode = SHOW_TIME;
			}
		} else if ((just_pressed & 0x2) || (just_pressed & 0x4)) {
    292e:	80 91 59 02 	lds	r24, 0x0259
    2932:	81 fd       	sbrc	r24, 1
    2934:	04 c0       	rjmp	.+8      	; 0x293e <main+0x2a4>
    2936:	80 91 59 02 	lds	r24, 0x0259
    293a:	82 ff       	sbrs	r24, 2
    293c:	17 c0       	rjmp	.+46     	; 0x296c <main+0x2d2>
			just_pressed = 0;
    293e:	10 92 59 02 	sts	0x0259, r1
			displaymode = NONE;
    2942:	a0 92 f4 02 	sts	0x02F4, r10
			display_date(DAY);
    2946:	81 e0       	ldi	r24, 0x01	; 1
    2948:	0e 94 c5 06 	call	0xd8a	; 0xd8a <display_date>
	displaymode = SHOW_TIME;
}

// we reset the watchdog timer 
void kickthedog(void) {
	wdt_reset();
    294c:	a8 95       	wdr

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    294e:	78 94       	sei

	milliseconds = 0;
    2950:	10 92 57 02 	sts	0x0257, r1
    2954:	10 92 56 02 	sts	0x0256, r1
	while (milliseconds < ms);
    2958:	80 91 56 02 	lds	r24, 0x0256
    295c:	90 91 57 02 	lds	r25, 0x0257
    2960:	8c 5d       	subi	r24, 0xDC	; 220
    2962:	95 40       	sbci	r25, 0x05	; 5
    2964:	c8 f3       	brcs	.-14     	; 0x2958 <main+0x2be>
	displaymode = SHOW_TIME;
}

// we reset the watchdog timer 
void kickthedog(void) {
	wdt_reset();
    2966:	a8 95       	wdr

			kickthedog();
			delayms(1500);
			kickthedog();

			displaymode = SHOW_TIME;     
    2968:	10 92 f4 02 	sts	0x02F4, r1
//GPS serial data handling functions:

//Check to see if there is any serial data.
uint8_t gpsdataready(void) {

	return (UCSR0A & _BV(RXC0));
    296c:	80 91 c0 00 	lds	r24, 0x00C0

			displaymode = SHOW_TIME;     
		}

		//Check to see if GPS data is ready:
		if ( gpsdataready() ) {
    2970:	87 ff       	sbrs	r24, 7
    2972:	7a cf       	rjmp	.-268    	; 0x2868 <main+0x1ce>
			getgpstime();
    2974:	0e 94 52 11 	call	0x22a4	; 0x22a4 <getgpstime>
    2978:	77 cf       	rjmp	.-274    	; 0x2868 <main+0x1ce>

0000297a <__vector_1>:
		else
			display[0] &= ~0x2;
	}
}

SIGNAL(SIG_INTERRUPT0) {
    297a:	1f 92       	push	r1
    297c:	0f 92       	push	r0
    297e:	0f b6       	in	r0, 0x3f	; 63
    2980:	0f 92       	push	r0
    2982:	11 24       	eor	r1, r1
    2984:	2f 93       	push	r18
    2986:	3f 93       	push	r19
    2988:	4f 93       	push	r20
    298a:	5f 93       	push	r21
    298c:	6f 93       	push	r22
    298e:	7f 93       	push	r23
    2990:	8f 93       	push	r24
    2992:	9f 93       	push	r25
    2994:	af 93       	push	r26
    2996:	bf 93       	push	r27
    2998:	ef 93       	push	r30
    299a:	ff 93       	push	r31
	EIMSK = 0;  //Disable this interrupt while we are processing it.
    299c:	1d ba       	out	0x1d, r1	; 29
	uart_putchar('i');
    299e:	89 e6       	ldi	r24, 0x69	; 105
    29a0:	0e 94 23 15 	call	0x2a46	; 0x2a46 <uart_putchar>
	uint8_t x = ALARM_PIN & _BV(ALARM);
    29a4:	29 b1       	in	r18, 0x09	; 9
	sei();
    29a6:	78 94       	sei

// We have a non-blocking delay function, milliseconds is updated by
// an interrupt
volatile uint16_t milliseconds = 0;
void delayms(uint16_t ms) {
	sei();
    29a8:	78 94       	sei

	milliseconds = 0;
    29aa:	10 92 57 02 	sts	0x0257, r1
    29ae:	10 92 56 02 	sts	0x0256, r1
	while (milliseconds < ms);
    29b2:	80 91 56 02 	lds	r24, 0x0256
    29b6:	90 91 57 02 	lds	r25, 0x0257
    29ba:	0a 97       	sbiw	r24, 0x0a	; 10
    29bc:	d0 f3       	brcs	.-12     	; 0x29b2 <__vector_1+0x38>
	EIMSK = 0;  //Disable this interrupt while we are processing it.
	uart_putchar('i');
	uint8_t x = ALARM_PIN & _BV(ALARM);
	sei();
	delayms(10); // wait for debouncing
	if (x != (ALARM_PIN & _BV(ALARM)))
    29be:	89 b1       	in	r24, 0x09	; 9
    29c0:	24 70       	andi	r18, 0x04	; 4
    29c2:	30 e0       	ldi	r19, 0x00	; 0
    29c4:	90 e0       	ldi	r25, 0x00	; 0
    29c6:	84 70       	andi	r24, 0x04	; 4
    29c8:	90 70       	andi	r25, 0x00	; 0
    29ca:	28 17       	cp	r18, r24
    29cc:	39 07       	cpc	r19, r25
    29ce:	11 f4       	brne	.+4      	; 0x29d4 <__vector_1+0x5a>
	{
		EIMSK = _BV(INT0);
		return;
	}
	setalarmstate();
    29d0:	0e 94 ac 0d 	call	0x1b58	; 0x1b58 <setalarmstate>
	EIMSK = _BV(INT0);  //And reenable it before exiting.
    29d4:	81 e0       	ldi	r24, 0x01	; 1
    29d6:	8d bb       	out	0x1d, r24	; 29
}
    29d8:	ff 91       	pop	r31
    29da:	ef 91       	pop	r30
    29dc:	bf 91       	pop	r27
    29de:	af 91       	pop	r26
    29e0:	9f 91       	pop	r25
    29e2:	8f 91       	pop	r24
    29e4:	7f 91       	pop	r23
    29e6:	6f 91       	pop	r22
    29e8:	5f 91       	pop	r21
    29ea:	4f 91       	pop	r20
    29ec:	3f 91       	pop	r19
    29ee:	2f 91       	pop	r18
    29f0:	0f 90       	pop	r0
    29f2:	0f be       	out	0x3f, r0	; 63
    29f4:	0f 90       	pop	r0
    29f6:	1f 90       	pop	r1
    29f8:	18 95       	reti

000029fa <delay_10us>:
#include <util/delay.h>
#include <avr/pgmspace.h>
#include "util.h"

void delay_10us(uint8_t ns)
{
    29fa:	06 c0       	rjmp	.+12     	; 0x2a08 <delay_10us+0xe>
  uint8_t i;
  
  while (ns != 0) {
    29fc:	90 e0       	ldi	r25, 0x00	; 0
    ns--;
    for (i=0; i< 30; i++) {
      nop;
    29fe:	00 00       	nop
{
  uint8_t i;
  
  while (ns != 0) {
    ns--;
    for (i=0; i< 30; i++) {
    2a00:	9f 5f       	subi	r25, 0xFF	; 255
    2a02:	9e 31       	cpi	r25, 0x1E	; 30
    2a04:	e1 f7       	brne	.-8      	; 0x29fe <delay_10us+0x4>
void delay_10us(uint8_t ns)
{
  uint8_t i;
  
  while (ns != 0) {
    ns--;
    2a06:	81 50       	subi	r24, 0x01	; 1

void delay_10us(uint8_t ns)
{
  uint8_t i;
  
  while (ns != 0) {
    2a08:	88 23       	and	r24, r24
    2a0a:	c1 f7       	brne	.-16     	; 0x29fc <delay_10us+0x2>
    ns--;
    for (i=0; i< 30; i++) {
      nop;
    }
  }
}
    2a0c:	08 95       	ret

00002a0e <delay_s>:
    2a0e:	48 ec       	ldi	r20, 0xC8	; 200
    2a10:	50 e0       	ldi	r21, 0x00	; 0
    2a12:	09 c0       	rjmp	.+18     	; 0x2a26 <delay_s+0x18>

void delay_s(uint8_t s) {
  while (s--) {
    2a14:	20 e1       	ldi	r18, 0x10	; 16
    2a16:	37 e2       	ldi	r19, 0x27	; 39
    2a18:	fa 01       	movw	r30, r20
    2a1a:	31 97       	sbiw	r30, 0x01	; 1
    2a1c:	f1 f7       	brne	.-4      	; 0x2a1a <delay_s+0xc>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2a1e:	21 50       	subi	r18, 0x01	; 1
    2a20:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2a22:	d1 f7       	brne	.-12     	; 0x2a18 <delay_s+0xa>
    2a24:	81 50       	subi	r24, 0x01	; 1
    2a26:	88 23       	and	r24, r24
    2a28:	a9 f7       	brne	.-22     	; 0x2a14 <delay_s+0x6>
    _delay_ms(1000);
  }
}
    2a2a:	08 95       	ret

00002a2c <uart_init>:

void uart_init(uint16_t BRR) {
  /* setup the main UART */
  UBRR0 = BRR;               // set baudrate counter
    2a2c:	90 93 c5 00 	sts	0x00C5, r25
    2a30:	80 93 c4 00 	sts	0x00C4, r24

  UCSR0B = _BV(RXEN0) | _BV(TXEN0);
    2a34:	88 e1       	ldi	r24, 0x18	; 24
    2a36:	80 93 c1 00 	sts	0x00C1, r24
  UCSR0C = _BV(USBS0) | (3<<UCSZ00);
    2a3a:	8e e0       	ldi	r24, 0x0E	; 14
    2a3c:	80 93 c2 00 	sts	0x00C2, r24
  DDRD |= _BV(PD1);
    2a40:	51 9a       	sbi	0x0a, 1	; 10
  DDRD &= ~_BV(PD0);
    2a42:	50 98       	cbi	0x0a, 0	; 10

}
    2a44:	08 95       	ret

00002a46 <uart_putchar>:

int uart_putchar(char c)
{
    2a46:	98 2f       	mov	r25, r24
  loop_until_bit_is_set(UCSR0A, UDRE0);
    2a48:	80 91 c0 00 	lds	r24, 0x00C0
    2a4c:	85 ff       	sbrs	r24, 5
    2a4e:	fc cf       	rjmp	.-8      	; 0x2a48 <uart_putchar+0x2>
  UDR0 = c;
    2a50:	90 93 c6 00 	sts	0x00C6, r25
  return 0;
}
    2a54:	80 e0       	ldi	r24, 0x00	; 0
    2a56:	90 e0       	ldi	r25, 0x00	; 0
    2a58:	08 95       	ret

00002a5a <uart_getchar>:

char uart_getchar(void) {
	while (!(UCSR0A & _BV(RXC0)));
    2a5a:	80 91 c0 00 	lds	r24, 0x00C0
    2a5e:	87 ff       	sbrs	r24, 7
    2a60:	fc cf       	rjmp	.-8      	; 0x2a5a <uart_getchar>
	return UDR0;
    2a62:	80 91 c6 00 	lds	r24, 0x00C6
}
    2a66:	08 95       	ret

00002a68 <uart_getch>:

char uart_getch(void) {
	return (UCSR0A & _BV(RXC0));
    2a68:	80 91 c0 00 	lds	r24, 0x00C0
}
    2a6c:	80 78       	andi	r24, 0x80	; 128
    2a6e:	08 95       	ret

00002a70 <ROM_putstring>:

void ROM_putstring(const char *str, uint8_t nl) {
    2a70:	ac 01       	movw	r20, r24
    2a72:	20 e0       	ldi	r18, 0x00	; 0
    2a74:	07 c0       	rjmp	.+14     	; 0x2a84 <ROM_putstring+0x14>

}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
    2a76:	80 91 c0 00 	lds	r24, 0x00C0
    2a7a:	85 ff       	sbrs	r24, 5
    2a7c:	fc cf       	rjmp	.-8      	; 0x2a76 <ROM_putstring+0x6>
  UDR0 = c;
    2a7e:	30 93 c6 00 	sts	0x00C6, r19
}

void ROM_putstring(const char *str, uint8_t nl) {
    uint8_t i;

    for (i=0; pgm_read_byte(&str[i]); i++) {
    2a82:	2f 5f       	subi	r18, 0xFF	; 255
    2a84:	fa 01       	movw	r30, r20
    2a86:	e2 0f       	add	r30, r18
    2a88:	f1 1d       	adc	r31, r1
    2a8a:	34 91       	lpm	r19, Z+
    2a8c:	33 23       	and	r19, r19
    2a8e:	99 f7       	brne	.-26     	; 0x2a76 <ROM_putstring+0x6>
        uart_putchar(pgm_read_byte(&str[i]));
  }
  if (nl) {
    2a90:	66 23       	and	r22, r22
    2a92:	71 f0       	breq	.+28     	; 0x2ab0 <ROM_putstring+0x40>

}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
    2a94:	80 91 c0 00 	lds	r24, 0x00C0
    2a98:	85 ff       	sbrs	r24, 5
    2a9a:	fc cf       	rjmp	.-8      	; 0x2a94 <ROM_putstring+0x24>
  UDR0 = c;
    2a9c:	8a e0       	ldi	r24, 0x0A	; 10
    2a9e:	80 93 c6 00 	sts	0x00C6, r24

}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
    2aa2:	80 91 c0 00 	lds	r24, 0x00C0
    2aa6:	85 ff       	sbrs	r24, 5
    2aa8:	fc cf       	rjmp	.-8      	; 0x2aa2 <ROM_putstring+0x32>
  UDR0 = c;
    2aaa:	8d e0       	ldi	r24, 0x0D	; 13
    2aac:	80 93 c6 00 	sts	0x00C6, r24
    2ab0:	08 95       	ret

00002ab2 <uart_puts>:
        uart_putchar('\n'); uart_putchar('\r');
  }
}

void uart_puts(const char* str)
{
    2ab2:	fc 01       	movw	r30, r24
    2ab4:	07 c0       	rjmp	.+14     	; 0x2ac4 <uart_puts+0x12>

}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
    2ab6:	80 91 c0 00 	lds	r24, 0x00C0
    2aba:	85 ff       	sbrs	r24, 5
    2abc:	fc cf       	rjmp	.-8      	; 0x2ab6 <uart_puts+0x4>
}

void uart_puts(const char* str)
{
    while(*str)
        uart_putc(*str++);
    2abe:	31 96       	adiw	r30, 0x01	; 1
}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
  UDR0 = c;
    2ac0:	90 93 c6 00 	sts	0x00C6, r25
  }
}

void uart_puts(const char* str)
{
    while(*str)
    2ac4:	90 81       	ld	r25, Z
    2ac6:	99 23       	and	r25, r25
    2ac8:	b1 f7       	brne	.-20     	; 0x2ab6 <uart_puts+0x4>
        uart_putc(*str++);
}
    2aca:	08 95       	ret

00002acc <uart_putc_hex>:


void uart_putc_hex(uint8_t b)
{
    2acc:	28 2f       	mov	r18, r24
    /* upper nibble */
    if((b >> 4) < 0x0a)
    2ace:	98 2f       	mov	r25, r24
    2ad0:	92 95       	swap	r25
    2ad2:	9f 70       	andi	r25, 0x0F	; 15
    2ad4:	9a 30       	cpi	r25, 0x0A	; 10
    2ad6:	30 f4       	brcc	.+12     	; 0x2ae4 <uart_putc_hex+0x18>

}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
    2ad8:	80 91 c0 00 	lds	r24, 0x00C0
    2adc:	85 ff       	sbrs	r24, 5
    2ade:	fc cf       	rjmp	.-8      	; 0x2ad8 <uart_putc_hex+0xc>

void uart_putc_hex(uint8_t b)
{
    /* upper nibble */
    if((b >> 4) < 0x0a)
        uart_putc((b >> 4) + '0');
    2ae0:	90 5d       	subi	r25, 0xD0	; 208
    2ae2:	05 c0       	rjmp	.+10     	; 0x2aee <uart_putc_hex+0x22>

}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
    2ae4:	80 91 c0 00 	lds	r24, 0x00C0
    2ae8:	85 ff       	sbrs	r24, 5
    2aea:	fc cf       	rjmp	.-8      	; 0x2ae4 <uart_putc_hex+0x18>
{
    /* upper nibble */
    if((b >> 4) < 0x0a)
        uart_putc((b >> 4) + '0');
    else
        uart_putc((b >> 4) - 0x0a + 'a');
    2aec:	99 5a       	subi	r25, 0xA9	; 169
}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
  UDR0 = c;
    2aee:	90 93 c6 00 	sts	0x00C6, r25
        uart_putc((b >> 4) + '0');
    else
        uart_putc((b >> 4) - 0x0a + 'a');

    /* lower nibble */
    if((b & 0x0f) < 0x0a)
    2af2:	82 2f       	mov	r24, r18
    2af4:	90 e0       	ldi	r25, 0x00	; 0
    2af6:	8f 70       	andi	r24, 0x0F	; 15
    2af8:	90 70       	andi	r25, 0x00	; 0
    2afa:	0a 97       	sbiw	r24, 0x0a	; 10
    2afc:	3c f4       	brge	.+14     	; 0x2b0c <uart_putc_hex+0x40>

}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
    2afe:	80 91 c0 00 	lds	r24, 0x00C0
    2b02:	85 ff       	sbrs	r24, 5
    2b04:	fc cf       	rjmp	.-8      	; 0x2afe <uart_putc_hex+0x32>
    else
        uart_putc((b >> 4) - 0x0a + 'a');

    /* lower nibble */
    if((b & 0x0f) < 0x0a)
        uart_putc((b & 0x0f) + '0');
    2b06:	2f 70       	andi	r18, 0x0F	; 15
    2b08:	20 5d       	subi	r18, 0xD0	; 208
    2b0a:	06 c0       	rjmp	.+12     	; 0x2b18 <uart_putc_hex+0x4c>

}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
    2b0c:	80 91 c0 00 	lds	r24, 0x00C0
    2b10:	85 ff       	sbrs	r24, 5
    2b12:	fc cf       	rjmp	.-8      	; 0x2b0c <uart_putc_hex+0x40>

    /* lower nibble */
    if((b & 0x0f) < 0x0a)
        uart_putc((b & 0x0f) + '0');
    else
        uart_putc((b & 0x0f) - 0x0a + 'a');
    2b14:	2f 70       	andi	r18, 0x0F	; 15
    2b16:	29 5a       	subi	r18, 0xA9	; 169
}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
  UDR0 = c;
    2b18:	20 93 c6 00 	sts	0x00C6, r18
    2b1c:	08 95       	ret

00002b1e <uart_putw_hex>:
    else
        uart_putc((b & 0x0f) - 0x0a + 'a');
}

void uart_putw_hex(uint16_t w)
{
    2b1e:	1f 93       	push	r17
    2b20:	18 2f       	mov	r17, r24
    uart_putc_hex((uint8_t) (w >> 8));
    2b22:	89 2f       	mov	r24, r25
    2b24:	0e 94 66 15 	call	0x2acc	; 0x2acc <uart_putc_hex>
    uart_putc_hex((uint8_t) (w & 0xff));
    2b28:	81 2f       	mov	r24, r17
    2b2a:	0e 94 66 15 	call	0x2acc	; 0x2acc <uart_putc_hex>
}
    2b2e:	1f 91       	pop	r17
    2b30:	08 95       	ret

00002b32 <uart_putdw_hex>:

void uart_putdw_hex(uint32_t dw)
{
    2b32:	ef 92       	push	r14
    2b34:	ff 92       	push	r15
    2b36:	0f 93       	push	r16
    2b38:	1f 93       	push	r17
    2b3a:	7b 01       	movw	r14, r22
    2b3c:	8c 01       	movw	r16, r24
    uart_putw_hex((uint16_t) (dw >> 16));
    2b3e:	c8 01       	movw	r24, r16
    2b40:	aa 27       	eor	r26, r26
    2b42:	bb 27       	eor	r27, r27
    2b44:	0e 94 8f 15 	call	0x2b1e	; 0x2b1e <uart_putw_hex>
    uart_putw_hex((uint16_t) (dw & 0xffff));
    2b48:	c7 01       	movw	r24, r14
    2b4a:	0e 94 8f 15 	call	0x2b1e	; 0x2b1e <uart_putw_hex>
}
    2b4e:	1f 91       	pop	r17
    2b50:	0f 91       	pop	r16
    2b52:	ff 90       	pop	r15
    2b54:	ef 90       	pop	r14
    2b56:	08 95       	ret

00002b58 <uart_putw_dec>:

void uart_putw_dec(uint16_t w)
{
    2b58:	0f 93       	push	r16
    2b5a:	1f 93       	push	r17
    2b5c:	cf 93       	push	r28
    2b5e:	df 93       	push	r29
    2b60:	8c 01       	movw	r16, r24
    2b62:	e0 e1       	ldi	r30, 0x10	; 16
    2b64:	f7 e2       	ldi	r31, 0x27	; 39
    2b66:	40 e0       	ldi	r20, 0x00	; 0
    2b68:	c0 e0       	ldi	r28, 0x00	; 0
    2b6a:	d0 e0       	ldi	r29, 0x00	; 0
    uint16_t num = 10000;
    uint8_t started = 0;

    while(num > 0)
    {
        uint8_t b = w / num;
    2b6c:	c8 01       	movw	r24, r16
    2b6e:	bf 01       	movw	r22, r30
    2b70:	0e 94 b2 16 	call	0x2d64	; 0x2d64 <__udivmodhi4>
    2b74:	26 2f       	mov	r18, r22
        if(b > 0 || started || num == 1)
    2b76:	66 23       	and	r22, r22
    2b78:	29 f4       	brne	.+10     	; 0x2b84 <uart_putw_dec+0x2c>
    2b7a:	44 23       	and	r20, r20
    2b7c:	19 f4       	brne	.+6      	; 0x2b84 <uart_putw_dec+0x2c>
    2b7e:	e1 30       	cpi	r30, 0x01	; 1
    2b80:	f1 05       	cpc	r31, r1
    2b82:	49 f4       	brne	.+18     	; 0x2b96 <uart_putw_dec+0x3e>

}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
    2b84:	80 91 c0 00 	lds	r24, 0x00C0
    2b88:	85 ff       	sbrs	r24, 5
    2b8a:	fc cf       	rjmp	.-8      	; 0x2b84 <uart_putw_dec+0x2c>
    while(num > 0)
    {
        uint8_t b = w / num;
        if(b > 0 || started || num == 1)
        {
            uart_putc('0' + b);
    2b8c:	20 5d       	subi	r18, 0xD0	; 208
}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
  UDR0 = c;
    2b8e:	20 93 c6 00 	sts	0x00C6, r18
    2b92:	20 53       	subi	r18, 0x30	; 48
    2b94:	41 e0       	ldi	r20, 0x01	; 1
            uart_putc('0' + b);
            started = 1;
        }
        w -= b * num;

        num /= 10;
    2b96:	cf 01       	movw	r24, r30
    2b98:	6a e0       	ldi	r22, 0x0A	; 10
    2b9a:	70 e0       	ldi	r23, 0x00	; 0
    2b9c:	0e 94 b2 16 	call	0x2d64	; 0x2d64 <__udivmodhi4>
    2ba0:	21 96       	adiw	r28, 0x01	; 1
void uart_putw_dec(uint16_t w)
{
    uint16_t num = 10000;
    uint8_t started = 0;

    while(num > 0)
    2ba2:	c5 30       	cpi	r28, 0x05	; 5
    2ba4:	d1 05       	cpc	r29, r1
    2ba6:	71 f0       	breq	.+28     	; 0x2bc4 <uart_putw_dec+0x6c>
        if(b > 0 || started || num == 1)
        {
            uart_putc('0' + b);
            started = 1;
        }
        w -= b * num;
    2ba8:	82 2f       	mov	r24, r18
    2baa:	90 e0       	ldi	r25, 0x00	; 0
    2bac:	9c 01       	movw	r18, r24
    2bae:	2e 9f       	mul	r18, r30
    2bb0:	c0 01       	movw	r24, r0
    2bb2:	2f 9f       	mul	r18, r31
    2bb4:	90 0d       	add	r25, r0
    2bb6:	3e 9f       	mul	r19, r30
    2bb8:	90 0d       	add	r25, r0
    2bba:	11 24       	eor	r1, r1
    2bbc:	08 1b       	sub	r16, r24
    2bbe:	19 0b       	sbc	r17, r25
    2bc0:	fb 01       	movw	r30, r22
    2bc2:	d4 cf       	rjmp	.-88     	; 0x2b6c <uart_putw_dec+0x14>

        num /= 10;
    }
}
    2bc4:	df 91       	pop	r29
    2bc6:	cf 91       	pop	r28
    2bc8:	1f 91       	pop	r17
    2bca:	0f 91       	pop	r16
    2bcc:	08 95       	ret

00002bce <uart_putdw_dec>:

void uart_putdw_dec(uint32_t dw)
{
    2bce:	4f 92       	push	r4
    2bd0:	5f 92       	push	r5
    2bd2:	6f 92       	push	r6
    2bd4:	7f 92       	push	r7
    2bd6:	8f 92       	push	r8
    2bd8:	9f 92       	push	r9
    2bda:	af 92       	push	r10
    2bdc:	bf 92       	push	r11
    2bde:	cf 92       	push	r12
    2be0:	df 92       	push	r13
    2be2:	ef 92       	push	r14
    2be4:	ff 92       	push	r15
    2be6:	0f 93       	push	r16
    2be8:	1f 93       	push	r17
    2bea:	cf 93       	push	r28
    2bec:	df 93       	push	r29
    2bee:	4b 01       	movw	r8, r22
    2bf0:	5c 01       	movw	r10, r24
    2bf2:	e1 2c       	mov	r14, r1
    2bf4:	9a ec       	ldi	r25, 0xCA	; 202
    2bf6:	f9 2e       	mov	r15, r25
    2bf8:	9a e9       	ldi	r25, 0x9A	; 154
    2bfa:	09 2f       	mov	r16, r25
    2bfc:	9b e3       	ldi	r25, 0x3B	; 59
    2bfe:	19 2f       	mov	r17, r25
    2c00:	44 24       	eor	r4, r4
    2c02:	c0 e0       	ldi	r28, 0x00	; 0
    2c04:	d0 e0       	ldi	r29, 0x00	; 0
    uint32_t num = 1000000000;
    uint8_t started = 0;

    while(num > 0)
    {
        uint8_t b = dw / num;
    2c06:	c5 01       	movw	r24, r10
    2c08:	b4 01       	movw	r22, r8
    2c0a:	a8 01       	movw	r20, r16
    2c0c:	97 01       	movw	r18, r14
    2c0e:	0e 94 d9 16 	call	0x2db2	; 0x2db2 <__udivmodsi4>
    2c12:	d2 2e       	mov	r13, r18
        if(b > 0 || started || num == 1)
    2c14:	22 23       	and	r18, r18
    2c16:	41 f4       	brne	.+16     	; 0x2c28 <uart_putdw_dec+0x5a>
    2c18:	44 20       	and	r4, r4
    2c1a:	31 f4       	brne	.+12     	; 0x2c28 <uart_putdw_dec+0x5a>
    2c1c:	81 e0       	ldi	r24, 0x01	; 1
    2c1e:	e8 16       	cp	r14, r24
    2c20:	f1 04       	cpc	r15, r1
    2c22:	01 05       	cpc	r16, r1
    2c24:	11 05       	cpc	r17, r1
    2c26:	61 f4       	brne	.+24     	; 0x2c40 <uart_putdw_dec+0x72>

}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
    2c28:	80 91 c0 00 	lds	r24, 0x00C0
    2c2c:	85 ff       	sbrs	r24, 5
    2c2e:	fc cf       	rjmp	.-8      	; 0x2c28 <uart_putdw_dec+0x5a>
    while(num > 0)
    {
        uint8_t b = dw / num;
        if(b > 0 || started || num == 1)
        {
            uart_putc('0' + b);
    2c30:	80 e3       	ldi	r24, 0x30	; 48
    2c32:	d8 0e       	add	r13, r24
}

int uart_putchar(char c)
{
  loop_until_bit_is_set(UCSR0A, UDRE0);
  UDR0 = c;
    2c34:	d0 92 c6 00 	sts	0x00C6, r13
    2c38:	80 ed       	ldi	r24, 0xD0	; 208
    2c3a:	d8 0e       	add	r13, r24
    2c3c:	44 24       	eor	r4, r4
    2c3e:	43 94       	inc	r4
            uart_putc('0' + b);
            started = 1;
        }
        dw -= b * num;

        num /= 10;
    2c40:	c8 01       	movw	r24, r16
    2c42:	b7 01       	movw	r22, r14
    2c44:	2a e0       	ldi	r18, 0x0A	; 10
    2c46:	30 e0       	ldi	r19, 0x00	; 0
    2c48:	40 e0       	ldi	r20, 0x00	; 0
    2c4a:	50 e0       	ldi	r21, 0x00	; 0
    2c4c:	0e 94 d9 16 	call	0x2db2	; 0x2db2 <__udivmodsi4>
    2c50:	c2 2e       	mov	r12, r18
    2c52:	73 2e       	mov	r7, r19
    2c54:	64 2e       	mov	r6, r20
    2c56:	55 2e       	mov	r5, r21
    2c58:	21 96       	adiw	r28, 0x01	; 1
void uart_putdw_dec(uint32_t dw)
{
    uint32_t num = 1000000000;
    uint8_t started = 0;

    while(num > 0)
    2c5a:	ca 30       	cpi	r28, 0x0A	; 10
    2c5c:	d1 05       	cpc	r29, r1
    2c5e:	a9 f0       	breq	.+42     	; 0x2c8a <uart_putdw_dec+0xbc>
        if(b > 0 || started || num == 1)
        {
            uart_putc('0' + b);
            started = 1;
        }
        dw -= b * num;
    2c60:	6d 2d       	mov	r22, r13
    2c62:	70 e0       	ldi	r23, 0x00	; 0
    2c64:	80 e0       	ldi	r24, 0x00	; 0
    2c66:	90 e0       	ldi	r25, 0x00	; 0
    2c68:	a8 01       	movw	r20, r16
    2c6a:	97 01       	movw	r18, r14
    2c6c:	0e 94 7a 16 	call	0x2cf4	; 0x2cf4 <__mulsi3>
    2c70:	86 1a       	sub	r8, r22
    2c72:	97 0a       	sbc	r9, r23
    2c74:	a8 0a       	sbc	r10, r24
    2c76:	b9 0a       	sbc	r11, r25
    2c78:	2c 2d       	mov	r18, r12
    2c7a:	37 2d       	mov	r19, r7
    2c7c:	46 2d       	mov	r20, r6
    2c7e:	55 2d       	mov	r21, r5
    2c80:	c9 01       	movw	r24, r18
    2c82:	da 01       	movw	r26, r20
    2c84:	7c 01       	movw	r14, r24
    2c86:	8d 01       	movw	r16, r26
    2c88:	be cf       	rjmp	.-132    	; 0x2c06 <uart_putdw_dec+0x38>

        num /= 10;
    }
}
    2c8a:	df 91       	pop	r29
    2c8c:	cf 91       	pop	r28
    2c8e:	1f 91       	pop	r17
    2c90:	0f 91       	pop	r16
    2c92:	ff 90       	pop	r15
    2c94:	ef 90       	pop	r14
    2c96:	df 90       	pop	r13
    2c98:	cf 90       	pop	r12
    2c9a:	bf 90       	pop	r11
    2c9c:	af 90       	pop	r10
    2c9e:	9f 90       	pop	r9
    2ca0:	8f 90       	pop	r8
    2ca2:	7f 90       	pop	r7
    2ca4:	6f 90       	pop	r6
    2ca6:	5f 90       	pop	r5
    2ca8:	4f 90       	pop	r4
    2caa:	08 95       	ret

00002cac <strchr>:
    2cac:	fc 01       	movw	r30, r24
    2cae:	81 91       	ld	r24, Z+
    2cb0:	86 17       	cp	r24, r22
    2cb2:	21 f0       	breq	.+8      	; 0x2cbc <strchr+0x10>
    2cb4:	88 23       	and	r24, r24
    2cb6:	d9 f7       	brne	.-10     	; 0x2cae <strchr+0x2>
    2cb8:	99 27       	eor	r25, r25
    2cba:	08 95       	ret
    2cbc:	31 97       	sbiw	r30, 0x01	; 1
    2cbe:	cf 01       	movw	r24, r30
    2cc0:	08 95       	ret

00002cc2 <strcmp>:
    2cc2:	fb 01       	movw	r30, r22
    2cc4:	dc 01       	movw	r26, r24
    2cc6:	8d 91       	ld	r24, X+
    2cc8:	01 90       	ld	r0, Z+
    2cca:	80 19       	sub	r24, r0
    2ccc:	01 10       	cpse	r0, r1
    2cce:	d9 f3       	breq	.-10     	; 0x2cc6 <strcmp+0x4>
    2cd0:	99 0b       	sbc	r25, r25
    2cd2:	08 95       	ret

00002cd4 <strncat>:
    2cd4:	fb 01       	movw	r30, r22
    2cd6:	dc 01       	movw	r26, r24
    2cd8:	0d 90       	ld	r0, X+
    2cda:	00 20       	and	r0, r0
    2cdc:	e9 f7       	brne	.-6      	; 0x2cd8 <strncat+0x4>
    2cde:	11 97       	sbiw	r26, 0x01	; 1
    2ce0:	41 50       	subi	r20, 0x01	; 1
    2ce2:	50 40       	sbci	r21, 0x00	; 0
    2ce4:	28 f0       	brcs	.+10     	; 0x2cf0 <strncat+0x1c>
    2ce6:	01 90       	ld	r0, Z+
    2ce8:	00 20       	and	r0, r0
    2cea:	0d 92       	st	X+, r0
    2cec:	c9 f7       	brne	.-14     	; 0x2ce0 <strncat+0xc>
    2cee:	08 95       	ret
    2cf0:	1c 92       	st	X, r1
    2cf2:	08 95       	ret

00002cf4 <__mulsi3>:
    2cf4:	62 9f       	mul	r22, r18
    2cf6:	d0 01       	movw	r26, r0
    2cf8:	73 9f       	mul	r23, r19
    2cfa:	f0 01       	movw	r30, r0
    2cfc:	82 9f       	mul	r24, r18
    2cfe:	e0 0d       	add	r30, r0
    2d00:	f1 1d       	adc	r31, r1
    2d02:	64 9f       	mul	r22, r20
    2d04:	e0 0d       	add	r30, r0
    2d06:	f1 1d       	adc	r31, r1
    2d08:	92 9f       	mul	r25, r18
    2d0a:	f0 0d       	add	r31, r0
    2d0c:	83 9f       	mul	r24, r19
    2d0e:	f0 0d       	add	r31, r0
    2d10:	74 9f       	mul	r23, r20
    2d12:	f0 0d       	add	r31, r0
    2d14:	65 9f       	mul	r22, r21
    2d16:	f0 0d       	add	r31, r0
    2d18:	99 27       	eor	r25, r25
    2d1a:	72 9f       	mul	r23, r18
    2d1c:	b0 0d       	add	r27, r0
    2d1e:	e1 1d       	adc	r30, r1
    2d20:	f9 1f       	adc	r31, r25
    2d22:	63 9f       	mul	r22, r19
    2d24:	b0 0d       	add	r27, r0
    2d26:	e1 1d       	adc	r30, r1
    2d28:	f9 1f       	adc	r31, r25
    2d2a:	bd 01       	movw	r22, r26
    2d2c:	cf 01       	movw	r24, r30
    2d2e:	11 24       	eor	r1, r1
    2d30:	08 95       	ret

00002d32 <__udivmodqi4>:
    2d32:	99 1b       	sub	r25, r25
    2d34:	79 e0       	ldi	r23, 0x09	; 9
    2d36:	04 c0       	rjmp	.+8      	; 0x2d40 <__udivmodqi4_ep>

00002d38 <__udivmodqi4_loop>:
    2d38:	99 1f       	adc	r25, r25
    2d3a:	96 17       	cp	r25, r22
    2d3c:	08 f0       	brcs	.+2      	; 0x2d40 <__udivmodqi4_ep>
    2d3e:	96 1b       	sub	r25, r22

00002d40 <__udivmodqi4_ep>:
    2d40:	88 1f       	adc	r24, r24
    2d42:	7a 95       	dec	r23
    2d44:	c9 f7       	brne	.-14     	; 0x2d38 <__udivmodqi4_loop>
    2d46:	80 95       	com	r24
    2d48:	08 95       	ret

00002d4a <__divmodqi4>:
    2d4a:	87 fb       	bst	r24, 7
    2d4c:	08 2e       	mov	r0, r24
    2d4e:	06 26       	eor	r0, r22
    2d50:	87 fd       	sbrc	r24, 7
    2d52:	81 95       	neg	r24
    2d54:	67 fd       	sbrc	r22, 7
    2d56:	61 95       	neg	r22
    2d58:	ec df       	rcall	.-40     	; 0x2d32 <__udivmodqi4>
    2d5a:	0e f4       	brtc	.+2      	; 0x2d5e <__divmodqi4_1>
    2d5c:	91 95       	neg	r25

00002d5e <__divmodqi4_1>:
    2d5e:	07 fc       	sbrc	r0, 7
    2d60:	81 95       	neg	r24

00002d62 <__divmodqi4_exit>:
    2d62:	08 95       	ret

00002d64 <__udivmodhi4>:
    2d64:	aa 1b       	sub	r26, r26
    2d66:	bb 1b       	sub	r27, r27
    2d68:	51 e1       	ldi	r21, 0x11	; 17
    2d6a:	07 c0       	rjmp	.+14     	; 0x2d7a <__udivmodhi4_ep>

00002d6c <__udivmodhi4_loop>:
    2d6c:	aa 1f       	adc	r26, r26
    2d6e:	bb 1f       	adc	r27, r27
    2d70:	a6 17       	cp	r26, r22
    2d72:	b7 07       	cpc	r27, r23
    2d74:	10 f0       	brcs	.+4      	; 0x2d7a <__udivmodhi4_ep>
    2d76:	a6 1b       	sub	r26, r22
    2d78:	b7 0b       	sbc	r27, r23

00002d7a <__udivmodhi4_ep>:
    2d7a:	88 1f       	adc	r24, r24
    2d7c:	99 1f       	adc	r25, r25
    2d7e:	5a 95       	dec	r21
    2d80:	a9 f7       	brne	.-22     	; 0x2d6c <__udivmodhi4_loop>
    2d82:	80 95       	com	r24
    2d84:	90 95       	com	r25
    2d86:	bc 01       	movw	r22, r24
    2d88:	cd 01       	movw	r24, r26
    2d8a:	08 95       	ret

00002d8c <__divmodhi4>:
    2d8c:	97 fb       	bst	r25, 7
    2d8e:	09 2e       	mov	r0, r25
    2d90:	07 26       	eor	r0, r23
    2d92:	0a d0       	rcall	.+20     	; 0x2da8 <__divmodhi4_neg1>
    2d94:	77 fd       	sbrc	r23, 7
    2d96:	04 d0       	rcall	.+8      	; 0x2da0 <__divmodhi4_neg2>
    2d98:	e5 df       	rcall	.-54     	; 0x2d64 <__udivmodhi4>
    2d9a:	06 d0       	rcall	.+12     	; 0x2da8 <__divmodhi4_neg1>
    2d9c:	00 20       	and	r0, r0
    2d9e:	1a f4       	brpl	.+6      	; 0x2da6 <__divmodhi4_exit>

00002da0 <__divmodhi4_neg2>:
    2da0:	70 95       	com	r23
    2da2:	61 95       	neg	r22
    2da4:	7f 4f       	sbci	r23, 0xFF	; 255

00002da6 <__divmodhi4_exit>:
    2da6:	08 95       	ret

00002da8 <__divmodhi4_neg1>:
    2da8:	f6 f7       	brtc	.-4      	; 0x2da6 <__divmodhi4_exit>
    2daa:	90 95       	com	r25
    2dac:	81 95       	neg	r24
    2dae:	9f 4f       	sbci	r25, 0xFF	; 255
    2db0:	08 95       	ret

00002db2 <__udivmodsi4>:
    2db2:	a1 e2       	ldi	r26, 0x21	; 33
    2db4:	1a 2e       	mov	r1, r26
    2db6:	aa 1b       	sub	r26, r26
    2db8:	bb 1b       	sub	r27, r27
    2dba:	fd 01       	movw	r30, r26
    2dbc:	0d c0       	rjmp	.+26     	; 0x2dd8 <__udivmodsi4_ep>

00002dbe <__udivmodsi4_loop>:
    2dbe:	aa 1f       	adc	r26, r26
    2dc0:	bb 1f       	adc	r27, r27
    2dc2:	ee 1f       	adc	r30, r30
    2dc4:	ff 1f       	adc	r31, r31
    2dc6:	a2 17       	cp	r26, r18
    2dc8:	b3 07       	cpc	r27, r19
    2dca:	e4 07       	cpc	r30, r20
    2dcc:	f5 07       	cpc	r31, r21
    2dce:	20 f0       	brcs	.+8      	; 0x2dd8 <__udivmodsi4_ep>
    2dd0:	a2 1b       	sub	r26, r18
    2dd2:	b3 0b       	sbc	r27, r19
    2dd4:	e4 0b       	sbc	r30, r20
    2dd6:	f5 0b       	sbc	r31, r21

00002dd8 <__udivmodsi4_ep>:
    2dd8:	66 1f       	adc	r22, r22
    2dda:	77 1f       	adc	r23, r23
    2ddc:	88 1f       	adc	r24, r24
    2dde:	99 1f       	adc	r25, r25
    2de0:	1a 94       	dec	r1
    2de2:	69 f7       	brne	.-38     	; 0x2dbe <__udivmodsi4_loop>
    2de4:	60 95       	com	r22
    2de6:	70 95       	com	r23
    2de8:	80 95       	com	r24
    2dea:	90 95       	com	r25
    2dec:	9b 01       	movw	r18, r22
    2dee:	ac 01       	movw	r20, r24
    2df0:	bd 01       	movw	r22, r26
    2df2:	cf 01       	movw	r24, r30
    2df4:	08 95       	ret

00002df6 <__divmodsi4>:
    2df6:	97 fb       	bst	r25, 7
    2df8:	09 2e       	mov	r0, r25
    2dfa:	05 26       	eor	r0, r21
    2dfc:	0e d0       	rcall	.+28     	; 0x2e1a <__divmodsi4_neg1>
    2dfe:	57 fd       	sbrc	r21, 7
    2e00:	04 d0       	rcall	.+8      	; 0x2e0a <__divmodsi4_neg2>
    2e02:	d7 df       	rcall	.-82     	; 0x2db2 <__udivmodsi4>
    2e04:	0a d0       	rcall	.+20     	; 0x2e1a <__divmodsi4_neg1>
    2e06:	00 1c       	adc	r0, r0
    2e08:	38 f4       	brcc	.+14     	; 0x2e18 <__divmodsi4_exit>

00002e0a <__divmodsi4_neg2>:
    2e0a:	50 95       	com	r21
    2e0c:	40 95       	com	r20
    2e0e:	30 95       	com	r19
    2e10:	21 95       	neg	r18
    2e12:	3f 4f       	sbci	r19, 0xFF	; 255
    2e14:	4f 4f       	sbci	r20, 0xFF	; 255
    2e16:	5f 4f       	sbci	r21, 0xFF	; 255

00002e18 <__divmodsi4_exit>:
    2e18:	08 95       	ret

00002e1a <__divmodsi4_neg1>:
    2e1a:	f6 f7       	brtc	.-4      	; 0x2e18 <__divmodsi4_exit>
    2e1c:	90 95       	com	r25
    2e1e:	80 95       	com	r24
    2e20:	70 95       	com	r23
    2e22:	61 95       	neg	r22
    2e24:	7f 4f       	sbci	r23, 0xFF	; 255
    2e26:	8f 4f       	sbci	r24, 0xFF	; 255
    2e28:	9f 4f       	sbci	r25, 0xFF	; 255
    2e2a:	08 95       	ret

00002e2c <_exit>:
    2e2c:	f8 94       	cli

00002e2e <__stop_program>:
    2e2e:	ff cf       	rjmp	.-2      	; 0x2e2e <__stop_program>
