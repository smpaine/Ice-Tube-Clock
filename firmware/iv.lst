   1               		.file	"iv.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 100               	.global	delayms
 102               	delayms:
 103               		.stabd	46,0,0
   0:iv.c          **** /***************************************************************************
   1:iv.c          ****  Ice Tube Clock firmware August 13, 2009
   2:iv.c          ****  (c) 2009 Limor Fried / Adafruit Industries
   3:iv.c          ****  Modifications by Len Popp
   4:iv.c          ****  Original auto-dimmer mod by Dave Parker
   5:iv.c          ****  Button interrupt fix by caitsith2
   6:iv.c          ****  Ice Tube Clock with GPS firmware July 22, 2010
   7:iv.c          ****  (c) 2010 Limor Fried / Adafruit Industries
   8:iv.c          ****  GPS Capability added by Devlin Thyne
   9:iv.c          **** 
  10:iv.c          **** Permission is hereby granted, free of charge, to any person obtaining a copy
  11:iv.c          **** of this software and associated documentation files (the "Software"), to deal
  12:iv.c          **** in the Software without restriction, including without limitation the rights
  13:iv.c          **** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  14:iv.c          **** copies of the Software, and to permit persons to whom the Software is
  15:iv.c          **** furnished to do so, subject to the following conditions:
  16:iv.c          **** 
  17:iv.c          **** The above copyright notice and this permission notice shall be included in
  18:iv.c          **** all copies or substantial portions of the Software.
  19:iv.c          **** 
  20:iv.c          **** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  21:iv.c          **** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  22:iv.c          **** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  23:iv.c          **** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  24:iv.c          **** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  25:iv.c          **** OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  26:iv.c          **** THE SOFTWARE.
  27:iv.c          **** ****************************************************************************/
  28:iv.c          **** 
  29:iv.c          **** #include <avr/io.h>      
  30:iv.c          **** #include <string.h>
  31:iv.c          **** #include <avr/interrupt.h>   // Interrupts and timers
  32:iv.c          **** #include <util/delay.h>      // Blocking delay functions
  33:iv.c          **** #include <avr/pgmspace.h>    // So we can store the 'font table' in ROM
  34:iv.c          **** #include <avr/eeprom.h>      // Date/time/pref backup in permanent EEPROM
  35:iv.c          **** #include <avr/wdt.h>     // Watchdog timer to repair lockups
  36:iv.c          **** #include <stdlib.h>
  37:iv.c          **** 
  38:iv.c          **** #include "iv.h"
  39:iv.c          **** #include "util.h"
  40:iv.c          **** #include "fonttable.h"
  41:iv.c          **** 
  42:iv.c          **** uint8_t region = REGION_US;
  43:iv.c          **** 
  44:iv.c          **** // These variables store the current time.
  45:iv.c          **** volatile int8_t time_s, time_m, time_h;
  46:iv.c          **** // ... and current date
  47:iv.c          **** volatile int8_t date_m, date_d, date_y;
  48:iv.c          **** 
  49:iv.c          **** // how loud is the speaker supposed to be?
  50:iv.c          **** volatile uint8_t volume;
  51:iv.c          **** 
  52:iv.c          **** // brightness set by user - 0 means the auto dimmer is turned on 
  53:iv.c          **** volatile uint8_t brightness_level;
  54:iv.c          **** 
  55:iv.c          **** // whether the alarm is on, going off, and alarm time
  56:iv.c          **** volatile uint8_t alarm_on, alarming, alarm_h, alarm_m;
  57:iv.c          **** 
  58:iv.c          **** // what is being displayed on the screen? (eg time, date, menu...)
  59:iv.c          **** volatile uint8_t displaymode;
  60:iv.c          **** 
  61:iv.c          **** // are we in low power sleep mode?
  62:iv.c          **** volatile uint8_t sleepmode = 0;
  63:iv.c          **** 
  64:iv.c          **** volatile uint8_t timeunknown = 0;        // MEME
  65:iv.c          **** volatile uint8_t restored = 0;
  66:iv.c          **** 
  67:iv.c          **** // String buffer for processing GPS data:
  68:iv.c          **** char strBuffer[BUFFERSIZE];
  69:iv.c          **** uint8_t intBufferStatus = 0;
  70:iv.c          **** 
  71:iv.c          **** // Variables for the timezone offset if using GPS.
  72:iv.c          **** int8_t intTimeZoneHour = -6;  //Because Colorado is my time zone...
  73:iv.c          **** uint8_t intTimeZoneMin = 0;
  74:iv.c          **** 
  75:iv.c          **** 
  76:iv.c          **** // Our display buffer, which is updated to show the time/date/etc
  77:iv.c          **** // and is multiplexed onto the tube
  78:iv.c          **** uint8_t display[DISPLAYSIZE]; // stores segments, not values!
  79:iv.c          **** uint8_t currdigit = 0;        // which digit we are currently multiplexing
  80:iv.c          **** 
  81:iv.c          **** // This table allow us to index between what digit we want to light up
  82:iv.c          **** // and what the pin number is on the MAX6921 see the .h for values.
  83:iv.c          **** // Stored in ROM (PROGMEM) to save RAM
  84:iv.c          **** const uint8_t digittable[] PROGMEM = {
  85:iv.c          ****   DIG_9, DIG_8, DIG_7, DIG_6, DIG_5, DIG_4, DIG_3, DIG_2, DIG_1
  86:iv.c          **** };
  87:iv.c          **** PGM_P digittable_p PROGMEM = digittable;
  88:iv.c          **** 
  89:iv.c          **** // This table allow us to index between what segment we want to light up
  90:iv.c          **** // and what the pin number is on the MAX6921 see the .h for values.
  91:iv.c          **** // Stored in ROM (PROGMEM) to save RAM
  92:iv.c          **** const uint8_t segmenttable[] PROGMEM = {
  93:iv.c          ****   SEG_H, SEG_G,  SEG_F,  SEG_E,  SEG_D,  SEG_C,  SEG_B,  SEG_A 
  94:iv.c          **** };
  95:iv.c          **** PGM_P segmenttable_p PROGMEM = segmenttable;
  96:iv.c          **** 
  97:iv.c          **** // muxdiv and MUX_DIVIDER divides down a high speed interrupt (31.25KHz)
  98:iv.c          **** // down so that we can refresh at about 100Hz (31.25KHz / 300)
  99:iv.c          **** // We refresh the entire display at 100Hz so each digit is updated
 100:iv.c          **** // 100Hz/DISPLAYSIZE
 101:iv.c          **** uint16_t muxdiv = 0;
 102:iv.c          **** #define MUX_DIVIDER (300 / DISPLAYSIZE)
 103:iv.c          **** 
 104:iv.c          **** // Likewise divides 100Hz down to 1Hz for the alarm beeping
 105:iv.c          **** uint16_t alarmdiv = 0;
 106:iv.c          **** #define ALARM_DIVIDER 100
 107:iv.c          **** 
 108:iv.c          **** // How long we have been snoozing
 109:iv.c          **** uint16_t snoozetimer = 0;
 110:iv.c          **** 
 111:iv.c          **** // We have a non-blocking delay function, milliseconds is updated by
 112:iv.c          **** // an interrupt
 113:iv.c          **** volatile uint16_t milliseconds = 0;
 114:iv.c          **** void delayms(uint16_t ms) {
 105               	.LM0:
 106               	.LFBB1:
 107               	/* prologue: function */
 108               	/* frame size = 0 */
 109 0000 9C01      		movw r18,r24
 115:iv.c          ****   sei();
 111               	.LM1:
 112               	/* #APP */
 113               	 ;  116 "iv.c" 1
 114 0002 7894      		sei
 115               	 ;  0 "" 2
 116:iv.c          **** 
 117:iv.c          ****   milliseconds = 0;
 117               	.LM2:
 118               	/* #NOAPP */
 119 0004 1092 0000 		sts (milliseconds)+1,__zero_reg__
 120 0008 1092 0000 		sts milliseconds,__zero_reg__
 121               	.L2:
 118:iv.c          ****   while (milliseconds < ms);
 123               	.LM3:
 124 000c 8091 0000 		lds r24,milliseconds
 125 0010 9091 0000 		lds r25,(milliseconds)+1
 126 0014 8217      		cp r24,r18
 127 0016 9307      		cpc r25,r19
 128 0018 00F0      		brlo .L2
 129               	/* epilogue start */
 119:iv.c          **** }
 131               	.LM4:
 132 001a 0895      		ret
 134               	.Lscope1:
 136               		.stabd	78,0,0
 138               	.global	kickthedog
 140               	kickthedog:
 141               		.stabd	46,0,0
 120:iv.c          **** 
 121:iv.c          **** // When the alarm is going off, pressing a button turns on snooze mode
 122:iv.c          **** // this sets the snoozetimer off in MAXSNOOZE seconds - which turns on
 123:iv.c          **** // the alarm again
 124:iv.c          **** void setsnooze(void) {
 125:iv.c          ****   //snoozetimer = eeprom_read_byte((uint8_t *)EE_SNOOZE);
 126:iv.c          ****   //snoozetimer *= 60; // convert minutes to seconds
 127:iv.c          ****   snoozetimer = MAXSNOOZE;
 128:iv.c          ****   DEBUGP("snooze");
 129:iv.c          ****   display_str("snoozing");
 130:iv.c          ****   displaymode = SHOW_SNOOZE;
 131:iv.c          ****   delayms(1000);
 132:iv.c          ****   displaymode = SHOW_TIME;
 133:iv.c          **** }
 134:iv.c          **** 
 135:iv.c          **** // we reset the watchdog timer 
 136:iv.c          **** void kickthedog(void) {
 143               	.LM5:
 144               	.LFBB2:
 145               	/* prologue: function */
 146               	/* frame size = 0 */
 137:iv.c          ****   wdt_reset();
 148               	.LM6:
 149               	/* #APP */
 150               	 ;  138 "iv.c" 1
 151 001c A895      		wdr
 152               	 ;  0 "" 2
 153               	/* epilogue start */
 138:iv.c          **** }
 155               	.LM7:
 156               	/* #NOAPP */
 157 001e 0895      		ret
 159               	.Lscope2:
 161               		.stabd	78,0,0
 163               	.global	gotosleep
 165               	gotosleep:
 166               		.stabd	46,0,0
 139:iv.c          **** 
 140:iv.c          **** // called @ (F_CPU/256) = ~30khz (31.25 khz)
 141:iv.c          **** SIGNAL (SIG_OVERFLOW0) {
 142:iv.c          ****   // allow other interrupts to go off while we're doing display updates
 143:iv.c          ****   sei();
 144:iv.c          **** 
 145:iv.c          ****   // kick the dog
 146:iv.c          ****   kickthedog();
 147:iv.c          **** 
 148:iv.c          ****   // divide down to 100Hz * digits
 149:iv.c          ****   muxdiv++;
 150:iv.c          ****   if (muxdiv < MUX_DIVIDER)
 151:iv.c          ****     return;
 152:iv.c          ****   muxdiv = 0;
 153:iv.c          ****   // now at 100Hz * digits
 154:iv.c          **** 
 155:iv.c          ****   // ok its not really 1ms but its like within 10% :)
 156:iv.c          ****   milliseconds++;
 157:iv.c          **** 
 158:iv.c          ****   // Cycle through each digit in the display
 159:iv.c          ****   if (currdigit >= DISPLAYSIZE)
 160:iv.c          ****     currdigit = 0;
 161:iv.c          **** 
 162:iv.c          ****   // Set the current display's segments
 163:iv.c          ****   setdisplay(currdigit, display[currdigit]);
 164:iv.c          ****   // and go to the next
 165:iv.c          ****   currdigit++;
 166:iv.c          **** 
 167:iv.c          ****   // check if we should have the alarm on
 168:iv.c          ****   if (alarming && !snoozetimer) {
 169:iv.c          ****     alarmdiv++;
 170:iv.c          ****     if (alarmdiv > ALARM_DIVIDER) {
 171:iv.c          ****       alarmdiv = 0;
 172:iv.c          ****     } else {
 173:iv.c          ****       return;
 174:iv.c          ****     }
 175:iv.c          ****     // This part only gets reached at 1Hz
 176:iv.c          **** 
 177:iv.c          ****     // This sets the buzzer frequency
 178:iv.c          ****     ICR1 = 250;
 179:iv.c          ****     OCR1A = OCR1B = ICR1/2;
 180:iv.c          **** 
 181:iv.c          ****     // ok alarm is ringing!
 182:iv.c          ****     if (alarming & 0xF0) { // top bit indicates pulsing alarm state
 183:iv.c          ****       alarming &= ~0xF0;
 184:iv.c          ****       TCCR1B &= ~_BV(CS11); // turn buzzer off!
 185:iv.c          ****     } else {
 186:iv.c          ****       alarming |= 0xF0;
 187:iv.c          ****       TCCR1B |= _BV(CS11); // turn buzzer on!
 188:iv.c          ****     }
 189:iv.c          ****   }
 190:iv.c          ****   
 191:iv.c          **** }
 192:iv.c          **** 
 193:iv.c          **** 
 194:iv.c          **** // We use the pin change interrupts to detect when buttons are pressed
 195:iv.c          **** 
 196:iv.c          **** // These store the current button states for all 3 buttons. We can 
 197:iv.c          **** // then query whether the buttons are pressed and released or pressed
 198:iv.c          **** // This allows for 'high speed incrementing' when setting the time
 199:iv.c          **** volatile uint8_t last_buttonstate = 0, just_pressed = 0, pressed = 0;
 200:iv.c          **** volatile uint8_t buttonholdcounter = 0;
 201:iv.c          **** 
 202:iv.c          **** // This interrupt detects switches 1 and 3
 203:iv.c          **** SIGNAL(SIG_PIN_CHANGE2) {
 204:iv.c          ****   // allow interrupts while we're doing this
 205:iv.c          ****   PCMSK2 = 0;
 206:iv.c          ****   sei();
 207:iv.c          ****   // kick the dog
 208:iv.c          ****   kickthedog();
 209:iv.c          **** 
 210:iv.c          ****   if (! (PIND & _BV(BUTTON1))) {
 211:iv.c          ****     // button1 is pressed
 212:iv.c          ****     if (! (last_buttonstate & 0x1)) { // was not pressed before
 213:iv.c          ****       delayms(10);                    // debounce
 214:iv.c          ****       if (PIND & _BV(BUTTON1))        // filter out bounces
 215:iv.c          ****       {
 216:iv.c          ****         PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
 217:iv.c          ****          return;
 218:iv.c          ****       }
 219:iv.c          ****       tick();                         // make a noise
 220:iv.c          ****       // check if we will snag this button press for snoozing
 221:iv.c          ****       if (alarming) {
 222:iv.c          **** 	// turn on snooze
 223:iv.c          **** 	setsnooze();
 224:iv.c          **** 	PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
 225:iv.c          **** 	return;
 226:iv.c          ****       }
 227:iv.c          ****       last_buttonstate |= 0x1;
 228:iv.c          ****       just_pressed |= 0x1;
 229:iv.c          ****       DEBUGP("b1");
 230:iv.c          ****     }
 231:iv.c          ****   } else {
 232:iv.c          ****     last_buttonstate &= ~0x1;
 233:iv.c          ****   }
 234:iv.c          **** 
 235:iv.c          ****   if (! (PIND & _BV(BUTTON3))) {
 236:iv.c          ****     // button3 is pressed
 237:iv.c          ****     if (! (last_buttonstate & 0x4)) { // was not pressed before
 238:iv.c          ****       delayms(10);                    // debounce
 239:iv.c          ****       if (PIND & _BV(BUTTON3))        // filter out bounces
 240:iv.c          ****       {
 241:iv.c          ****         PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
 242:iv.c          **** 	return;
 243:iv.c          ****       }
 244:iv.c          ****       buttonholdcounter = 2;          // see if we're press-and-holding
 245:iv.c          ****       while (buttonholdcounter) {
 246:iv.c          **** 	if (PIND & _BV(BUTTON3)) {        // released
 247:iv.c          **** 	  tick();                         // make a noise
 248:iv.c          **** 	  last_buttonstate &= ~0x4;
 249:iv.c          **** 	  // check if we will snag this button press for snoozing
 250:iv.c          **** 	  if (alarming) {
 251:iv.c          **** 	    // turn on snooze
 252:iv.c          **** 	    setsnooze();
 253:iv.c          **** 	    PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
 254:iv.c          **** 	    return;
 255:iv.c          **** 	  }
 256:iv.c          **** 	  DEBUGP("b3");
 257:iv.c          **** 	  just_pressed |= 0x4;
 258:iv.c          **** 	  PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
 259:iv.c          **** 	  return;
 260:iv.c          **** 	}
 261:iv.c          ****       }
 262:iv.c          ****       last_buttonstate |= 0x4;
 263:iv.c          ****       pressed |= 0x4;                 // held down
 264:iv.c          ****     }
 265:iv.c          ****   } else {
 266:iv.c          ****     pressed = 0;                      // button released
 267:iv.c          ****     last_buttonstate &= ~0x4;
 268:iv.c          ****   }
 269:iv.c          ****   PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
 270:iv.c          **** }
 271:iv.c          **** 
 272:iv.c          **** // Just button #2
 273:iv.c          **** SIGNAL(SIG_PIN_CHANGE0) {
 274:iv.c          ****   PCMSK0 = 0;
 275:iv.c          ****   sei();
 276:iv.c          ****   if (! (PINB & _BV(BUTTON2))) {
 277:iv.c          ****     // button2 is pressed
 278:iv.c          ****     if (! (last_buttonstate & 0x2)) { // was not pressed before
 279:iv.c          ****       delayms(10);                    // debounce
 280:iv.c          ****       if (PINB & _BV(BUTTON2))        // filter out bounces
 281:iv.c          ****       {
 282:iv.c          ****         PCMSK0 = _BV(PCINT0);
 283:iv.c          **** 	return;
 284:iv.c          ****       }
 285:iv.c          ****       tick();                         // make a noise
 286:iv.c          ****       // check if we will snag this button press for snoozing
 287:iv.c          ****       if (alarming) {
 288:iv.c          **** 	setsnooze(); 	// turn on snooze
 289:iv.c          **** 	PCMSK0 = _BV(PCINT0);
 290:iv.c          **** 	return;
 291:iv.c          ****       }
 292:iv.c          ****       last_buttonstate |= 0x2;
 293:iv.c          ****       just_pressed |= 0x2;
 294:iv.c          ****       DEBUGP("b2");
 295:iv.c          ****     }
 296:iv.c          ****   } else {
 297:iv.c          ****     last_buttonstate &= ~0x2;
 298:iv.c          ****   }
 299:iv.c          ****   PCMSK0 = _BV(PCINT0);
 300:iv.c          **** }
 301:iv.c          **** 
 302:iv.c          **** // This variable keeps track of whether we have not pressed any
 303:iv.c          **** // buttons in a few seconds, and turns off the menu display
 304:iv.c          **** volatile uint8_t timeoutcounter = 0;
 305:iv.c          **** 
 306:iv.c          **** // this goes off once a second
 307:iv.c          **** SIGNAL (TIMER2_OVF_vect) {
 308:iv.c          ****   CLKPR = _BV(CLKPCE);  //MEME
 309:iv.c          ****   CLKPR = 0;
 310:iv.c          **** 
 311:iv.c          ****   time_s++;             // one second has gone by
 312:iv.c          **** 
 313:iv.c          ****   fix_time();
 314:iv.c          **** 
 315:iv.c          ****   // If we're in low power mode we should get out now since the display is off
 316:iv.c          ****   if (sleepmode)
 317:iv.c          ****     return;
 318:iv.c          ****    
 319:iv.c          **** 
 320:iv.c          ****   if (displaymode == SHOW_TIME) {
 321:iv.c          ****     if (timeunknown && (time_s % 2)) {
 322:iv.c          ****       display_str("        ");
 323:iv.c          ****     } else {
 324:iv.c          ****       display_time(time_h, time_m, time_s);
 325:iv.c          ****     }
 326:iv.c          ****     if (alarm_on)
 327:iv.c          ****       display[0] |= 0x2;
 328:iv.c          ****     else 
 329:iv.c          ****       display[0] &= ~0x2;
 330:iv.c          ****     
 331:iv.c          ****   }
 332:iv.c          **** 
 333:iv.c          **** #ifdef FEATURE_AUTODIM
 334:iv.c          ****   dimmer_update();
 335:iv.c          **** #endif
 336:iv.c          ****   check_alarm(time_h, time_m, time_s);
 337:iv.c          **** 
 338:iv.c          ****   if (timeoutcounter)
 339:iv.c          ****     timeoutcounter--;
 340:iv.c          ****   if (buttonholdcounter)
 341:iv.c          ****     buttonholdcounter--;
 342:iv.c          ****   if (snoozetimer) {
 343:iv.c          ****     snoozetimer--;
 344:iv.c          ****     if (snoozetimer % 2) 
 345:iv.c          ****       display[0] |= 0x2;
 346:iv.c          ****     else
 347:iv.c          ****       display[0] &= ~0x2;
 348:iv.c          ****   }
 349:iv.c          **** }
 350:iv.c          **** 
 351:iv.c          **** SIGNAL(SIG_INTERRUPT0) {
 352:iv.c          ****   EIMSK = 0;  //Disable this interrupt while we are processing it.
 353:iv.c          ****   uart_putchar('i');
 354:iv.c          ****   uint8_t x = ALARM_PIN & _BV(ALARM);
 355:iv.c          ****   sei();
 356:iv.c          ****   delayms(10); // wait for debouncing
 357:iv.c          ****   if (x != (ALARM_PIN & _BV(ALARM)))
 358:iv.c          ****   {
 359:iv.c          ****     EIMSK = _BV(INT0);
 360:iv.c          ****     return;
 361:iv.c          ****   }
 362:iv.c          ****   setalarmstate();
 363:iv.c          ****   EIMSK = _BV(INT0);  //And reenable it before exiting.
 364:iv.c          **** }
 365:iv.c          **** 
 366:iv.c          **** 
 367:iv.c          **** 
 368:iv.c          **** SIGNAL(SIG_COMPARATOR) {
 369:iv.c          ****   //DEBUGP("COMP");
 370:iv.c          ****   if (ACSR & _BV(ACO)) {
 371:iv.c          ****     //DEBUGP("HIGH");
 372:iv.c          ****     if (!sleepmode) {
 373:iv.c          ****       VFDSWITCH_PORT |= _BV(VFDSWITCH); // turn off display
 374:iv.c          ****       VFDCLK_PORT &= ~_BV(VFDCLK) & ~_BV(VFDDATA); // no power to vfdchip
 375:iv.c          ****       BOOST_PORT &= ~_BV(BOOST); // pull boost fet low
 376:iv.c          ****       SPCR  &= ~_BV(SPE); // turn off spi
 377:iv.c          ****       if (restored) {
 378:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_MIN, time_m);
 379:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_SEC, time_s);
 380:iv.c          ****       }
 381:iv.c          ****       DEBUGP("z");
 382:iv.c          ****       TCCR0B = 0; // no boost
 383:iv.c          ****       volume = 0; // low power buzzer
 384:iv.c          ****       PCICR = 0;  // ignore buttons
 385:iv.c          **** #ifdef FEATURE_AUTODIM
 386:iv.c          ****       DIMMER_POWER_PORT &= ~_BV(DIMMER_POWER_PIN); // no power to photoresistor
 387:iv.c          **** #endif
 388:iv.c          **** 
 389:iv.c          ****       app_start();
 390:iv.c          ****     }
 391:iv.c          ****   } else {
 392:iv.c          ****     //DEBUGP("LOW");
 393:iv.c          ****     if (sleepmode) {
 394:iv.c          ****       if (restored) {
 395:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_MIN, time_m);
 396:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_SEC, time_s);
 397:iv.c          ****       }
 398:iv.c          ****       DEBUGP("WAKERESET"); 
 399:iv.c          ****       app_start();
 400:iv.c          ****     }
 401:iv.c          ****   }
 402:iv.c          **** }
 403:iv.c          **** 
 404:iv.c          **** 
 405:iv.c          **** /*********************** Main app **********/
 406:iv.c          **** 
 407:iv.c          **** uint32_t t;
 408:iv.c          **** 
 409:iv.c          **** void gotosleep(void) {
 168               	.LM8:
 169               	.LFBB3:
 170               	/* prologue: function */
 171               	/* frame size = 0 */
 410:iv.c          ****   // battery
 411:iv.c          ****   //if (sleepmode) //already asleep?
 412:iv.c          ****   //  return;
 413:iv.c          ****   //DEBUGP("sleeptime");
 414:iv.c          ****   
 415:iv.c          ****   sleepmode = 1;
 173               	.LM9:
 174 0020 81E0      		ldi r24,lo8(1)
 175 0022 8093 0000 		sts sleepmode,r24
 416:iv.c          ****   VFDSWITCH_PORT |= _BV(VFDSWITCH); // turn off display
 177               	.LM10:
 178 0026 5B9A      		sbi 43-32,3
 417:iv.c          ****   SPCR  &= ~_BV(SPE); // turn off spi
 180               	.LM11:
 181 0028 8CB5      		in r24,76-32
 182 002a 8F7B      		andi r24,lo8(-65)
 183 002c 8CBD      		out 76-32,r24
 418:iv.c          ****   VFDCLK_PORT &= ~_BV(VFDCLK) & ~_BV(VFDDATA); // no power to vfdchip
 185               	.LM12:
 186 002e 85B1      		in r24,37-32
 187 0030 877D      		andi r24,lo8(-41)
 188 0032 85B9      		out 37-32,r24
 419:iv.c          ****   BOOST_PORT &= ~_BV(BOOST); // pull boost fet low
 190               	.LM13:
 191 0034 5E98      		cbi 43-32,6
 420:iv.c          ****   TCCR0B = 0; // no boost
 193               	.LM14:
 194 0036 15BC      		out 69-32,__zero_reg__
 421:iv.c          ****   volume = 0; // low power buzzer
 196               	.LM15:
 197 0038 1092 0000 		sts volume,__zero_reg__
 422:iv.c          ****   PCICR = 0;  // ignore buttons
 199               	.LM16:
 200 003c 1092 6800 		sts 104,__zero_reg__
 423:iv.c          **** #ifdef FEATURE_AUTODIM
 424:iv.c          ****   DIMMER_POWER_PORT &= ~_BV(DIMMER_POWER_PIN); // no power to photoresistor
 202               	.LM17:
 203 0040 4598      		cbi 40-32,5
 425:iv.c          **** #endif
 426:iv.c          **** 
 427:iv.c          ****   // sleep time!
 428:iv.c          ****   //beep(3520, 1);
 429:iv.c          ****   //beep(1760, 1);
 430:iv.c          ****   //beep(880, 1);
 431:iv.c          ****   // turn beeper off
 432:iv.c          ****   PORTB &= ~_BV(SPK1) & ~_BV(SPK2); 
 205               	.LM18:
 206 0042 85B1      		in r24,37-32
 207 0044 897F      		andi r24,lo8(-7)
 208 0046 85B9      		out 37-32,r24
 433:iv.c          ****   
 434:iv.c          ****   // turn off pullups
 435:iv.c          ****   PORTD &= ~_BV(BUTTON1) & ~_BV(BUTTON3);
 210               	.LM19:
 211 0048 8BB1      		in r24,43-32
 212 004a 8F7C      		andi r24,lo8(-49)
 213 004c 8BB9      		out 43-32,r24
 436:iv.c          ****   PORTB &= ~_BV(BUTTON2);
 215               	.LM20:
 216 004e 2898      		cbi 37-32,0
 437:iv.c          ****   DDRD &= ~_BV(BUTTON1) & ~_BV(BUTTON3);
 218               	.LM21:
 219 0050 8AB1      		in r24,42-32
 220 0052 8F7C      		andi r24,lo8(-49)
 221 0054 8AB9      		out 42-32,r24
 438:iv.c          ****   DDRB &= ~_BV(BUTTON2);
 223               	.LM22:
 224 0056 2098      		cbi 36-32,0
 439:iv.c          ****   ALARM_PORT &= ~_BV(ALARM);
 226               	.LM23:
 227 0058 5A98      		cbi 43-32,2
 440:iv.c          ****   ALARM_DDR &= ~_BV(ALARM);
 229               	.LM24:
 230 005a 5298      		cbi 42-32,2
 441:iv.c          ****   
 442:iv.c          **** 
 443:iv.c          ****   // reduce the clock speed
 444:iv.c          ****   CLKPR = _BV(CLKPCE);
 232               	.LM25:
 233 005c E1E6      		ldi r30,lo8(97)
 234 005e F0E0      		ldi r31,hi8(97)
 235 0060 90E8      		ldi r25,lo8(-128)
 236 0062 9083      		st Z,r25
 445:iv.c          ****   CLKPR = _BV(CLKPS3);
 238               	.LM26:
 239 0064 88E0      		ldi r24,lo8(8)
 240 0066 8083      		st Z,r24
 446:iv.c          ****   
 447:iv.c          ****   //  PPR |= _BV(PRUSART0) | _BV(PRADC) | _BV(PRSPI) | _BV(PRTIM1) | _BV(PRTIM0) | _BV(PRTWI);
 448:iv.c          ****   PORTC |= _BV(4);  // sleep signal
 242               	.LM27:
 243 0068 449A      		sbi 40-32,4
 449:iv.c          ****   SMCR |= _BV(SM1) | _BV(SM0) | _BV(SE); // sleep mode
 245               	.LM28:
 246 006a 83B7      		in r24,83-32
 247 006c 8760      		ori r24,lo8(7)
 248 006e 83BF      		out 83-32,r24
 450:iv.c          ****   asm("sleep"); 
 250               	.LM29:
 251               	/* #APP */
 252               	 ;  451 "iv.c" 1
 253 0070 8895      		sleep
 254               	 ;  0 "" 2
 451:iv.c          ****   CLKPR = _BV(CLKPCE);
 256               	.LM30:
 257               	/* #NOAPP */
 258 0072 9083      		st Z,r25
 452:iv.c          ****   CLKPR = 0;
 260               	.LM31:
 261 0074 1082      		st Z,__zero_reg__
 453:iv.c          ****   PORTC &= ~_BV(4);
 263               	.LM32:
 264 0076 4498      		cbi 40-32,4
 265               	/* epilogue start */
 454:iv.c          **** }
 267               	.LM33:
 268 0078 0895      		ret
 270               	.Lscope3:
 272               		.stabd	78,0,0
 274               	.global	initbuttons
 276               	initbuttons:
 277               		.stabd	46,0,0
 455:iv.c          **** 
 456:iv.c          ****  void wakeup(void) {
 457:iv.c          ****    if (!sleepmode)
 458:iv.c          ****      return;
 459:iv.c          ****    CLKPR = _BV(CLKPCE);
 460:iv.c          ****    CLKPR = 0;
 461:iv.c          ****    DEBUGP("waketime");
 462:iv.c          ****    sleepmode = 0;
 463:iv.c          ****    // plugged in
 464:iv.c          ****    // wait to verify
 465:iv.c          ****    _delay_ms(20);
 466:iv.c          ****    if (ACSR & _BV(ACO)) 
 467:iv.c          ****      return;
 468:iv.c          ****    
 469:iv.c          ****    // turn on pullups
 470:iv.c          ****    initbuttons();
 471:iv.c          **** 
 472:iv.c          **** #ifdef FEATURE_AUTODIM
 473:iv.c          ****    dimmer_init();
 474:iv.c          **** #endif
 475:iv.c          **** 
 476:iv.c          ****    // turn on boost
 477:iv.c          ****    brightness_level = eeprom_read_byte((uint8_t *)EE_BRIGHT);
 478:iv.c          ****    boost_init(brightness_level);
 479:iv.c          **** 
 480:iv.c          ****    // turn on vfd control
 481:iv.c          ****    vfd_init();
 482:iv.c          **** 
 483:iv.c          ****    // turn on display
 484:iv.c          ****    VFDSWITCH_PORT &= ~_BV(VFDSWITCH); 
 485:iv.c          ****    VFDBLANK_PORT &= ~_BV(VFDBLANK);
 486:iv.c          ****    volume = eeprom_read_byte((uint8_t *)EE_VOLUME); // reset
 487:iv.c          ****    
 488:iv.c          ****    speaker_init();
 489:iv.c          **** 
 490:iv.c          ****    kickthedog();
 491:iv.c          **** 
 492:iv.c          ****    setalarmstate();
 493:iv.c          **** 
 494:iv.c          ****    // wake up sound
 495:iv.c          ****    beep(880, 1);
 496:iv.c          ****    beep(1760, 1);
 497:iv.c          ****    beep(3520, 1);
 498:iv.c          **** 
 499:iv.c          ****    kickthedog();
 500:iv.c          ****  }
 501:iv.c          **** 
 502:iv.c          **** 
 503:iv.c          **** void initbuttons(void) {
 279               	.LM34:
 280               	.LFBB4:
 281               	/* prologue: function */
 282               	/* frame size = 0 */
 504:iv.c          ****     DDRB =  _BV(VFDCLK) | _BV(VFDDATA) | _BV(SPK1) | _BV(SPK2);
 284               	.LM35:
 285 007a 8EE2      		ldi r24,lo8(46)
 286 007c 84B9      		out 36-32,r24
 505:iv.c          ****     DDRD = _BV(BOOST) | _BV(VFDSWITCH);
 288               	.LM36:
 289 007e 88E4      		ldi r24,lo8(72)
 290 0080 8AB9      		out 42-32,r24
 506:iv.c          ****     DDRC = _BV(VFDLOAD) | _BV(VFDBLANK);
 292               	.LM37:
 293 0082 89E0      		ldi r24,lo8(9)
 294 0084 87B9      		out 39-32,r24
 507:iv.c          ****     PORTD = _BV(BUTTON1) | _BV(BUTTON3) | _BV(ALARM);
 296               	.LM38:
 297 0086 84E3      		ldi r24,lo8(52)
 298 0088 8BB9      		out 43-32,r24
 508:iv.c          ****     PORTB = _BV(BUTTON2);
 300               	.LM39:
 301 008a 91E0      		ldi r25,lo8(1)
 302 008c 95B9      		out 37-32,r25
 509:iv.c          **** 
 510:iv.c          ****     PCICR = _BV(PCIE0) | _BV(PCIE2);
 304               	.LM40:
 305 008e 85E0      		ldi r24,lo8(5)
 306 0090 8093 6800 		sts 104,r24
 511:iv.c          ****     PCMSK0 = _BV(PCINT0);
 308               	.LM41:
 309 0094 9093 6B00 		sts 107,r25
 512:iv.c          ****     PCMSK2 = _BV(PCINT21) | _BV(PCINT20);    
 311               	.LM42:
 312 0098 80E3      		ldi r24,lo8(48)
 313 009a 8093 6D00 		sts 109,r24
 314               	/* epilogue start */
 513:iv.c          **** }
 316               	.LM43:
 317 009e 0895      		ret
 319               	.Lscope4:
 321               		.stabd	78,0,0
 324               	.global	leapyear
 326               	leapyear:
 327               		.stabd	46,0,0
 514:iv.c          **** 
 515:iv.c          **** 
 516:iv.c          **** 
 517:iv.c          **** int main(void) {
 518:iv.c          ****   //  uint8_t i;
 519:iv.c          ****   uint8_t mcustate;
 520:iv.c          **** 
 521:iv.c          ****   // turn boost off
 522:iv.c          ****   TCCR0B = 0;
 523:iv.c          ****   BOOST_DDR |= _BV(BOOST);
 524:iv.c          ****   BOOST_PORT &= ~_BV(BOOST); // pull boost fet low
 525:iv.c          **** 
 526:iv.c          ****   // check if we were reset
 527:iv.c          ****   mcustate = MCUSR;
 528:iv.c          ****   MCUSR = 0;
 529:iv.c          **** 
 530:iv.c          ****   uart_putw_hex(mcustate);
 531:iv.c          **** 
 532:iv.c          ****   wdt_disable();
 533:iv.c          ****   // now turn it back on... 2 second time out
 534:iv.c          ****   //WDTCSR |= _BV(WDP0) | _BV(WDP1) | _BV(WDP2);
 535:iv.c          ****   //WDTCSR = _BV(WDE);
 536:iv.c          ****   wdt_enable(WDTO_2S);
 537:iv.c          ****   kickthedog();
 538:iv.c          **** 
 539:iv.c          ****   // we lost power at some point so lets alert the user
 540:iv.c          ****   // that the time may be wrong (the clock still works)
 541:iv.c          ****   timeunknown = 1;
 542:iv.c          **** 
 543:iv.c          ****   // have we read the time & date from eeprom?
 544:iv.c          ****   restored = 0;
 545:iv.c          **** 
 546:iv.c          ****   // setup uart
 547:iv.c          ****   uart_init(BRRL_4800);
 548:iv.c          **** 
 549:iv.c          ****   //DEBUGP("VFD Clock");
 550:iv.c          ****   DEBUGP("!");
 551:iv.c          ****   uart_puts("\n\rHello World!\n\r");
 552:iv.c          ****   uart_puts("\n\rBuffer size is:\t");
 553:iv.c          ****   uart_putw_dec(BUFFERSIZE);
 554:iv.c          ****   uart_puts("\n\r");
 555:iv.c          **** 
 556:iv.c          ****   //DEBUGP("turning on anacomp");
 557:iv.c          ****   // set up analog comparator
 558:iv.c          ****   ACSR = _BV(ACBG) | _BV(ACIE); // use bandgap, intr. on toggle!
 559:iv.c          ****   _delay_ms(1);
 560:iv.c          ****   // settle!
 561:iv.c          ****   if (ACSR & _BV(ACO)) {
 562:iv.c          ****     // hmm we should not interrupt here
 563:iv.c          ****     ACSR |= _BV(ACI);
 564:iv.c          **** 
 565:iv.c          ****     // even in low power mode, we run the clock 
 566:iv.c          ****     DEBUGP("clock init");
 567:iv.c          ****     clock_init();  
 568:iv.c          **** 
 569:iv.c          ****   } else {
 570:iv.c          ****     // we aren't in low power mode so init stuff
 571:iv.c          **** 
 572:iv.c          ****     // init IOs
 573:iv.c          ****     initbuttons();
 574:iv.c          ****     
 575:iv.c          ****     VFDSWITCH_PORT &= ~_BV(VFDSWITCH);
 576:iv.c          ****     
 577:iv.c          ****     DEBUGP("turning on buttons");
 578:iv.c          ****     // set up button interrupts
 579:iv.c          ****     DEBUGP("turning on alarmsw");
 580:iv.c          ****     // set off an interrupt if alarm is set or unset
 581:iv.c          ****     EICRA = _BV(ISC00);
 582:iv.c          ****     EIMSK = _BV(INT0);
 583:iv.c          ****   
 584:iv.c          ****     displaymode = SHOW_TIME;
 585:iv.c          ****     DEBUGP("vfd init");
 586:iv.c          ****     vfd_init();
 587:iv.c          ****    
 588:iv.c          **** #ifdef FEATURE_AUTODIM
 589:iv.c          ****     dimmer_init();
 590:iv.c          **** #endif
 591:iv.c          **** 
 592:iv.c          ****     DEBUGP("boost init");
 593:iv.c          ****     brightness_level = eeprom_read_byte((uint8_t *)EE_BRIGHT);
 594:iv.c          ****     boost_init(brightness_level);
 595:iv.c          ****     sei();
 596:iv.c          **** 
 597:iv.c          ****     //Load and check the timezone information
 598:iv.c          ****     intTimeZoneHour = eeprom_read_byte((uint8_t *)EE_ZONE_HOUR);
 599:iv.c          ****     if ( ( 12 < intTimeZoneHour ) || ( -12 > intTimeZoneHour ) )
 600:iv.c          ****       intTimeZoneHour = 0;
 601:iv.c          **** 
 602:iv.c          ****     intTimeZoneMin = eeprom_read_byte((uint8_t *)EE_ZONE_MIN);
 603:iv.c          ****     if ( ( 60 < intTimeZoneMin ) || ( 0 > intTimeZoneMin ) )
 604:iv.c          ****       intTimeZoneMin = 0;
 605:iv.c          **** 
 606:iv.c          ****     region = eeprom_read_byte((uint8_t *)EE_REGION);
 607:iv.c          ****     
 608:iv.c          ****     DEBUGP("speaker init");
 609:iv.c          ****     speaker_init();
 610:iv.c          **** 
 611:iv.c          ****     beep(4000, 1);
 612:iv.c          **** 
 613:iv.c          ****     DEBUGP("clock init");
 614:iv.c          ****     clock_init();  
 615:iv.c          **** 
 616:iv.c          ****     DEBUGP("alarm init");
 617:iv.c          ****     setalarmstate();
 618:iv.c          ****   }
 619:iv.c          ****   DEBUGP("done");
 620:iv.c          ****   while (1) {
 621:iv.c          ****     //_delay_ms(100);
 622:iv.c          ****     kickthedog();
 623:iv.c          ****     //uart_putc_hex(ACSR);
 624:iv.c          ****     if (ACSR & _BV(ACO)) {
 625:iv.c          ****       // DEBUGP("SLEEPYTIME");
 626:iv.c          ****       gotosleep();
 627:iv.c          ****       continue;
 628:iv.c          ****     }
 629:iv.c          ****     //DEBUGP(".");
 630:iv.c          ****     if (just_pressed & 0x1) {
 631:iv.c          ****       just_pressed = 0;
 632:iv.c          ****       switch(displaymode) {
 633:iv.c          ****       case (SHOW_TIME):
 634:iv.c          **** 	displaymode = SET_ALARM;
 635:iv.c          **** 	display_str("set alarm");
 636:iv.c          **** 	set_alarm();
 637:iv.c          **** 	break;
 638:iv.c          ****       case (SET_ALARM):
 639:iv.c          **** 	displaymode = SET_TIME;
 640:iv.c          **** 	display_str("set time");
 641:iv.c          **** 	set_time();
 642:iv.c          **** 	timeunknown = 0;
 643:iv.c          **** 	break;
 644:iv.c          ****       case (SET_TIME):
 645:iv.c          **** 	displaymode = SET_DATE;
 646:iv.c          **** 	display_str("set date");
 647:iv.c          **** 	set_date();
 648:iv.c          **** 	break;
 649:iv.c          ****       case (SET_DATE):
 650:iv.c          **** 	//displaymode = SET_BRIGHTNESS;
 651:iv.c          **** 	//display_str("set brit");
 652:iv.c          **** 	//set_brightness();
 653:iv.c          ****         displaymode = SET_ZONE;
 654:iv.c          ****         display_str("set zone");
 655:iv.c          ****         set_timezone();
 656:iv.c          **** 	break;
 657:iv.c          ****       case (SET_ZONE):
 658:iv.c          ****         displaymode = SET_BRIGHTNESS;
 659:iv.c          ****         display_str("set brit");
 660:iv.c          ****         set_brightness();
 661:iv.c          ****         break;
 662:iv.c          ****       case (SET_BRIGHTNESS):
 663:iv.c          **** 	displaymode = SET_VOLUME;
 664:iv.c          **** 	display_str("set vol ");
 665:iv.c          **** 	set_volume();
 666:iv.c          **** 	break;
 667:iv.c          ****       case (SET_VOLUME):
 668:iv.c          **** 	displaymode = SET_REGION;
 669:iv.c          **** 	display_str("set regn");
 670:iv.c          **** 	set_region();
 671:iv.c          **** 	break;
 672:iv.c          **** 	/*
 673:iv.c          ****       case (SET_REGION):
 674:iv.c          **** 	displaymode = SET_SNOOZE;
 675:iv.c          **** 	display_str("set snoz");
 676:iv.c          **** 	set_snooze();
 677:iv.c          **** 	break;
 678:iv.c          **** 	*/
 679:iv.c          ****       default:
 680:iv.c          **** 	displaymode = SHOW_TIME;
 681:iv.c          ****       }
 682:iv.c          ****     } else if ((just_pressed & 0x2) || (just_pressed & 0x4)) {
 683:iv.c          ****       just_pressed = 0;
 684:iv.c          ****       displaymode = NONE;
 685:iv.c          ****       display_date(DAY);
 686:iv.c          **** 
 687:iv.c          ****       kickthedog();
 688:iv.c          ****       delayms(1500);
 689:iv.c          ****       kickthedog();
 690:iv.c          **** 
 691:iv.c          ****       displaymode = SHOW_TIME;     
 692:iv.c          ****     }
 693:iv.c          **** 
 694:iv.c          ****     //Check to see if GPS data is ready:
 695:iv.c          ****     if ( gpsdataready() ) {
 696:iv.c          ****        getgpstime();
 697:iv.c          **** 
 698:iv.c          ****     }
 699:iv.c          ****  
 700:iv.c          ****   }
 701:iv.c          **** }
 702:iv.c          **** 
 703:iv.c          **** /**************************** SUB-MENUS *****************************/
 704:iv.c          **** 
 705:iv.c          **** void set_alarm(void) 
 706:iv.c          **** {
 707:iv.c          ****   uint8_t mode;
 708:iv.c          ****   uint8_t hour, min, sec;
 709:iv.c          ****     
 710:iv.c          ****   hour = min = sec = 0;
 711:iv.c          ****   mode = SHOW_MENU;
 712:iv.c          **** 
 713:iv.c          ****   hour = alarm_h;
 714:iv.c          ****   min = alarm_m;
 715:iv.c          ****   sec = 0;
 716:iv.c          ****   
 717:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;
 718:iv.c          ****   
 719:iv.c          ****   while (1) {
 720:iv.c          ****     if (just_pressed & 0x1) { // mode change
 721:iv.c          ****       return;
 722:iv.c          ****     }
 723:iv.c          ****     if (just_pressed || pressed) {
 724:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;  
 725:iv.c          ****       // timeout w/no buttons pressed after 3 seconds?
 726:iv.c          ****     } else if (!timeoutcounter) {
 727:iv.c          ****       //timed out!
 728:iv.c          ****       displaymode = SHOW_TIME;     
 729:iv.c          ****       alarm_h = hour;
 730:iv.c          ****       alarm_m = min;
 731:iv.c          ****       eeprom_write_byte((uint8_t *)EE_ALARM_HOUR, alarm_h);    
 732:iv.c          ****       eeprom_write_byte((uint8_t *)EE_ALARM_MIN, alarm_m);    
 733:iv.c          ****       return;
 734:iv.c          ****     }
 735:iv.c          ****     if (just_pressed & 0x2) {
 736:iv.c          ****       just_pressed = 0;
 737:iv.c          ****       if (mode == SHOW_MENU) {
 738:iv.c          **** 	// ok now its selected
 739:iv.c          **** 	mode = SET_HOUR;
 740:iv.c          **** 	display_alarm(hour, min);
 741:iv.c          **** 	display[1] |= 0x1;
 742:iv.c          **** 	display[2] |= 0x1;	
 743:iv.c          ****       } else if (mode == SET_HOUR) {
 744:iv.c          **** 	mode = SET_MIN;
 745:iv.c          **** 	display_alarm(hour, min);
 746:iv.c          **** 	display[4] |= 0x1;
 747:iv.c          **** 	display[5] |= 0x1;
 748:iv.c          ****       } else {
 749:iv.c          **** 	// done!
 750:iv.c          **** 	alarm_h = hour;
 751:iv.c          **** 	alarm_m = min;
 752:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_ALARM_HOUR, alarm_h);    
 753:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_ALARM_MIN, alarm_m);    
 754:iv.c          **** 	displaymode = SHOW_TIME;
 755:iv.c          **** 	return;
 756:iv.c          ****       }
 757:iv.c          ****     }
 758:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
 759:iv.c          ****       just_pressed = 0;
 760:iv.c          **** 
 761:iv.c          ****       if (mode == SET_HOUR) {
 762:iv.c          **** 	hour = (hour+1) % 24;
 763:iv.c          **** 	display_alarm(hour, min);
 764:iv.c          **** 	display[1] |= 0x1;
 765:iv.c          **** 	display[2] |= 0x1;
 766:iv.c          ****       }
 767:iv.c          ****       if (mode == SET_MIN) {
 768:iv.c          **** 	min = (min+1) % 60;
 769:iv.c          **** 	display_alarm(hour, min);
 770:iv.c          **** 	display[4] |= 0x1;
 771:iv.c          **** 	display[5] |= 0x1;
 772:iv.c          ****       }
 773:iv.c          **** 
 774:iv.c          ****       if (pressed & 0x4)
 775:iv.c          **** 	delayms(75);
 776:iv.c          ****     }
 777:iv.c          ****   }
 778:iv.c          **** }
 779:iv.c          **** 
 780:iv.c          **** void set_time(void) 
 781:iv.c          **** {
 782:iv.c          ****   uint8_t mode;
 783:iv.c          ****   uint8_t hour, min, sec;
 784:iv.c          ****     
 785:iv.c          ****   hour = time_h;
 786:iv.c          ****   min = time_m;
 787:iv.c          ****   sec = time_s;
 788:iv.c          ****   mode = SHOW_MENU;
 789:iv.c          **** 
 790:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;
 791:iv.c          ****   
 792:iv.c          ****   while (1) {
 793:iv.c          ****     if (just_pressed & 0x1) { // mode change
 794:iv.c          ****       return;
 795:iv.c          ****     }
 796:iv.c          ****     if (just_pressed || pressed) {
 797:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;  
 798:iv.c          ****       // timeout w/no buttons pressed after 3 seconds?
 799:iv.c          ****     } else if (!timeoutcounter) {
 800:iv.c          ****       //timed out!
 801:iv.c          ****       displaymode = SHOW_TIME;     
 802:iv.c          ****       return;
 803:iv.c          ****     }
 804:iv.c          ****     if (just_pressed & 0x2) {
 805:iv.c          ****       just_pressed = 0;
 806:iv.c          ****       if (mode == SHOW_MENU) {
 807:iv.c          **** 	hour = time_h;
 808:iv.c          **** 	min = time_m;
 809:iv.c          **** 	sec = time_s;
 810:iv.c          **** 
 811:iv.c          **** 	// ok now its selected
 812:iv.c          **** 	mode = SET_HOUR;
 813:iv.c          **** 	display_time(hour, min, sec);
 814:iv.c          **** 	display[1] |= 0x1;
 815:iv.c          **** 	display[2] |= 0x1;	
 816:iv.c          ****       } else if (mode == SET_HOUR) {
 817:iv.c          **** 	mode = SET_MIN;
 818:iv.c          **** 	display_time(hour, min, sec);
 819:iv.c          **** 	display[4] |= 0x1;
 820:iv.c          **** 	display[5] |= 0x1;
 821:iv.c          ****       } else if (mode == SET_MIN) {
 822:iv.c          **** 	mode = SET_SEC;
 823:iv.c          **** 	display_time(hour, min, sec);
 824:iv.c          **** 	display[7] |= 0x1;
 825:iv.c          **** 	display[8] |= 0x1;
 826:iv.c          ****       } else {
 827:iv.c          **** 	// done!
 828:iv.c          **** 	time_h = hour;
 829:iv.c          **** 	time_m = min;
 830:iv.c          **** 	time_s = sec;
 831:iv.c          **** 	displaymode = SHOW_TIME;
 832:iv.c          **** 	return;
 833:iv.c          ****       }
 834:iv.c          ****     }
 835:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
 836:iv.c          ****       just_pressed = 0;
 837:iv.c          ****       
 838:iv.c          ****       if (mode == SET_HOUR) {
 839:iv.c          **** 	hour = (hour+1) % 24;
 840:iv.c          **** 	display_time(hour, min, sec);
 841:iv.c          **** 	display[1] |= 0x1;
 842:iv.c          **** 	display[2] |= 0x1;
 843:iv.c          **** 	time_h = hour;
 844:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_HOUR, time_h);    
 845:iv.c          ****       }
 846:iv.c          ****       if (mode == SET_MIN) {
 847:iv.c          **** 	min = (min+1) % 60;
 848:iv.c          **** 	display_time(hour, min, sec);
 849:iv.c          **** 	display[4] |= 0x1;
 850:iv.c          **** 	display[5] |= 0x1;
 851:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_MIN, time_m);
 852:iv.c          **** 	time_m = min;
 853:iv.c          ****       }
 854:iv.c          ****       if ((mode == SET_SEC) ) {
 855:iv.c          **** 	sec = (sec+1) % 60;
 856:iv.c          **** 	display_time(hour, min, sec);
 857:iv.c          **** 	display[7] |= 0x1;
 858:iv.c          **** 	display[8] |= 0x1;
 859:iv.c          **** 	time_s = sec;
 860:iv.c          ****       }
 861:iv.c          ****       
 862:iv.c          ****       if (pressed & 0x4)
 863:iv.c          **** 	delayms(75);
 864:iv.c          ****     }
 865:iv.c          ****   }
 866:iv.c          **** }
 867:iv.c          **** 
 868:iv.c          **** 
 869:iv.c          **** 
 870:iv.c          **** void set_date(void) {
 871:iv.c          ****   uint8_t mode = SHOW_MENU;
 872:iv.c          **** 
 873:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;;  
 874:iv.c          **** 
 875:iv.c          ****   while (1) {
 876:iv.c          ****     if (just_pressed || pressed) {
 877:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
 878:iv.c          ****       // timeout w/no buttons pressed after 3 seconds?
 879:iv.c          ****     } else if (!timeoutcounter) {
 880:iv.c          ****       //timed out!
 881:iv.c          ****       displaymode = SHOW_TIME;     
 882:iv.c          ****       return;
 883:iv.c          ****     }
 884:iv.c          ****     if (just_pressed & 0x1) { // mode change
 885:iv.c          ****       return;
 886:iv.c          ****     }
 887:iv.c          ****     if (just_pressed & 0x2) {
 888:iv.c          **** 
 889:iv.c          ****       just_pressed = 0;
 890:iv.c          ****       if (mode == SHOW_MENU) {
 891:iv.c          **** 	// start!
 892:iv.c          **** 	if (region == REGION_US) {
 893:iv.c          **** 	  mode = SET_MONTH;
 894:iv.c          **** 	}
 895:iv.c          **** 	else {
 896:iv.c          **** 	  DEBUGP("Set day");
 897:iv.c          **** 	  mode = SET_DAY;
 898:iv.c          **** 	}
 899:iv.c          **** 	display_date(DATE);
 900:iv.c          **** 	display[1] |= 0x1;
 901:iv.c          **** 	display[2] |= 0x1;
 902:iv.c          ****       } else if (((mode == SET_MONTH) && (region == REGION_US)) ||
 903:iv.c          **** 		 ((mode == SET_DAY) && (region == REGION_EU))) {
 904:iv.c          **** 	if (region == REGION_US)
 905:iv.c          **** 	  mode = SET_DAY;
 906:iv.c          **** 	else
 907:iv.c          **** 	  mode = SET_MONTH;
 908:iv.c          **** 	display_date(DATE);
 909:iv.c          **** 	display[4] |= 0x1;
 910:iv.c          **** 	display[5] |= 0x1;
 911:iv.c          ****       } else if (((mode == SET_DAY) && (region == REGION_US)) ||
 912:iv.c          **** 	((mode == SET_MONTH) && (region == REGION_EU))) {
 913:iv.c          **** 	mode = SET_YEAR;
 914:iv.c          **** 	display_date(DATE);
 915:iv.c          **** 	display[7] |= 0x1;
 916:iv.c          **** 	display[8] |= 0x1;
 917:iv.c          ****       } else {
 918:iv.c          **** 	displaymode = NONE;
 919:iv.c          **** 	display_date(DATE);
 920:iv.c          **** 	delayms(1500);
 921:iv.c          **** 	displaymode = SHOW_TIME;
 922:iv.c          **** 	return;
 923:iv.c          ****       }
 924:iv.c          ****     }
 925:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
 926:iv.c          ****       just_pressed = 0;
 927:iv.c          ****       if (mode == SET_MONTH) {
 928:iv.c          **** 	date_m++;
 929:iv.c          **** 	if (date_m >= 13)
 930:iv.c          **** 	  date_m = 1;
 931:iv.c          **** 	display_date(DATE);
 932:iv.c          **** 	if (region == REGION_US) {
 933:iv.c          **** 	  display[1] |= 0x1;
 934:iv.c          **** 	  display[2] |= 0x1;
 935:iv.c          **** 	} else {
 936:iv.c          **** 	  display[4] |= 0x1;
 937:iv.c          **** 	  display[5] |= 0x1;
 938:iv.c          **** 	}
 939:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_MONTH, date_m);    
 940:iv.c          ****       }
 941:iv.c          ****       if (mode == SET_DAY) {
 942:iv.c          **** 	date_d++;
 943:iv.c          **** 	if (date_d > 31)
 944:iv.c          **** 	  date_d = 1;
 945:iv.c          **** 	display_date(DATE);
 946:iv.c          **** 
 947:iv.c          **** 	if (region == REGION_EU) {
 948:iv.c          **** 	  display[1] |= 0x1;
 949:iv.c          **** 	  display[2] |= 0x1;
 950:iv.c          **** 	} else {
 951:iv.c          **** 	  display[4] |= 0x1;
 952:iv.c          **** 	  display[5] |= 0x1;
 953:iv.c          **** 	}
 954:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_DAY, date_d);    
 955:iv.c          ****       }
 956:iv.c          ****       if (mode == SET_YEAR) {
 957:iv.c          **** 	date_y++;
 958:iv.c          **** 	date_y %= 100;
 959:iv.c          **** 	display_date(DATE);
 960:iv.c          **** 	display[7] |= 0x1;
 961:iv.c          **** 	display[8] |= 0x1;
 962:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_YEAR, date_y);    
 963:iv.c          ****       }
 964:iv.c          **** 
 965:iv.c          ****       if (pressed & 0x4)
 966:iv.c          **** 	delayms(60);
 967:iv.c          ****     }
 968:iv.c          ****   }
 969:iv.c          **** }
 970:iv.c          **** 
 971:iv.c          **** //Function to set the time zone
 972:iv.c          **** void set_timezone(void) {
 973:iv.c          ****   int8_t hour = intTimeZoneHour;
 974:iv.c          ****   uint8_t min = intTimeZoneMin;
 975:iv.c          ****   uint8_t mode = SHOW_MENU;
 976:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;
 977:iv.c          **** 
 978:iv.c          ****   while (1) {
 979:iv.c          ****     if (just_pressed & 0x1) { // mode change
 980:iv.c          ****       return;
 981:iv.c          ****     }
 982:iv.c          ****     if (just_pressed || pressed) {
 983:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;  
 984:iv.c          ****       // timeout w/no buttons pressed after 3 seconds?
 985:iv.c          ****     } else if (!timeoutcounter) {
 986:iv.c          ****       //timed out!
 987:iv.c          ****       displaymode = SHOW_TIME;     
 988:iv.c          ****       return;
 989:iv.c          ****     }
 990:iv.c          ****     if (just_pressed & 0x2) {
 991:iv.c          ****       just_pressed = 0;
 992:iv.c          ****       if (mode == SHOW_MENU) {
 993:iv.c          **** 	// ok now its selected
 994:iv.c          **** 	mode = SET_HOUR;
 995:iv.c          **** 	display_timezone(hour, min);
 996:iv.c          **** 	display[1] |= 0x1;
 997:iv.c          **** 	display[2] |= 0x1;	
 998:iv.c          ****       } else if (mode == SET_HOUR) {
 999:iv.c          **** 	mode = SET_MIN;
1000:iv.c          **** 	display_timezone(hour, min);
1001:iv.c          **** 	display[4] |= 0x1;
1002:iv.c          **** 	display[5] |= 0x1;
1003:iv.c          ****       } else {
1004:iv.c          **** 	// done!
1005:iv.c          **** 	displaymode = SHOW_TIME;
1006:iv.c          **** 	return;
1007:iv.c          ****       }
1008:iv.c          ****     }
1009:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
1010:iv.c          ****       just_pressed = 0;
1011:iv.c          ****       
1012:iv.c          ****       if (mode == SET_HOUR) {
1013:iv.c          **** 	hour = ( ( hour + 1 + 12 ) % 25 ) - 12;
1014:iv.c          **** 	display_timezone(hour, min);
1015:iv.c          **** 	display[1] |= 0x1;
1016:iv.c          **** 	display[2] |= 0x1;
1017:iv.c          ****         intTimeZoneHour = hour;
1018:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_ZONE_HOUR, hour);
1019:iv.c          **** 	//Debugging:
1020:iv.c          **** 	uart_puts("\n\rTimezone offset hour:\t");
1021:iv.c          **** 	uart_putw_dec(hour);
1022:iv.c          ****       }
1023:iv.c          ****       if (mode == SET_MIN) {
1024:iv.c          **** 	min = ( min + 1 ) % 60;
1025:iv.c          **** 	display_timezone(hour, min);
1026:iv.c          **** 	display[4] |= 0x1;
1027:iv.c          **** 	display[5] |= 0x1;
1028:iv.c          ****         intTimeZoneMin = min;
1029:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_ZONE_MIN, min);
1030:iv.c          ****       }
1031:iv.c          ****       
1032:iv.c          ****       if (pressed & 0x4)
1033:iv.c          **** 	delayms(75);
1034:iv.c          ****     }
1035:iv.c          ****   }
1036:iv.c          **** }
1037:iv.c          **** 
1038:iv.c          **** void set_brightness(void) {
1039:iv.c          ****   uint8_t mode = SHOW_MENU;
1040:iv.c          **** 
1041:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;;  
1042:iv.c          **** 
1043:iv.c          ****   while (1) {
1044:iv.c          ****     if (just_pressed || pressed) {
1045:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
1046:iv.c          ****       // timeout w/no buttons pressed after 3 seconds?
1047:iv.c          ****     } else if (!timeoutcounter) {
1048:iv.c          ****       //timed out!
1049:iv.c          ****       displaymode = SHOW_TIME;     
1050:iv.c          ****       eeprom_write_byte((uint8_t *)EE_BRIGHT, brightness_level);
1051:iv.c          ****       return;
1052:iv.c          ****     }
1053:iv.c          ****     if (just_pressed & 0x1) { // mode change
1054:iv.c          ****       return;
1055:iv.c          ****     }
1056:iv.c          ****     if (just_pressed & 0x2) {
1057:iv.c          **** 
1058:iv.c          ****       just_pressed = 0;
1059:iv.c          ****       if (mode == SHOW_MENU) {
1060:iv.c          **** 	// start!
1061:iv.c          **** 	mode = SET_BRITE;
1062:iv.c          **** 	// display brightness
1063:iv.c          **** 	display_str("brite ");
1064:iv.c          **** 	display_brightness(brightness_level);
1065:iv.c          ****       } else {	
1066:iv.c          **** 	displaymode = SHOW_TIME;
1067:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_BRIGHT, brightness_level);
1068:iv.c          **** 	return;
1069:iv.c          ****       }
1070:iv.c          ****     }
1071:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
1072:iv.c          ****       just_pressed = 0;
1073:iv.c          ****       if (mode == SET_BRITE) {
1074:iv.c          ****         // Increment brightness level. Zero means auto-dim.
1075:iv.c          **** 	if (brightness_level == 0) {
1076:iv.c          **** 	  brightness_level = BRIGHTNESS_MIN;
1077:iv.c          **** 	} else {
1078:iv.c          **** 	  brightness_level += BRIGHTNESS_INCREMENT;
1079:iv.c          **** 	  if (brightness_level > BRIGHTNESS_MAX) {
1080:iv.c          **** #ifdef FEATURE_AUTODIM
1081:iv.c          **** 	    brightness_level = 0;
1082:iv.c          **** #else
1083:iv.c          **** 	    brightness_level = BRIGHTNESS_MIN;
1084:iv.c          **** #endif
1085:iv.c          **** 	  }
1086:iv.c          **** 	}
1087:iv.c          **** 	display_brightness(brightness_level);
1088:iv.c          ****       }
1089:iv.c          ****     }
1090:iv.c          ****   }
1091:iv.c          **** }
1092:iv.c          **** 
1093:iv.c          **** void display_brightness(int brightness) {
1094:iv.c          **** #ifdef FEATURE_AUTODIM
1095:iv.c          ****   if (brightness == 0) {
1096:iv.c          ****     // auto-dim
1097:iv.c          ****     display[7] =  pgm_read_byte(alphatable_p + 'a' - 'a') | 0x1;
1098:iv.c          ****     display[8] =  pgm_read_byte(alphatable_p + 'u' - 'a') | 0x1;
1099:iv.c          ****     dimmer_update();
1100:iv.c          ****     return;
1101:iv.c          ****   }
1102:iv.c          **** #endif
1103:iv.c          ****   display[7] = pgm_read_byte(numbertable_p + (brightness / 10)) | 0x1;
1104:iv.c          ****   display[8] = pgm_read_byte(numbertable_p + (brightness % 10)) | 0x1;
1105:iv.c          ****   set_vfd_brightness(brightness);
1106:iv.c          **** }
1107:iv.c          **** 
1108:iv.c          **** void set_volume(void) {
1109:iv.c          ****   uint8_t mode = SHOW_MENU;
1110:iv.c          ****   uint8_t volume;
1111:iv.c          **** 
1112:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;;  
1113:iv.c          ****   volume = eeprom_read_byte((uint8_t *)EE_VOLUME);
1114:iv.c          **** 
1115:iv.c          ****   while (1) {
1116:iv.c          ****     if (just_pressed || pressed) {
1117:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
1118:iv.c          ****       // timeout w/no buttons pressed after 3 seconds?
1119:iv.c          ****     } else if (!timeoutcounter) {
1120:iv.c          ****       //timed out!
1121:iv.c          ****       displaymode = SHOW_TIME;     
1122:iv.c          ****       return;
1123:iv.c          ****     }
1124:iv.c          ****     if (just_pressed & 0x1) { // mode change
1125:iv.c          ****       return;
1126:iv.c          ****     }
1127:iv.c          ****     if (just_pressed & 0x2) {
1128:iv.c          ****       just_pressed = 0;
1129:iv.c          ****       if (mode == SHOW_MENU) {
1130:iv.c          **** 	// start!
1131:iv.c          **** 	mode = SET_VOL;
1132:iv.c          **** 	// display volume
1133:iv.c          **** 	if (volume) {
1134:iv.c          **** 	  display_str("vol high");
1135:iv.c          **** 	  display[5] |= 0x1;
1136:iv.c          **** 	} else {
1137:iv.c          **** 	  display_str("vol  low");
1138:iv.c          **** 	}
1139:iv.c          **** 	display[6] |= 0x1;
1140:iv.c          **** 	display[7] |= 0x1;
1141:iv.c          **** 	display[8] |= 0x1;
1142:iv.c          ****       } else {	
1143:iv.c          **** 	displaymode = SHOW_TIME;
1144:iv.c          **** 	return;
1145:iv.c          ****       }
1146:iv.c          ****     }
1147:iv.c          ****     if (just_pressed & 0x4) {
1148:iv.c          ****       just_pressed = 0;
1149:iv.c          ****       if (mode == SET_VOL) {
1150:iv.c          **** 	volume = !volume;
1151:iv.c          **** 	if (volume) {
1152:iv.c          **** 	  display_str("vol high");
1153:iv.c          **** 	  display[5] |= 0x1;
1154:iv.c          **** 	} else {
1155:iv.c          **** 	  display_str("vol  low");
1156:iv.c          **** 	}
1157:iv.c          **** 	display[6] |= 0x1;
1158:iv.c          **** 	display[7] |= 0x1;
1159:iv.c          **** 	display[8] |= 0x1;
1160:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_VOLUME, volume);
1161:iv.c          **** 	speaker_init();
1162:iv.c          **** 	beep(4000, 1);
1163:iv.c          ****       }
1164:iv.c          ****     }
1165:iv.c          ****   }
1166:iv.c          **** }
1167:iv.c          **** 
1168:iv.c          **** 
1169:iv.c          **** 
1170:iv.c          **** 
1171:iv.c          **** void set_region(void) {
1172:iv.c          ****   uint8_t mode = SHOW_MENU;
1173:iv.c          **** 
1174:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;;  
1175:iv.c          ****   region = eeprom_read_byte((uint8_t *)EE_REGION);
1176:iv.c          **** 
1177:iv.c          ****   while (1) {
1178:iv.c          ****     if (just_pressed || pressed) {
1179:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
1180:iv.c          ****       // timeout w/no buttons pressed after 3 seconds?
1181:iv.c          ****     } else if (!timeoutcounter) {
1182:iv.c          ****       //timed out!
1183:iv.c          ****       displaymode = SHOW_TIME;     
1184:iv.c          ****       return;
1185:iv.c          ****     }
1186:iv.c          ****     if (just_pressed & 0x1) { // mode change
1187:iv.c          ****       return;
1188:iv.c          ****     }
1189:iv.c          ****     if (just_pressed & 0x2) {
1190:iv.c          ****       just_pressed = 0;
1191:iv.c          ****       if (mode == SHOW_MENU) {
1192:iv.c          **** 	// start!
1193:iv.c          **** 	mode = SET_REG;
1194:iv.c          **** 	// display region
1195:iv.c          **** 	if (region == REGION_US) {
1196:iv.c          **** 	  display_str("usa-12hr");
1197:iv.c          **** 	} else {
1198:iv.c          **** 	  display_str("eur-24hr");
1199:iv.c          **** 	}
1200:iv.c          ****       } else {	
1201:iv.c          **** 	displaymode = SHOW_TIME;
1202:iv.c          **** 	return;
1203:iv.c          ****       }
1204:iv.c          ****     }
1205:iv.c          ****     if (just_pressed & 0x4) {
1206:iv.c          ****       just_pressed = 0;
1207:iv.c          ****       if (mode == SET_REG) {
1208:iv.c          **** 	region = !region;
1209:iv.c          **** 	if (region == REGION_US) {
1210:iv.c          **** 	  display_str("usa-12hr");
1211:iv.c          **** 	} else {
1212:iv.c          **** 	  display_str("eur-24hr");
1213:iv.c          **** 	}
1214:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_REGION, region);
1215:iv.c          ****       }
1216:iv.c          ****     }
1217:iv.c          ****   }
1218:iv.c          **** }
1219:iv.c          **** 
1220:iv.c          **** 
1221:iv.c          **** /*
1222:iv.c          **** void set_snooze(void) {
1223:iv.c          ****   uint8_t mode = SHOW_MENU;
1224:iv.c          ****   uint8_t snooze;
1225:iv.c          **** 
1226:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;;  
1227:iv.c          ****   snooze = eeprom_read_byte((uint8_t *)EE_SNOOZE);
1228:iv.c          **** 
1229:iv.c          ****   while (1) {
1230:iv.c          ****     if (just_pressed || pressed) {
1231:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
1232:iv.c          ****       // timeout w/no buttons pressed after 3 seconds?
1233:iv.c          ****     } else if (!timeoutcounter) {
1234:iv.c          ****       //timed out!
1235:iv.c          ****       displaymode = SHOW_TIME;     
1236:iv.c          ****       return;
1237:iv.c          ****     }
1238:iv.c          ****     if (just_pressed & 0x1) { // mode change
1239:iv.c          ****       return;
1240:iv.c          ****     }
1241:iv.c          ****     if (just_pressed & 0x2) {
1242:iv.c          **** 
1243:iv.c          ****       just_pressed = 0;
1244:iv.c          ****       if (mode == SHOW_MENU) {
1245:iv.c          **** 	// start!
1246:iv.c          **** 	mode = SET_SNOOZE;
1247:iv.c          **** 	// display snooze
1248:iv.c          **** 	display_str("   minut");
1249:iv.c          **** 	display[1] = pgm_read_byte(numbertable_p + (snooze / 10)) | 0x1;
1250:iv.c          **** 	display[2] = pgm_read_byte(numbertable_p + (snooze % 10)) | 0x1;
1251:iv.c          ****       } else { 
1252:iv.c          **** 	displaymode = SHOW_TIME;
1253:iv.c          **** 	return;
1254:iv.c          ****       }
1255:iv.c          ****     }
1256:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
1257:iv.c          ****       just_pressed = 0;
1258:iv.c          ****       if (mode == SET_SNOOZE) {
1259:iv.c          ****         snooze ++;
1260:iv.c          **** 	if (snooze >= 100)
1261:iv.c          **** 	  snooze = 0;
1262:iv.c          **** 	display[1] = pgm_read_byte(numbertable_p + (snooze / 10)) | 0x1;
1263:iv.c          **** 	display[2] = pgm_read_byte(numbertable_p + (snooze % 10)) | 0x1;
1264:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_SNOOZE, snooze);
1265:iv.c          ****       }
1266:iv.c          **** 
1267:iv.c          ****       if (pressed & 0x4)
1268:iv.c          **** 	delayms(75);
1269:iv.c          **** 
1270:iv.c          ****     }
1271:iv.c          ****   }
1272:iv.c          **** }
1273:iv.c          **** */
1274:iv.c          **** 
1275:iv.c          **** 
1276:iv.c          **** /**************************** RTC & ALARM *****************************/
1277:iv.c          **** void clock_init(void) {
1278:iv.c          ****   // we store the time in EEPROM when switching from power modes so its
1279:iv.c          ****   // reasonable to start with whats in memory
1280:iv.c          ****   time_h = eeprom_read_byte((uint8_t *)EE_HOUR) % 24;
1281:iv.c          ****   time_m = eeprom_read_byte((uint8_t *)EE_MIN) % 60;
1282:iv.c          ****   time_s = eeprom_read_byte((uint8_t *)EE_SEC) % 60;
1283:iv.c          **** 
1284:iv.c          ****   /*
1285:iv.c          ****     // if you're debugging, having the makefile set the right
1286:iv.c          ****     // time automatically will be very handy. Otherwise don't use this
1287:iv.c          ****   time_h = TIMEHOUR;
1288:iv.c          ****   time_m = TIMEMIN;
1289:iv.c          ****   time_s = TIMESEC + 10;
1290:iv.c          ****   */
1291:iv.c          **** 
1292:iv.c          ****   // Set up the stored alarm time and date
1293:iv.c          ****   alarm_m = eeprom_read_byte((uint8_t *)EE_ALARM_MIN) % 60;
1294:iv.c          ****   alarm_h = eeprom_read_byte((uint8_t *)EE_ALARM_HOUR) % 24;
1295:iv.c          **** 
1296:iv.c          ****   date_y = eeprom_read_byte((uint8_t *)EE_YEAR) % 100;
1297:iv.c          ****   date_m = eeprom_read_byte((uint8_t *)EE_MONTH) % 13;
1298:iv.c          ****   date_d = eeprom_read_byte((uint8_t *)EE_DAY) % 32;
1299:iv.c          **** 
1300:iv.c          ****   restored = 1;
1301:iv.c          **** 
1302:iv.c          ****   // Turn on the RTC by selecting the external 32khz crystal
1303:iv.c          ****   // 32.768 / 128 = 256 which is exactly an 8-bit timer overflow
1304:iv.c          ****   ASSR |= _BV(AS2); // use crystal
1305:iv.c          ****   TCCR2B = _BV(CS22) | _BV(CS20); // div by 128
1306:iv.c          ****   // We will overflow once a second, and call an interrupt
1307:iv.c          **** 
1308:iv.c          ****   // enable interrupt
1309:iv.c          ****   TIMSK2 = _BV(TOIE2);
1310:iv.c          **** 
1311:iv.c          ****   // enable all interrupts!
1312:iv.c          ****   sei();
1313:iv.c          **** }
1314:iv.c          **** 
1315:iv.c          **** // This turns on/off the alarm when the switch has been
1316:iv.c          **** // set. It also displays the alarm time
1317:iv.c          **** void setalarmstate(void) {
1318:iv.c          ****   if (ALARM_PIN & _BV(ALARM)) { 
1319:iv.c          ****     // Don't display the alarm/beep if we already have
1320:iv.c          ****     if  (!alarm_on) {
1321:iv.c          ****       // alarm on!
1322:iv.c          ****       alarm_on = 1;
1323:iv.c          ****       // reset snoozing
1324:iv.c          ****       snoozetimer = 0;
1325:iv.c          ****       // show the status on the VFD tube
1326:iv.c          ****       display_str("alarm on");
1327:iv.c          ****       // its not actually SHOW_SNOOZE but just anything but SHOW_TIME
1328:iv.c          ****       displaymode = SHOW_SNOOZE;
1329:iv.c          ****       delayms(1000);
1330:iv.c          ****       // show the current alarm time set
1331:iv.c          ****       display_alarm(alarm_h, alarm_m);
1332:iv.c          ****       delayms(1000);
1333:iv.c          ****       // after a second, go back to clock mode
1334:iv.c          ****       displaymode = SHOW_TIME;
1335:iv.c          ****     }
1336:iv.c          ****   } else {
1337:iv.c          ****     if (alarm_on) {
1338:iv.c          ****       // turn off the alarm
1339:iv.c          ****       alarm_on = 0;
1340:iv.c          ****       snoozetimer = 0;
1341:iv.c          ****       if (alarming) {
1342:iv.c          **** 	// if the alarm is going off, we should turn it off
1343:iv.c          **** 	// and quiet the speaker
1344:iv.c          **** 	DEBUGP("alarm off");
1345:iv.c          **** 	alarming = 0;
1346:iv.c          **** 	TCCR1B &= ~_BV(CS11); // turn it off!
1347:iv.c          **** 	PORTB |= _BV(SPK1) | _BV(SPK2);
1348:iv.c          ****       } 
1349:iv.c          ****     }
1350:iv.c          ****   }
1351:iv.c          **** }
1352:iv.c          **** 
1353:iv.c          **** // This will calculate leapyears, give it the year
1354:iv.c          **** // and it will return 1 (true) or 0 (false)
1355:iv.c          **** uint8_t leapyear(uint16_t y) {
 329               	.LM44:
 330               	.LFBB5:
 331               	/* prologue: function */
 332               	/* frame size = 0 */
 333 00a0 FC01      		movw r30,r24
1356:iv.c          ****   return ( (!(y % 4) && (y % 100)) || !(y % 400));
 335               	.LM45:
 336 00a2 8370      		andi r24,lo8(3)
 337 00a4 9070      		andi r25,hi8(3)
 338 00a6 892B      		or r24,r25
 339 00a8 01F4      		brne .L12
 340 00aa CF01      		movw r24,r30
 341 00ac 64E6      		ldi r22,lo8(100)
 342 00ae 70E0      		ldi r23,hi8(100)
 343 00b0 0E94 0000 		call __udivmodhi4
 344 00b4 892B      		or r24,r25
 345 00b6 01F4      		brne .L16
 346               	.L12:
 347 00b8 20E0      		ldi r18,lo8(0)
 348 00ba 30E0      		ldi r19,hi8(0)
 349 00bc CF01      		movw r24,r30
 350 00be 60E9      		ldi r22,lo8(400)
 351 00c0 71E0      		ldi r23,hi8(400)
 352 00c2 0E94 0000 		call __udivmodhi4
 353 00c6 892B      		or r24,r25
 354 00c8 01F4      		brne .L13
 355               	.L16:
 356 00ca 21E0      		ldi r18,lo8(1)
 357 00cc 30E0      		ldi r19,hi8(1)
 358               	.L13:
1357:iv.c          **** }
 360               	.LM46:
 361 00ce 822F      		mov r24,r18
 362               	/* epilogue start */
 363 00d0 0895      		ret
 365               	.Lscope5:
 367               		.stabd	78,0,0
 369               	.global	tick
 371               	tick:
 372               		.stabd	46,0,0
1358:iv.c          **** 
1359:iv.c          **** 
1360:iv.c          **** /**************************** SPEAKER *****************************/
1361:iv.c          **** // Set up the speaker to prepare for beeping!
1362:iv.c          **** void speaker_init(void) {
1363:iv.c          **** 
1364:iv.c          ****   // read the preferences for high/low volume
1365:iv.c          ****   volume = eeprom_read_byte((uint8_t *)EE_VOLUME);
1366:iv.c          **** 
1367:iv.c          ****   // We use the built-in fast PWM, 8 bit timer
1368:iv.c          ****   PORTB |= _BV(SPK1) | _BV(SPK2); 
1369:iv.c          **** 
1370:iv.c          ****   // Turn on PWM outputs for both pins
1371:iv.c          ****   TCCR1A = _BV(COM1B1) | _BV(COM1B0) | _BV(WGM11);
1372:iv.c          ****   if (volume) {
1373:iv.c          ****     TCCR1A |= _BV(COM1A1);
1374:iv.c          ****   } 
1375:iv.c          ****   TCCR1B = _BV(WGM13) | _BV(WGM12);
1376:iv.c          **** 
1377:iv.c          ****   // start at 4khz:  250 * 8 multiplier * 4000 = 8mhz
1378:iv.c          ****   ICR1 = 250;
1379:iv.c          ****   OCR1B = OCR1A = ICR1 / 2;
1380:iv.c          **** }
1381:iv.c          **** 
1382:iv.c          **** // This makes the speaker tick, it doesnt use PWM
1383:iv.c          **** // instead it just flicks the piezo
1384:iv.c          **** void tick(void) {
 374               	.LM47:
 375               	.LFBB6:
 376               	/* prologue: function */
 377               	/* frame size = 0 */
1385:iv.c          ****   TCCR1A = 0;
 379               	.LM48:
 380 00d2 1092 8000 		sts 128,__zero_reg__
1386:iv.c          ****   TCCR1B = 0;
 382               	.LM49:
 383 00d6 1092 8100 		sts 129,__zero_reg__
1387:iv.c          **** 
1388:iv.c          ****   // Send a pulse thru both pins, alternating
1389:iv.c          ****   SPK_PORT |= _BV(SPK1);
 385               	.LM50:
 386 00da 299A      		sbi 37-32,1
1390:iv.c          ****   SPK_PORT &= ~_BV(SPK2);
 388               	.LM51:
 389 00dc 2A98      		cbi 37-32,2
 390               	.LBB128:
 391               	.LBB129:
 116:iv.c          ****   sei();
 393               	.LM52:
 394               	/* #APP */
 395               	 ;  116 "iv.c" 1
 396 00de 7894      		sei
 397               	 ;  0 "" 2
 118:iv.c          ****   milliseconds = 0;
 399               	.LM53:
 400               	/* #NOAPP */
 401 00e0 1092 0000 		sts (milliseconds)+1,__zero_reg__
 402 00e4 1092 0000 		sts milliseconds,__zero_reg__
 403               	.L18:
 119:iv.c          ****   while (milliseconds < ms);
 405               	.LM54:
 406 00e8 8091 0000 		lds r24,milliseconds
 407 00ec 9091 0000 		lds r25,(milliseconds)+1
 408 00f0 0A97      		sbiw r24,10
 409 00f2 00F0      		brlo .L18
 410               	.LBE129:
 411               	.LBE128:
1391:iv.c          ****   delayms(10);
1392:iv.c          ****   SPK_PORT |= _BV(SPK2);
 413               	.LM55:
 414 00f4 2A9A      		sbi 37-32,2
1393:iv.c          ****   SPK_PORT &= ~_BV(SPK1);
 416               	.LM56:
 417 00f6 2998      		cbi 37-32,1
 418               	.LBB130:
 419               	.LBB131:
 116:iv.c          ****   sei();
 421               	.LM57:
 422               	/* #APP */
 423               	 ;  116 "iv.c" 1
 424 00f8 7894      		sei
 425               	 ;  0 "" 2
 118:iv.c          ****   milliseconds = 0;
 427               	.LM58:
 428               	/* #NOAPP */
 429 00fa 1092 0000 		sts (milliseconds)+1,__zero_reg__
 430 00fe 1092 0000 		sts milliseconds,__zero_reg__
 431               	.L19:
 119:iv.c          ****   while (milliseconds < ms);
 433               	.LM59:
 434 0102 8091 0000 		lds r24,milliseconds
 435 0106 9091 0000 		lds r25,(milliseconds)+1
 436 010a 0A97      		sbiw r24,10
 437 010c 00F0      		brlo .L19
 438               	.LBE131:
 439               	.LBE130:
1394:iv.c          ****   delayms(10);
1395:iv.c          ****   // turn them both off
1396:iv.c          ****   SPK_PORT &= ~_BV(SPK1) & ~_BV(SPK2);
 441               	.LM60:
 442 010e 85B1      		in r24,37-32
 443 0110 897F      		andi r24,lo8(-7)
 444 0112 85B9      		out 37-32,r24
1397:iv.c          **** 
1398:iv.c          ****   TCCR1A = _BV(COM1A1) | _BV(COM1B1) | _BV(COM1B0) | _BV(WGM11);
 446               	.LM61:
 447 0114 82EB      		ldi r24,lo8(-78)
 448 0116 8093 8000 		sts 128,r24
1399:iv.c          ****   TCCR1B = _BV(WGM13) | _BV(WGM12);
 450               	.LM62:
 451 011a 88E1      		ldi r24,lo8(24)
 452 011c 8093 8100 		sts 129,r24
 453               	/* epilogue start */
1400:iv.c          **** }
 455               	.LM63:
 456 0120 0895      		ret
 458               	.Lscope6:
 460               		.stabd	78,0,0
 464               	.global	beep
 466               	beep:
 467               		.stabd	46,0,0
1401:iv.c          **** 
1402:iv.c          **** // We can play short beeps!
1403:iv.c          **** void beep(uint16_t freq, uint8_t times) {
 469               	.LM64:
 470               	.LFBB7:
 471 0122 1F93      		push r17
 472               	/* prologue: function */
 473               	/* frame size = 0 */
 474 0124 162F      		mov r17,r22
1404:iv.c          ****   // set the PWM output to match the desired frequency
1405:iv.c          ****   ICR1 = (F_CPU/8)/freq;
 476               	.LM65:
 477 0126 9C01      		movw r18,r24
 478 0128 40E0      		ldi r20,lo8(0)
 479 012a 50E0      		ldi r21,hi8(0)
 480 012c 60E4      		ldi r22,lo8(1000000)
 481 012e 72E4      		ldi r23,hi8(1000000)
 482 0130 8FE0      		ldi r24,hlo8(1000000)
 483 0132 90E0      		ldi r25,hhi8(1000000)
 484 0134 0E94 0000 		call __divmodsi4
 485 0138 3093 8700 		sts (134)+1,r19
 486 013c 2093 8600 		sts 134,r18
1406:iv.c          ****   // we want 50% duty cycle square wave
1407:iv.c          ****   OCR1A = OCR1B = ICR1/2;
 488               	.LM66:
 489 0140 8091 8600 		lds r24,134
 490 0144 9091 8700 		lds r25,(134)+1
 491 0148 9695      		lsr r25
 492 014a 8795      		ror r24
 493 014c 9093 8B00 		sts (138)+1,r25
 494 0150 8093 8A00 		sts 138,r24
 495 0154 8091 8A00 		lds r24,138
 496 0158 9091 8B00 		lds r25,(138)+1
 497 015c 9093 8900 		sts (136)+1,r25
 498 0160 8093 8800 		sts 136,r24
 499               	.LBB132:
 500               	.LBB133:
 501               	.LBB134:
 502               	.LBB135:
 504               	.Ltext1:
   0:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   1:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   2:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****    All rights reserved.
   3:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 
   4:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   5:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   6:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 
   7:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   8:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
   9:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 
  10:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  13:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****      distribution.
  14:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 
  15:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  16:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  17:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  18:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 
  19:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  30:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 
  31:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h,v 1.1 2007/05/13 21:23:20 joerg_wunsch Exp $ */
  32:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 
  33:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  34:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  35:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 
  36:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  37:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 
  38:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** /** \file */
  39:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  40:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     \code
  41:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  42:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     \endcode
  43:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 
  44:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  45:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  46:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  47:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  48:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  49:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  50:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  51:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 
  52:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  53:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  54:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  55:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  56:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  57:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     to the overall delay time.
  58:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 
  59:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  60:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 
  61:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** */
  62:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 
  63:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  64:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  65:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  66:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** #endif
  67:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 
  68:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  69:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 
  70:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  71:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  72:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  73:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  74:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     register.
  75:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 
  76:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  77:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     can be achieved.
  78:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** */
  79:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** void
  80:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  81:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** {
  82:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  83:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  84:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 		"brne 1b"
  85:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  86:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  87:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 	);
  88:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** }
  89:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 
  90:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  91:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 
  92:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  93:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  94:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  95:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  96:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     counter register pair.
  97:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 
  98:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
  99:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 100:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h ****  */
 101:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** void
 102:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 103:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** {
 104:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 506               	.LM67:
 507 0164 28EC      		ldi r18,lo8(200)
 508 0166 30E0      		ldi r19,hi8(200)
 509 0168 00C0      		rjmp .L24
 510               	.L27:
 511               	.LBE135:
 512               	.LBE134:
 513               	.LBE133:
 514               	.LBE132:
 516               	.Ltext2:
1408:iv.c          ****    
1409:iv.c          ****   while (times--) {
1410:iv.c          ****     TCCR1B |= _BV(CS11); // turn it on!
 518               	.LM68:
 519 016a 8091 8100 		lds r24,129
 520 016e 8260      		ori r24,lo8(2)
 521 0170 8093 8100 		sts 129,r24
 522 0174 80ED      		ldi r24,lo8(2000)
 523 0176 97E0      		ldi r25,hi8(2000)
 524               	.L25:
 525               	.LBB139:
 526               	.LBB138:
 527               	.LBB137:
 528               	.LBB136:
 530               	.Ltext3:
 532               	.LM69:
 533 0178 F901      		movw r30,r18
 534               	/* #APP */
 535               	 ;  105 "/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h" 1
 536 017a 3197      		1: sbiw r30,1
 537 017c 01F4      		brne 1b
 538               	 ;  0 "" 2
 539               	/* #NOAPP */
 540               	.LBE136:
 541               	.LBE137:
 543               	.Ltext4:
   0:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   1:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   2:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   3:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****    All rights reserved.
   4:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
   5:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
   8:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
  11:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  14:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****      distribution.
  15:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
  16:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  18:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  19:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
  20:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
  32:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** /* $Id: delay.h,v 1.5.2.1 2009/02/25 10:14:03 joerg_wunsch Exp $ */
  33:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
  34:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  35:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  36:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
  37:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  38:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  39:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
  40:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** /** \file */
  41:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  42:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     \code
  43:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  44:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  45:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  46:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     \endcode
  47:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
  48:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  49:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  50:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  51:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     used.
  52:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
  53:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  54:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  55:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  56:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  57:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  58:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  59:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  60:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  61:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
  62:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  63:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  64:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  65:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  66:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  67:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  68:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  69:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     routines linked into the application.
  70:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
  71:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  72:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  73:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  74:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
  75:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** */
  76:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
  77:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  78:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  79:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  80:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** #endif
  81:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
  82:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  83:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  84:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  85:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  86:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** #endif
  87:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
  88:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  89:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  90:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** #endif
  91:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
  92:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** /**
  93:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****    \ingroup util_delay
  94:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
  95:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
  96:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
  97:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
  98:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
  99:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
 100:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 101:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 
 102:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 103:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 104:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 105:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 106:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 107:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h ****  */
 108:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** void
 109:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 110:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** {
 111:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 112:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 	double __tmp = ((F_CPU) / 4e3) * __ms;
 113:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 114:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 115:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 116:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 	{
 117:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 118:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 119:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 		while(__ticks)
 120:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 		{
 121:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 122:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 123:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 			__ticks --;
 545               	.LM70:
 546 017e 0197      		sbiw r24,1
 120:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 		while(__ticks)
 548               	.LM71:
 549 0180 01F4      		brne .L25
 550               	.LBE138:
 551               	.LBE139:
 553               	.Ltext5:
1411:iv.c          ****     // beeps are 200ms long on
1412:iv.c          ****     _delay_ms(200);
1413:iv.c          ****     TCCR1B &= ~_BV(CS11); // turn it off!
 555               	.LM72:
 556 0182 8091 8100 		lds r24,129
 557 0186 8D7F      		andi r24,lo8(-3)
 558 0188 8093 8100 		sts 129,r24
1414:iv.c          ****     PORTB &= ~_BV(SPK1) & ~_BV(SPK2);
 560               	.LM73:
 561 018c 85B1      		in r24,37-32
 562 018e 897F      		andi r24,lo8(-7)
 563 0190 85B9      		out 37-32,r24
 564 0192 80ED      		ldi r24,lo8(2000)
 565 0194 97E0      		ldi r25,hi8(2000)
 566               	.L26:
 567               	.LBB140:
 568               	.LBB141:
 569               	.LBB142:
 570               	.LBB143:
 572               	.Ltext6:
 574               	.LM74:
 575 0196 F901      		movw r30,r18
 576               	/* #APP */
 577               	 ;  105 "/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h" 1
 578 0198 3197      		1: sbiw r30,1
 579 019a 01F4      		brne 1b
 580               	 ;  0 "" 2
 581               	/* #NOAPP */
 582               	.LBE143:
 583               	.LBE142:
 585               	.Ltext7:
 587               	.LM75:
 588 019c 0197      		sbiw r24,1
 120:/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay.h **** 		while(__ticks)
 590               	.LM76:
 591 019e 01F4      		brne .L26
 592 01a0 1150      		subi r17,lo8(-(-1))
 593               	.L24:
 594               	.LBE141:
 595               	.LBE140:
 597               	.Ltext8:
1410:iv.c          ****   while (times--) {
 599               	.LM77:
 600 01a2 1123      		tst r17
 601 01a4 01F4      		brne .L27
1415:iv.c          ****     // beeps are 200ms long off
1416:iv.c          ****     _delay_ms(200);
1417:iv.c          ****   }
1418:iv.c          ****   // turn speaker off
1419:iv.c          ****   PORTB &= ~_BV(SPK1) & ~_BV(SPK2);
 603               	.LM78:
 604 01a6 85B1      		in r24,37-32
 605 01a8 897F      		andi r24,lo8(-7)
 606 01aa 85B9      		out 37-32,r24
 607               	/* epilogue start */
1420:iv.c          **** }
 609               	.LM79:
 610 01ac 1F91      		pop r17
 611 01ae 0895      		ret
 631               	.Lscope7:
 633               		.stabd	78,0,0
 635               	.global	dimmer_init
 637               	dimmer_init:
 638               		.stabd	46,0,0
1421:iv.c          **** 
1422:iv.c          **** 
1423:iv.c          **** #ifdef FEATURE_AUTODIM
1424:iv.c          **** /**************************** DIMMER ****************************/
1425:iv.c          **** void dimmer_init(void) {
 640               	.LM80:
 641               	.LFBB8:
 642               	/* prologue: function */
 643               	/* frame size = 0 */
1426:iv.c          ****   // Power for the photoresistor
1427:iv.c          ****   DIMMER_POWER_DDR |= _BV(DIMMER_POWER_PIN); 
 645               	.LM81:
 646 01b0 3D9A      		sbi 39-32,5
1428:iv.c          ****   DIMMER_POWER_PORT |= _BV(DIMMER_POWER_PIN);
 648               	.LM82:
 649 01b2 459A      		sbi 40-32,5
1429:iv.c          **** 
1430:iv.c          ****   ADCSRA |= _BV(ADPS2)| _BV(ADPS1); // Set ADC prescalar to 64 - 125KHz sample rate @ 8MHz F_CPU
 651               	.LM83:
 652 01b4 AAE7      		ldi r26,lo8(122)
 653 01b6 B0E0      		ldi r27,hi8(122)
 654 01b8 8C91      		ld r24,X
 655 01ba 8660      		ori r24,lo8(6)
 656 01bc 8C93      		st X,r24
1431:iv.c          ****   ADMUX |= _BV(REFS0);  // Set ADC reference to AVCC
 658               	.LM84:
 659 01be ECE7      		ldi r30,lo8(124)
 660 01c0 F0E0      		ldi r31,hi8(124)
 661 01c2 8081      		ld r24,Z
 662 01c4 8064      		ori r24,lo8(64)
 663 01c6 8083      		st Z,r24
1432:iv.c          ****   ADMUX |= _BV(DIMMER_SENSE_PIN);   // Set ADC input as ADC4 (PC4)
 665               	.LM85:
 666 01c8 8081      		ld r24,Z
 667 01ca 8460      		ori r24,lo8(4)
 668 01cc 8083      		st Z,r24
1433:iv.c          ****   DIDR0 |= _BV(DIMMER_SENSE_PIND); // Disable the digital imput buffer on the sense pin to save pow
 670               	.LM86:
 671 01ce EEE7      		ldi r30,lo8(126)
 672 01d0 F0E0      		ldi r31,hi8(126)
 673 01d2 8081      		ld r24,Z
 674 01d4 8061      		ori r24,lo8(16)
 675 01d6 8083      		st Z,r24
1434:iv.c          ****   ADCSRA |= _BV(ADEN);  // Enable ADC
 677               	.LM87:
 678 01d8 8C91      		ld r24,X
 679 01da 8068      		ori r24,lo8(-128)
 680 01dc 8C93      		st X,r24
1435:iv.c          ****   ADCSRA |= _BV(ADIE);  // Enable ADC interrupt
 682               	.LM88:
 683 01de 8C91      		ld r24,X
 684 01e0 8860      		ori r24,lo8(8)
 685 01e2 8C93      		st X,r24
 686               	/* epilogue start */
1436:iv.c          **** }
 688               	.LM89:
 689 01e4 0895      		ret
 691               	.Lscope8:
 693               		.stabd	78,0,0
 695               	.global	dimmer_update
 697               	dimmer_update:
 698               		.stabd	46,0,0
1437:iv.c          **** 
1438:iv.c          **** // Start ADC conversion for dimmer
1439:iv.c          **** void dimmer_update(void) {
 700               	.LM90:
 701               	.LFBB9:
 702               	/* prologue: function */
 703               	/* frame size = 0 */
1440:iv.c          ****   if (brightness_level == 0) 
 705               	.LM91:
 706 01e6 8091 0000 		lds r24,brightness_level
 707 01ea 8823      		tst r24
 708 01ec 01F4      		brne .L35
1441:iv.c          ****     ADCSRA |= _BV(ADSC);
 710               	.LM92:
 711 01ee 8091 7A00 		lds r24,122
 712 01f2 8064      		ori r24,lo8(64)
 713 01f4 8093 7A00 		sts 122,r24
 714               	.L35:
 715 01f8 0895      		ret
 717               	.Lscope9:
 719               		.stabd	78,0,0
 722               	.global	set_vfd_brightness
 724               	set_vfd_brightness:
 725               		.stabd	46,0,0
1442:iv.c          **** }
1443:iv.c          **** 
1444:iv.c          **** // Update brightness once ADC measurement completes
1445:iv.c          **** SIGNAL(SIG_ADC) {
1446:iv.c          ****   uint8_t low, high;
1447:iv.c          ****   unsigned int val;
1448:iv.c          ****   if (brightness_level != 0)
1449:iv.c          ****     return;
1450:iv.c          ****   // Read 2-byte value. Must read ADCL first because that locks the value.
1451:iv.c          ****   low = ADCL;
1452:iv.c          ****   high = ADCH;
1453:iv.c          ****   val = (high << 8) | low;
1454:iv.c          ****   // Set brightness to a value between min & max based on light reading.
1455:iv.c          ****   if (val >= PHOTOCELL_DARK) {
1456:iv.c          ****     val = PHOTOCELL_MIN;
1457:iv.c          ****   } else if (val <= PHOTOCELL_LIGHT) {
1458:iv.c          ****     val = PHOTOCELL_MAX;
1459:iv.c          ****   } else {
1460:iv.c          ****     val = PHOTOCELL_MAX - (((unsigned long)(PHOTOCELL_MAX - PHOTOCELL_MIN)) *
1461:iv.c          ****         (val - PHOTOCELL_LIGHT)) / (PHOTOCELL_DARK - PHOTOCELL_LIGHT);
1462:iv.c          ****   }
1463:iv.c          ****   set_vfd_brightness(val);
1464:iv.c          **** }
1465:iv.c          **** #endif
1466:iv.c          **** 
1467:iv.c          **** /**************************** BOOST *****************************/
1468:iv.c          **** 
1469:iv.c          **** // We control the boost converter by changing the PWM output
1470:iv.c          **** // pins
1471:iv.c          **** void boost_init(uint8_t brightness) {
1472:iv.c          **** 
1473:iv.c          ****   set_vfd_brightness(brightness);
1474:iv.c          **** 
1475:iv.c          ****   // fast PWM, set OC0A (boost output pin) on match
1476:iv.c          ****   TCCR0A = _BV(WGM00) | _BV(WGM01);  
1477:iv.c          **** 
1478:iv.c          ****   // Use the fastest clock
1479:iv.c          ****   TCCR0B = _BV(CS00);
1480:iv.c          ****  
1481:iv.c          ****   TCCR0A |= _BV(COM0A1);
1482:iv.c          ****   TIMSK0 |= _BV(TOIE0); // turn on the interrupt for muxing
1483:iv.c          ****   sei();
1484:iv.c          **** }
1485:iv.c          **** 
1486:iv.c          **** void set_vfd_brightness(uint8_t brightness) {
 727               	.LM93:
 728               	.LFBB10:
 729               	/* prologue: function */
 730               	/* frame size = 0 */
 731 01fa 982F      		mov r25,r24
1487:iv.c          ****   // Set PWM value, don't set it so high that
1488:iv.c          ****   // we could damage the MAX chip or display
1489:iv.c          ****   if (brightness > BRIGHTNESS_MAX)
 733               	.LM94:
 734 01fc 8B35      		cpi r24,lo8(91)
 735 01fe 00F0      		brlo .L37
 736 0200 9AE5      		ldi r25,lo8(90)
 737 0202 00C0      		rjmp .L38
 738               	.L37:
1490:iv.c          ****     brightness = BRIGHTNESS_MAX;
1491:iv.c          **** 
1492:iv.c          ****   // Or so low its not visible
1493:iv.c          ****   if (brightness < BRIGHTNESS_MIN)
 740               	.LM95:
 741 0204 8E31      		cpi r24,lo8(30)
 742 0206 00F4      		brsh .L38
 743 0208 9EE1      		ldi r25,lo8(30)
 744               	.L38:
1494:iv.c          ****     brightness = BRIGHTNESS_MIN;
1495:iv.c          **** 
1496:iv.c          ****   //// Round up to the next brightness increment
1497:iv.c          ****   //if (brightness % BRIGHTNESS_INCREMENT != 0) {
1498:iv.c          ****   //  brightness += BRIGHTNESS_INCREMENT - (brightness % BRIGHTNESS_INCREMENT);
1499:iv.c          ****   //}
1500:iv.c          **** 
1501:iv.c          ****   if (OCR0A == brightness)
 746               	.LM96:
 747 020a 87B5      		in r24,71-32
 748 020c 8913      		cpse r24,r25
1502:iv.c          ****     return;
1503:iv.c          **** 
1504:iv.c          ****   OCR0A = brightness;
 750               	.LM97:
 751 020e 97BD      		out 71-32,r25
 752               	.L40:
 753 0210 0895      		ret
 755               	.Lscope10:
 757               		.stabd	78,0,0
 760               	.global	boost_init
 762               	boost_init:
 763               		.stabd	46,0,0
1472:iv.c          **** void boost_init(uint8_t brightness) {
 765               	.LM98:
 766               	.LFBB11:
 767               	/* prologue: function */
 768               	/* frame size = 0 */
1474:iv.c          ****   set_vfd_brightness(brightness);
 770               	.LM99:
 771 0212 0E94 0000 		call set_vfd_brightness
1477:iv.c          ****   TCCR0A = _BV(WGM00) | _BV(WGM01);  
 773               	.LM100:
 774 0216 83E0      		ldi r24,lo8(3)
 775 0218 84BD      		out 68-32,r24
1480:iv.c          ****   TCCR0B = _BV(CS00);
 777               	.LM101:
 778 021a 81E0      		ldi r24,lo8(1)
 779 021c 85BD      		out 69-32,r24
1482:iv.c          ****   TCCR0A |= _BV(COM0A1);
 781               	.LM102:
 782 021e 84B5      		in r24,68-32
 783 0220 8068      		ori r24,lo8(-128)
 784 0222 84BD      		out 68-32,r24
1483:iv.c          ****   TIMSK0 |= _BV(TOIE0); // turn on the interrupt for muxing
 786               	.LM103:
 787 0224 EEE6      		ldi r30,lo8(110)
 788 0226 F0E0      		ldi r31,hi8(110)
 789 0228 8081      		ld r24,Z
 790 022a 8160      		ori r24,lo8(1)
 791 022c 8083      		st Z,r24
1484:iv.c          ****   sei();
 793               	.LM104:
 794               	/* #APP */
 795               	 ;  1484 "iv.c" 1
 796 022e 7894      		sei
 797               	 ;  0 "" 2
 798               	/* epilogue start */
1485:iv.c          **** }
 800               	.LM105:
 801               	/* #NOAPP */
 802 0230 0895      		ret
 804               	.Lscope11:
 806               		.stabd	78,0,0
 808               	.global	__vector_21
 810               	__vector_21:
 811               		.stabd	46,0,0
1446:iv.c          **** SIGNAL(SIG_ADC) {
 813               	.LM106:
 814               	.LFBB12:
 815 0232 1F92      		push __zero_reg__
 816 0234 0F92      		push r0
 817 0236 0FB6      		in r0,__SREG__
 818 0238 0F92      		push r0
 819 023a 1124      		clr __zero_reg__
 820 023c 2F93      		push r18
 821 023e 3F93      		push r19
 822 0240 4F93      		push r20
 823 0242 5F93      		push r21
 824 0244 6F93      		push r22
 825 0246 7F93      		push r23
 826 0248 8F93      		push r24
 827 024a 9F93      		push r25
 828 024c AF93      		push r26
 829 024e BF93      		push r27
 830 0250 EF93      		push r30
 831 0252 FF93      		push r31
 832               	/* prologue: Signal */
 833               	/* frame size = 0 */
1449:iv.c          ****   if (brightness_level != 0)
 835               	.LM107:
 836 0254 8091 0000 		lds r24,brightness_level
 837 0258 8823      		tst r24
 838 025a 01F4      		brne .L48
1452:iv.c          ****   low = ADCL;
 840               	.LM108:
 841 025c 3091 7800 		lds r19,120
1453:iv.c          ****   high = ADCH;
 843               	.LM109:
 844 0260 2091 7900 		lds r18,121
1454:iv.c          ****   val = (high << 8) | low;
 846               	.LM110:
 847 0264 922F      		mov r25,r18
 848 0266 80E0      		ldi r24,lo8(0)
 849 0268 632F      		mov r22,r19
 850 026a 70E0      		ldi r23,lo8(0)
 851 026c 682B      		or r22,r24
 852 026e 792B      		or r23,r25
1456:iv.c          ****   if (val >= PHOTOCELL_DARK) {
 854               	.LM111:
 855 0270 83E0      		ldi r24,hi8(1023)
 856 0272 6F3F      		cpi r22,lo8(1023)
 857 0274 7807      		cpc r23,r24
 858 0276 00F0      		brlo .L45
 859 0278 8DE2      		ldi r24,lo8(45)
 860 027a 90E0      		ldi r25,hi8(45)
 861 027c 00C0      		rjmp .L46
 862               	.L45:
1458:iv.c          ****   } else if (val <= PHOTOCELL_LIGHT) {
 864               	.LM112:
 865 027e 82E0      		ldi r24,hi8(601)
 866 0280 6935      		cpi r22,lo8(601)
 867 0282 7807      		cpc r23,r24
 868 0284 00F4      		brsh .L47
 869 0286 8AE5      		ldi r24,lo8(90)
 870 0288 90E0      		ldi r25,hi8(90)
 871 028a 00C0      		rjmp .L46
 872               	.L47:
1461:iv.c          ****     val = PHOTOCELL_MAX - (((unsigned long)(PHOTOCELL_MAX - PHOTOCELL_MIN)) *
 874               	.LM113:
 875 028c 6855      		subi r22,lo8(-(-600))
 876 028e 7240      		sbci r23,hi8(-(-600))
 877 0290 80E0      		ldi r24,lo8(0)
 878 0292 90E0      		ldi r25,hi8(0)
 879 0294 2DE2      		ldi r18,lo8(45)
 880 0296 30E0      		ldi r19,hi8(45)
 881 0298 40E0      		ldi r20,hlo8(45)
 882 029a 50E0      		ldi r21,hhi8(45)
 883 029c 0E94 0000 		call __mulsi3
 884 02a0 27EA      		ldi r18,lo8(423)
 885 02a2 31E0      		ldi r19,hi8(423)
 886 02a4 40E0      		ldi r20,hlo8(423)
 887 02a6 50E0      		ldi r21,hhi8(423)
 888 02a8 0E94 0000 		call __udivmodsi4
 889 02ac 8AE5      		ldi r24,lo8(90)
 890 02ae 90E0      		ldi r25,hi8(90)
 891 02b0 821B      		sub r24,r18
 892 02b2 930B      		sbc r25,r19
 893               	.L46:
1464:iv.c          ****   set_vfd_brightness(val);
 895               	.LM114:
 896 02b4 0E94 0000 		call set_vfd_brightness
 897               	.L48:
 898               	/* epilogue start */
1465:iv.c          **** }
 900               	.LM115:
 901 02b8 FF91      		pop r31
 902 02ba EF91      		pop r30
 903 02bc BF91      		pop r27
 904 02be AF91      		pop r26
 905 02c0 9F91      		pop r25
 906 02c2 8F91      		pop r24
 907 02c4 7F91      		pop r23
 908 02c6 6F91      		pop r22
 909 02c8 5F91      		pop r21
 910 02ca 4F91      		pop r20
 911 02cc 3F91      		pop r19
 912 02ce 2F91      		pop r18
 913 02d0 0F90      		pop r0
 914 02d2 0FBE      		out __SREG__,r0
 915 02d4 0F90      		pop r0
 916 02d6 1F90      		pop __zero_reg__
 917 02d8 1895      		reti
 924               	.Lscope12:
 926               		.stabd	78,0,0
 929               	.global	display_brightness
 931               	display_brightness:
 932               		.stabd	46,0,0
1094:iv.c          **** void display_brightness(int brightness) {
 934               	.LM116:
 935               	.LFBB13:
 936               	/* prologue: function */
 937               	/* frame size = 0 */
 938 02da 9C01      		movw r18,r24
1096:iv.c          ****   if (brightness == 0) {
 940               	.LM117:
 941 02dc 0097      		sbiw r24,0
 942 02de 01F4      		brne .L50
 943               	.LBB144:
1098:iv.c          ****     display[7] =  pgm_read_byte(alphatable_p + 'a' - 'a') | 0x1;
 945               	.LM118:
 946 02e0 E0E0      		ldi r30,lo8(alphatable)
 947 02e2 F0E0      		ldi r31,hi8(alphatable)
 948               	/* #APP */
 949               	 ;  1098 "iv.c" 1
 950 02e4 8491      		lpm r24, Z
 951               		
 952               	 ;  0 "" 2
 953               	/* #NOAPP */
 954               	.LBE144:
 955 02e6 8160      		ori r24,lo8(1)
 956 02e8 8093 0000 		sts display+7,r24
 957               	.LBB145:
1099:iv.c          ****     display[8] =  pgm_read_byte(alphatable_p + 'u' - 'a') | 0x1;
 959               	.LM119:
 960 02ec 7496      		adiw r30,20
 961               	/* #APP */
 962               	 ;  1099 "iv.c" 1
 963 02ee E491      		lpm r30, Z
 964               		
 965               	 ;  0 "" 2
 966               	/* #NOAPP */
 967               	.LBE145:
 968 02f0 E160      		ori r30,lo8(1)
 969 02f2 E093 0000 		sts display+8,r30
 970               	.LBB146:
 971               	.LBB147:
1441:iv.c          ****   if (brightness_level == 0) 
 973               	.LM120:
 974 02f6 8091 0000 		lds r24,brightness_level
 975 02fa 8823      		tst r24
 976 02fc 01F4      		brne .L52
1442:iv.c          ****     ADCSRA |= _BV(ADSC);
 978               	.LM121:
 979 02fe 8091 7A00 		lds r24,122
 980 0302 8064      		ori r24,lo8(64)
 981 0304 8093 7A00 		sts 122,r24
 982 0308 0895      		ret
 983               	.L50:
 984               	.LBE147:
 985               	.LBE146:
 986               	.LBB148:
1104:iv.c          ****   display[7] = pgm_read_byte(numbertable_p + (brightness / 10)) | 0x1;
 988               	.LM122:
 989 030a 6AE0      		ldi r22,lo8(10)
 990 030c 70E0      		ldi r23,hi8(10)
 991 030e 0E94 0000 		call __divmodhi4
 992 0312 FB01      		movw r30,r22
 993 0314 E050      		subi r30,lo8(-(numbertable))
 994 0316 F040      		sbci r31,hi8(-(numbertable))
 995               	/* #APP */
 996               	 ;  1104 "iv.c" 1
 997 0318 E491      		lpm r30, Z
 998               		
 999               	 ;  0 "" 2
 1000               	/* #NOAPP */
 1001               	.LBE148:
 1002 031a E160      		ori r30,lo8(1)
 1003 031c E093 0000 		sts display+7,r30
 1004               	.LBB149:
1105:iv.c          ****   display[8] = pgm_read_byte(numbertable_p + (brightness % 10)) | 0x1;
 1006               	.LM123:
 1007 0320 C901      		movw r24,r18
 1008 0322 6AE0      		ldi r22,lo8(10)
 1009 0324 70E0      		ldi r23,hi8(10)
 1010 0326 0E94 0000 		call __divmodhi4
 1011 032a FC01      		movw r30,r24
 1012 032c E050      		subi r30,lo8(-(numbertable))
 1013 032e F040      		sbci r31,hi8(-(numbertable))
 1014               	/* #APP */
 1015               	 ;  1105 "iv.c" 1
 1016 0330 E491      		lpm r30, Z
 1017               		
 1018               	 ;  0 "" 2
 1019               	/* #NOAPP */
 1020               	.LBE149:
 1021 0332 E160      		ori r30,lo8(1)
 1022 0334 E093 0000 		sts display+8,r30
1106:iv.c          ****   set_vfd_brightness(brightness);
 1024               	.LM124:
 1025 0338 822F      		mov r24,r18
 1026 033a 0E94 0000 		call set_vfd_brightness
 1027               	.L52:
 1028 033e 0895      		ret
 1042               	.Lscope13:
 1044               		.stabd	78,0,0
 1049               	.global	display_time
 1051               	display_time:
 1052               		.stabd	46,0,0
1505:iv.c          **** }
1506:iv.c          **** 
1507:iv.c          **** /**************************** DISPLAY *****************************/
1508:iv.c          **** 
1509:iv.c          **** // We can display the current date!
1510:iv.c          **** void display_date(uint8_t style) {
1511:iv.c          **** 
1512:iv.c          ****   // This type is mm-dd-yy OR dd-mm-yy depending on our pref.
1513:iv.c          ****   if (style == DATE) {
1514:iv.c          ****     display[0] = 0;
1515:iv.c          ****     display[6] = display[3] = 0x02;     // put dashes between num
1516:iv.c          **** 
1517:iv.c          ****     if (region == REGION_US) {
1518:iv.c          ****       // mm-dd-yy
1519:iv.c          ****       display[1] = pgm_read_byte(numbertable_p + (date_m / 10));
1520:iv.c          ****       display[2] = pgm_read_byte(numbertable_p + (date_m % 10));
1521:iv.c          ****       display[4] = pgm_read_byte(numbertable_p + (date_d / 10));
1522:iv.c          ****       display[5] = pgm_read_byte(numbertable_p + (date_d % 10));
1523:iv.c          ****     } else {
1524:iv.c          ****       // dd-mm-yy
1525:iv.c          ****       display[1] = pgm_read_byte(numbertable_p + (date_d / 10));
1526:iv.c          ****       display[2] = pgm_read_byte(numbertable_p + (date_d % 10));
1527:iv.c          ****       display[4] = pgm_read_byte(numbertable_p + (date_m / 10));
1528:iv.c          ****       display[5] = pgm_read_byte(numbertable_p + (date_m % 10));
1529:iv.c          ****     }
1530:iv.c          ****     // the yy part is the same
1531:iv.c          ****     display[7] = pgm_read_byte(numbertable_p + (date_y / 10));
1532:iv.c          ****     display[8] = pgm_read_byte(numbertable_p + (date_y % 10));
1533:iv.c          **** 
1534:iv.c          ****   } else if (style == DAY) {
1535:iv.c          ****     // This is more "Sunday June 21" style
1536:iv.c          **** 
1537:iv.c          ****     uint16_t month, year;
1538:iv.c          ****     uint8_t dotw;
1539:iv.c          **** 
1540:iv.c          ****     // Calculate day of the week
1541:iv.c          ****     
1542:iv.c          ****     month = date_m;
1543:iv.c          ****     year = 2000 + date_y;
1544:iv.c          ****     if (date_m < 3)  {
1545:iv.c          ****       month += 12;
1546:iv.c          ****       year -= 1;
1547:iv.c          ****     }
1548:iv.c          ****     dotw = (date_d + (2 * month) + (6 * (month+1)/10) + year + (year/4) - (year/100) + (year/400) +
1549:iv.c          **** 
1550:iv.c          ****     // Display the day first
1551:iv.c          ****     display[8] = display[7] = 0;
1552:iv.c          ****     switch (dotw) {
1553:iv.c          ****     case 0:
1554:iv.c          ****       display_str("sunday"); break;
1555:iv.c          ****     case 1:
1556:iv.c          ****       display_str("monday"); break;
1557:iv.c          ****     case 2:
1558:iv.c          ****       display_str("tuesday"); break;
1559:iv.c          ****     case 3:
1560:iv.c          ****       display_str("wednsday"); break;
1561:iv.c          ****     case 4:
1562:iv.c          ****       display_str("thursday"); break;
1563:iv.c          ****     case 5:
1564:iv.c          ****       display_str("friday"); break;
1565:iv.c          ****     case 6:
1566:iv.c          ****       display_str("saturday"); break;
1567:iv.c          ****     }
1568:iv.c          ****     
1569:iv.c          ****     // wait one seconds about
1570:iv.c          ****     delayms(1000);
1571:iv.c          **** 
1572:iv.c          ****     // Then display the month and date
1573:iv.c          ****     display[6] = display[5] = display[4] = 0;
1574:iv.c          ****     switch (date_m) {
1575:iv.c          ****     case 1:
1576:iv.c          ****       display_str("jan"); break;
1577:iv.c          ****     case 2:
1578:iv.c          ****       display_str("feb"); break;
1579:iv.c          ****     case 3:
1580:iv.c          ****       display_str("march"); break;
1581:iv.c          ****     case 4:
1582:iv.c          ****       display_str("april"); break;
1583:iv.c          ****     case 5:
1584:iv.c          ****       display_str("may"); break;
1585:iv.c          ****     case 6:
1586:iv.c          ****       display_str("june"); break;
1587:iv.c          ****     case 7:
1588:iv.c          ****       display_str("july"); break;
1589:iv.c          ****     case 8:
1590:iv.c          ****       display_str("augst"); break;
1591:iv.c          ****     case 9:
1592:iv.c          ****       display_str("sept"); break;
1593:iv.c          ****     case 10:
1594:iv.c          ****       display_str("octob"); break;
1595:iv.c          ****     case 11:
1596:iv.c          ****       display_str("novem"); break;
1597:iv.c          ****     case 12:
1598:iv.c          ****       display_str("decem"); break;
1599:iv.c          ****     }
1600:iv.c          ****     display[7] = pgm_read_byte(numbertable_p + (date_d / 10));
1601:iv.c          ****     display[8] = pgm_read_byte(numbertable_p + (date_d % 10));
1602:iv.c          ****     
1603:iv.c          ****   }
1604:iv.c          **** }
1605:iv.c          **** 
1606:iv.c          **** // This displays a time on the clock
1607:iv.c          **** void display_time(uint8_t h, uint8_t m, uint8_t s) {
 1054               	.LM125:
 1055               	.LFBB14:
 1056 0340 1F93      		push r17
 1057               	/* prologue: function */
 1058               	/* frame size = 0 */
 1059 0342 182F      		mov r17,r24
 1060 0344 262F      		mov r18,r22
 1061               	.LBB150:
1608:iv.c          ****   
1609:iv.c          ****   // seconds and minutes are at the end
1610:iv.c          ****   display[8] =  pgm_read_byte(numbertable_p + (s % 10));
 1063               	.LM126:
 1064 0346 842F      		mov r24,r20
 1065 0348 6AE0      		ldi r22,lo8(10)
 1066 034a 0E94 0000 		call __udivmodqi4
 1067 034e E92F      		mov r30,r25
 1068 0350 F0E0      		ldi r31,lo8(0)
 1069 0352 E050      		subi r30,lo8(-(numbertable))
 1070 0354 F040      		sbci r31,hi8(-(numbertable))
 1071               	/* #APP */
 1072               	 ;  1611 "iv.c" 1
 1073 0356 E491      		lpm r30, Z
 1074               		
 1075               	 ;  0 "" 2
 1076               	/* #NOAPP */
 1077               	.LBE150:
 1078 0358 E093 0000 		sts display+8,r30
 1079               	.LBB151:
1611:iv.c          ****   display[7] =  pgm_read_byte(numbertable_p + (s / 10));
 1081               	.LM127:
 1082 035c 842F      		mov r24,r20
 1083 035e 0E94 0000 		call __udivmodqi4
 1084 0362 E82F      		mov r30,r24
 1085 0364 F0E0      		ldi r31,lo8(0)
 1086 0366 E050      		subi r30,lo8(-(numbertable))
 1087 0368 F040      		sbci r31,hi8(-(numbertable))
 1088               	/* #APP */
 1089               	 ;  1612 "iv.c" 1
 1090 036a E491      		lpm r30, Z
 1091               		
 1092               	 ;  0 "" 2
 1093               	/* #NOAPP */
 1094               	.LBE151:
 1095 036c E093 0000 		sts display+7,r30
1612:iv.c          ****   display[6] = 0;
 1097               	.LM128:
 1098 0370 1092 0000 		sts display+6,__zero_reg__
 1099               	.LBB152:
1613:iv.c          ****   display[5] =  pgm_read_byte(numbertable_p + (m % 10));
 1101               	.LM129:
 1102 0374 822F      		mov r24,r18
 1103 0376 0E94 0000 		call __udivmodqi4
 1104 037a E92F      		mov r30,r25
 1105 037c F0E0      		ldi r31,lo8(0)
 1106 037e E050      		subi r30,lo8(-(numbertable))
 1107 0380 F040      		sbci r31,hi8(-(numbertable))
 1108               	/* #APP */
 1109               	 ;  1614 "iv.c" 1
 1110 0382 E491      		lpm r30, Z
 1111               		
 1112               	 ;  0 "" 2
 1113               	/* #NOAPP */
 1114               	.LBE152:
 1115 0384 E093 0000 		sts display+5,r30
 1116               	.LBB153:
1614:iv.c          ****   display[4] =  pgm_read_byte(numbertable_p + (m / 10)); 
 1118               	.LM130:
 1119 0388 822F      		mov r24,r18
 1120 038a 0E94 0000 		call __udivmodqi4
 1121 038e E82F      		mov r30,r24
 1122 0390 F0E0      		ldi r31,lo8(0)
 1123 0392 E050      		subi r30,lo8(-(numbertable))
 1124 0394 F040      		sbci r31,hi8(-(numbertable))
 1125               	/* #APP */
 1126               	 ;  1615 "iv.c" 1
 1127 0396 E491      		lpm r30, Z
 1128               		
 1129               	 ;  0 "" 2
 1130               	/* #NOAPP */
 1131               	.LBE153:
 1132 0398 E093 0000 		sts display+4,r30
1615:iv.c          ****   display[3] = 0;
 1134               	.LM131:
 1135 039c 1092 0000 		sts display+3,__zero_reg__
1616:iv.c          **** 
1617:iv.c          ****   // check euro (24h) or US (12h) style time
1618:iv.c          ****   if (region == REGION_US) {
 1137               	.LM132:
 1138 03a0 8091 0000 		lds r24,region
 1139 03a4 8823      		tst r24
 1140 03a6 01F4      		brne .L54
 1141               	.LBB154:
1619:iv.c          ****     display[2] =  pgm_read_byte(numbertable_p + ( (((h+11)%12)+1) % 10));
 1143               	.LM133:
 1144 03a8 812F      		mov r24,r17
 1145 03aa 90E0      		ldi r25,lo8(0)
 1146 03ac 0B96      		adiw r24,11
 1147 03ae 6CE0      		ldi r22,lo8(12)
 1148 03b0 70E0      		ldi r23,hi8(12)
 1149 03b2 0E94 0000 		call __divmodhi4
 1150 03b6 9C01      		movw r18,r24
 1151 03b8 2F5F      		subi r18,lo8(-(1))
 1152 03ba 3F4F      		sbci r19,hi8(-(1))
 1153 03bc C901      		movw r24,r18
 1154 03be 6AE0      		ldi r22,lo8(10)
 1155 03c0 70E0      		ldi r23,hi8(10)
 1156 03c2 0E94 0000 		call __divmodhi4
 1157 03c6 FC01      		movw r30,r24
 1158 03c8 E050      		subi r30,lo8(-(numbertable))
 1159 03ca F040      		sbci r31,hi8(-(numbertable))
 1160               	/* #APP */
 1161               	 ;  1620 "iv.c" 1
 1162 03cc E491      		lpm r30, Z
 1163               		
 1164               	 ;  0 "" 2
 1165               	/* #NOAPP */
 1166               	.LBE154:
 1167 03ce E093 0000 		sts display+2,r30
 1168               	.LBB155:
1620:iv.c          ****     display[1] =  pgm_read_byte(numbertable_p + ( (((h+11)%12)+1) / 10));
 1170               	.LM134:
 1171 03d2 C901      		movw r24,r18
 1172 03d4 6AE0      		ldi r22,lo8(10)
 1173 03d6 70E0      		ldi r23,hi8(10)
 1174 03d8 0E94 0000 		call __divmodhi4
 1175 03dc FB01      		movw r30,r22
 1176 03de E050      		subi r30,lo8(-(numbertable))
 1177 03e0 F040      		sbci r31,hi8(-(numbertable))
 1178               	/* #APP */
 1179               	 ;  1621 "iv.c" 1
 1180 03e2 E491      		lpm r30, Z
 1181               		
 1182               	 ;  0 "" 2
 1183               	/* #NOAPP */
 1184               	.LBE155:
 1185 03e4 E093 0000 		sts display+1,r30
1621:iv.c          **** 
1622:iv.c          ****     // We use the '*' as an am/pm notice
1623:iv.c          ****     if (h >= 12)
 1187               	.LM135:
 1188 03e8 1C30      		cpi r17,lo8(12)
 1189 03ea 00F0      		brlo .L55
1624:iv.c          ****       display[0] |= 0x1;  // 'pm' notice
 1191               	.LM136:
 1192 03ec 8091 0000 		lds r24,display
 1193 03f0 8160      		ori r24,lo8(1)
 1194 03f2 00C0      		rjmp .L58
 1195               	.L55:
1625:iv.c          ****     else 
1626:iv.c          ****       display[0] &= ~0x1;  // 'pm' notice
 1197               	.LM137:
 1198 03f4 8091 0000 		lds r24,display
 1199 03f8 8E7F      		andi r24,lo8(-2)
 1200               	.L58:
 1201 03fa 8093 0000 		sts display,r24
 1202 03fe 00C0      		rjmp .L57
 1203               	.L54:
 1204               	.LBB156:
1627:iv.c          ****   } else {
1628:iv.c          ****     display[2] =  pgm_read_byte(numbertable_p + ( (h%24) % 10));
 1206               	.LM138:
 1207 0400 812F      		mov r24,r17
 1208 0402 68E1      		ldi r22,lo8(24)
 1209 0404 0E94 0000 		call __udivmodqi4
 1210 0408 292F      		mov r18,r25
 1211 040a 892F      		mov r24,r25
 1212 040c 6AE0      		ldi r22,lo8(10)
 1213 040e 0E94 0000 		call __udivmodqi4
 1214 0412 E92F      		mov r30,r25
 1215 0414 F0E0      		ldi r31,lo8(0)
 1216 0416 E050      		subi r30,lo8(-(numbertable))
 1217 0418 F040      		sbci r31,hi8(-(numbertable))
 1218               	/* #APP */
 1219               	 ;  1629 "iv.c" 1
 1220 041a E491      		lpm r30, Z
 1221               		
 1222               	 ;  0 "" 2
 1223               	/* #NOAPP */
 1224               	.LBE156:
 1225 041c E093 0000 		sts display+2,r30
 1226               	.LBB157:
1629:iv.c          ****     display[1] =  pgm_read_byte(numbertable_p + ( (h%24) / 10));
 1228               	.LM139:
 1229 0420 822F      		mov r24,r18
 1230 0422 0E94 0000 		call __udivmodqi4
 1231 0426 E82F      		mov r30,r24
 1232 0428 F0E0      		ldi r31,lo8(0)
 1233 042a E050      		subi r30,lo8(-(numbertable))
 1234 042c F040      		sbci r31,hi8(-(numbertable))
 1235               	/* #APP */
 1236               	 ;  1630 "iv.c" 1
 1237 042e E491      		lpm r30, Z
 1238               		
 1239               	 ;  0 "" 2
 1240               	/* #NOAPP */
 1241               	.LBE157:
 1242 0430 E093 0000 		sts display+1,r30
 1243               	.L57:
 1244               	/* epilogue start */
1630:iv.c          ****   }
1631:iv.c          **** }
 1246               	.LM140:
 1247 0434 1F91      		pop r17
 1248 0436 0895      		ret
 1274               	.Lscope14:
 1276               		.stabd	78,0,0
 1280               	.global	display_alarm
 1282               	display_alarm:
 1283               		.stabd	46,0,0
1632:iv.c          **** 
1633:iv.c          **** // Kinda like display_time but just hours and minutes
1634:iv.c          **** void display_alarm(uint8_t h, uint8_t m){ 
 1285               	.LM141:
 1286               	.LFBB15:
 1287               	/* prologue: function */
 1288               	/* frame size = 0 */
 1289 0438 382F      		mov r19,r24
 1290 043a 262F      		mov r18,r22
1635:iv.c          ****   display[8] = 0;
 1292               	.LM142:
 1293 043c 1092 0000 		sts display+8,__zero_reg__
1636:iv.c          ****   display[7] = 0;
 1295               	.LM143:
 1296 0440 1092 0000 		sts display+7,__zero_reg__
1637:iv.c          ****   display[6] = 0;
 1298               	.LM144:
 1299 0444 1092 0000 		sts display+6,__zero_reg__
 1300               	.LBB158:
1638:iv.c          ****   display[5] = pgm_read_byte(numbertable_p + (m % 10));
 1302               	.LM145:
 1303 0448 862F      		mov r24,r22
 1304 044a 6AE0      		ldi r22,lo8(10)
 1305 044c 0E94 0000 		call __udivmodqi4
 1306 0450 E92F      		mov r30,r25
 1307 0452 F0E0      		ldi r31,lo8(0)
 1308 0454 E050      		subi r30,lo8(-(numbertable))
 1309 0456 F040      		sbci r31,hi8(-(numbertable))
 1310               	/* #APP */
 1311               	 ;  1639 "iv.c" 1
 1312 0458 E491      		lpm r30, Z
 1313               		
 1314               	 ;  0 "" 2
 1315               	/* #NOAPP */
 1316               	.LBE158:
 1317 045a E093 0000 		sts display+5,r30
 1318               	.LBB159:
1639:iv.c          ****   display[4] = pgm_read_byte(numbertable_p + (m / 10)); 
 1320               	.LM146:
 1321 045e 822F      		mov r24,r18
 1322 0460 0E94 0000 		call __udivmodqi4
 1323 0464 E82F      		mov r30,r24
 1324 0466 F0E0      		ldi r31,lo8(0)
 1325 0468 E050      		subi r30,lo8(-(numbertable))
 1326 046a F040      		sbci r31,hi8(-(numbertable))
 1327               	/* #APP */
 1328               	 ;  1640 "iv.c" 1
 1329 046c E491      		lpm r30, Z
 1330               		
 1331               	 ;  0 "" 2
 1332               	/* #NOAPP */
 1333               	.LBE159:
 1334 046e E093 0000 		sts display+4,r30
1640:iv.c          ****   display[3] = 0;
 1336               	.LM147:
 1337 0472 1092 0000 		sts display+3,__zero_reg__
1641:iv.c          **** 
1642:iv.c          ****   // check euro or US style time
1643:iv.c          ****   if (region == REGION_US) {
 1339               	.LM148:
 1340 0476 8091 0000 		lds r24,region
 1341 047a 8823      		tst r24
 1342 047c 01F0      		breq .+2
 1343 047e 00C0      		rjmp .L60
1644:iv.c          ****     if (h >= 12) {
 1345               	.LM149:
 1346 0480 3C30      		cpi r19,lo8(12)
 1347 0482 00F0      		brlo .L61
1645:iv.c          ****       display[0] |= 0x1;  // 'pm' notice
 1349               	.LM150:
 1350 0484 8091 0000 		lds r24,display
 1351 0488 8160      		ori r24,lo8(1)
 1352 048a 8093 0000 		sts display,r24
 1353               	.LBB160:
1646:iv.c          ****       display[7] = pgm_read_byte(alphatable_p + 'p' - 'a');
 1355               	.LM151:
 1356 048e E0E0      		ldi r30,lo8(alphatable+15)
 1357 0490 F0E0      		ldi r31,hi8(alphatable+15)
 1358               	/* #APP */
 1359               	 ;  1647 "iv.c" 1
 1360 0492 E491      		lpm r30, Z
 1361               		
 1362               	 ;  0 "" 2
 1363               	/* #NOAPP */
 1364               	.LBE160:
 1365 0494 E093 0000 		sts display+7,r30
 1366 0498 00C0      		rjmp .L62
 1367               	.L61:
 1368               	.LBB161:
1647:iv.c          ****     } else {
1648:iv.c          ****       display[7] = pgm_read_byte(alphatable_p + 'a' - 'a');
 1370               	.LM152:
 1371 049a E0E0      		ldi r30,lo8(alphatable)
 1372 049c F0E0      		ldi r31,hi8(alphatable)
 1373               	/* #APP */
 1374               	 ;  1649 "iv.c" 1
 1375 049e E491      		lpm r30, Z
 1376               		
 1377               	 ;  0 "" 2
 1378               	/* #NOAPP */
 1379               	.LBE161:
 1380 04a0 E093 0000 		sts display+7,r30
1649:iv.c          ****       display[0] &= ~0x1;  // 'am' notice
 1382               	.LM153:
 1383 04a4 8091 0000 		lds r24,display
 1384 04a8 8E7F      		andi r24,lo8(-2)
 1385 04aa 8093 0000 		sts display,r24
 1386               	.L62:
 1387               	.LBB162:
1650:iv.c          ****     }
1651:iv.c          ****     display[8] = pgm_read_byte(alphatable_p + 'm' - 'a');
 1389               	.LM154:
 1390 04ae E0E0      		ldi r30,lo8(alphatable+12)
 1391 04b0 F0E0      		ldi r31,hi8(alphatable+12)
 1392               	/* #APP */
 1393               	 ;  1652 "iv.c" 1
 1394 04b2 E491      		lpm r30, Z
 1395               		
 1396               	 ;  0 "" 2
 1397               	/* #NOAPP */
 1398               	.LBE162:
 1399 04b4 E093 0000 		sts display+8,r30
 1400               	.LBB163:
1652:iv.c          **** 
1653:iv.c          ****     display[2] =  pgm_read_byte(numbertable_p + ( (((h+11)%12)+1) % 10));
 1402               	.LM155:
 1403 04b8 832F      		mov r24,r19
 1404 04ba 90E0      		ldi r25,lo8(0)
 1405 04bc 0B96      		adiw r24,11
 1406 04be 6CE0      		ldi r22,lo8(12)
 1407 04c0 70E0      		ldi r23,hi8(12)
 1408 04c2 0E94 0000 		call __divmodhi4
 1409 04c6 9C01      		movw r18,r24
 1410 04c8 2F5F      		subi r18,lo8(-(1))
 1411 04ca 3F4F      		sbci r19,hi8(-(1))
 1412 04cc C901      		movw r24,r18
 1413 04ce 6AE0      		ldi r22,lo8(10)
 1414 04d0 70E0      		ldi r23,hi8(10)
 1415 04d2 0E94 0000 		call __divmodhi4
 1416 04d6 FC01      		movw r30,r24
 1417 04d8 E050      		subi r30,lo8(-(numbertable))
 1418 04da F040      		sbci r31,hi8(-(numbertable))
 1419               	/* #APP */
 1420               	 ;  1654 "iv.c" 1
 1421 04dc E491      		lpm r30, Z
 1422               		
 1423               	 ;  0 "" 2
 1424               	/* #NOAPP */
 1425               	.LBE163:
 1426 04de E093 0000 		sts display+2,r30
 1427               	.LBB164:
1654:iv.c          ****     display[1] =  pgm_read_byte(numbertable_p + ( (((h+11)%12)+1) / 10));
 1429               	.LM156:
 1430 04e2 C901      		movw r24,r18
 1431 04e4 6AE0      		ldi r22,lo8(10)
 1432 04e6 70E0      		ldi r23,hi8(10)
 1433 04e8 0E94 0000 		call __divmodhi4
 1434 04ec FB01      		movw r30,r22
 1435 04ee E050      		subi r30,lo8(-(numbertable))
 1436 04f0 F040      		sbci r31,hi8(-(numbertable))
 1437               	/* #APP */
 1438               	 ;  1655 "iv.c" 1
 1439 04f2 E491      		lpm r30, Z
 1440               		
 1441               	 ;  0 "" 2
 1442               	/* #NOAPP */
 1443 04f4 00C0      		rjmp .L65
 1444               	.L60:
 1445               	.LBE164:
 1446               	.LBB165:
1655:iv.c          ****   } else {
1656:iv.c          ****       display[2] =  pgm_read_byte(numbertable_p + ( (((h+23)%24)+1) % 10));
 1448               	.LM157:
 1449 04f6 832F      		mov r24,r19
 1450 04f8 90E0      		ldi r25,lo8(0)
 1451 04fa 4796      		adiw r24,23
 1452 04fc 68E1      		ldi r22,lo8(24)
 1453 04fe 70E0      		ldi r23,hi8(24)
 1454 0500 0E94 0000 		call __divmodhi4
 1455 0504 9C01      		movw r18,r24
 1456 0506 2F5F      		subi r18,lo8(-(1))
 1457 0508 3F4F      		sbci r19,hi8(-(1))
 1458 050a C901      		movw r24,r18
 1459 050c 6AE0      		ldi r22,lo8(10)
 1460 050e 70E0      		ldi r23,hi8(10)
 1461 0510 0E94 0000 		call __divmodhi4
 1462 0514 FC01      		movw r30,r24
 1463 0516 E050      		subi r30,lo8(-(numbertable))
 1464 0518 F040      		sbci r31,hi8(-(numbertable))
 1465               	/* #APP */
 1466               	 ;  1657 "iv.c" 1
 1467 051a E491      		lpm r30, Z
 1468               		
 1469               	 ;  0 "" 2
 1470               	/* #NOAPP */
 1471               	.LBE165:
 1472 051c E093 0000 		sts display+2,r30
 1473               	.LBB166:
1657:iv.c          ****     display[1] =  pgm_read_byte(numbertable_p + ( (((h+23)%24)+1) / 10));
 1475               	.LM158:
 1476 0520 C901      		movw r24,r18
 1477 0522 6AE0      		ldi r22,lo8(10)
 1478 0524 70E0      		ldi r23,hi8(10)
 1479 0526 0E94 0000 		call __divmodhi4
 1480 052a FB01      		movw r30,r22
 1481 052c E050      		subi r30,lo8(-(numbertable))
 1482 052e F040      		sbci r31,hi8(-(numbertable))
 1483               	/* #APP */
 1484               	 ;  1658 "iv.c" 1
 1485 0530 E491      		lpm r30, Z
 1486               		
 1487               	 ;  0 "" 2
 1488               	/* #NOAPP */
 1489               	.L65:
 1490               	.LBE166:
 1491 0532 E093 0000 		sts display+1,r30
 1492 0536 0895      		ret
 1521               	.Lscope15:
 1523               		.stabd	78,0,0
 1527               	.global	display_timezone
 1529               	display_timezone:
 1530               		.stabd	46,0,0
1658:iv.c          ****   }
1659:iv.c          **** }
1660:iv.c          **** 
1661:iv.c          **** // Kinda like display_time but just hours and minutes allows negative hours.
1662:iv.c          **** void display_timezone(int8_t h, uint8_t m){ 
 1532               	.LM159:
 1533               	.LFBB16:
 1534               	/* prologue: function */
 1535               	/* frame size = 0 */
 1536 0538 482F      		mov r20,r24
 1537 053a 262F      		mov r18,r22
 1538               	.LBB167:
1663:iv.c          ****   display[8] = pgm_read_byte(alphatable_p + 'c' - 'a');
 1540               	.LM160:
 1541 053c E0E0      		ldi r30,lo8(alphatable+2)
 1542 053e F0E0      		ldi r31,hi8(alphatable+2)
 1543               	/* #APP */
 1544               	 ;  1664 "iv.c" 1
 1545 0540 8491      		lpm r24, Z
 1546               		
 1547               	 ;  0 "" 2
 1548               	/* #NOAPP */
 1549               	.LBE167:
 1550 0542 8093 0000 		sts display+8,r24
 1551               	.LBB168:
1664:iv.c          ****   display[7] = pgm_read_byte(alphatable_p + 't' - 'a');
 1553               	.LM161:
 1554 0546 7196      		adiw r30,17
 1555               	/* #APP */
 1556               	 ;  1665 "iv.c" 1
 1557 0548 8491      		lpm r24, Z
 1558               		
 1559               	 ;  0 "" 2
 1560               	/* #NOAPP */
 1561               	.LBE168:
 1562 054a 8093 0000 		sts display+7,r24
 1563               	.LBB169:
1665:iv.c          ****   display[6] = pgm_read_byte(alphatable_p + 'u' - 'a');
 1565               	.LM162:
 1566 054e 3196      		adiw r30,1
 1567               	/* #APP */
 1568               	 ;  1666 "iv.c" 1
 1569 0550 E491      		lpm r30, Z
 1570               		
 1571               	 ;  0 "" 2
 1572               	/* #NOAPP */
 1573               	.LBE169:
 1574 0552 E093 0000 		sts display+6,r30
 1575               	.LBB170:
1666:iv.c          ****   display[5] = pgm_read_byte(numbertable_p + (m % 10));
 1577               	.LM163:
 1578 0556 862F      		mov r24,r22
 1579 0558 6AE0      		ldi r22,lo8(10)
 1580 055a 0E94 0000 		call __udivmodqi4
 1581 055e E92F      		mov r30,r25
 1582 0560 F0E0      		ldi r31,lo8(0)
 1583 0562 E050      		subi r30,lo8(-(numbertable))
 1584 0564 F040      		sbci r31,hi8(-(numbertable))
 1585               	/* #APP */
 1586               	 ;  1667 "iv.c" 1
 1587 0566 E491      		lpm r30, Z
 1588               		
 1589               	 ;  0 "" 2
 1590               	/* #NOAPP */
 1591               	.LBE170:
 1592 0568 E093 0000 		sts display+5,r30
 1593               	.LBB171:
1667:iv.c          ****   display[4] = pgm_read_byte(numbertable_p + (m / 10)); 
 1595               	.LM164:
 1596 056c 822F      		mov r24,r18
 1597 056e 0E94 0000 		call __udivmodqi4
 1598 0572 E82F      		mov r30,r24
 1599 0574 F0E0      		ldi r31,lo8(0)
 1600 0576 E050      		subi r30,lo8(-(numbertable))
 1601 0578 F040      		sbci r31,hi8(-(numbertable))
 1602               	/* #APP */
 1603               	 ;  1668 "iv.c" 1
 1604 057a E491      		lpm r30, Z
 1605               		
 1606               	 ;  0 "" 2
 1607               	/* #NOAPP */
 1608               	.LBE171:
 1609 057c E093 0000 		sts display+4,r30
1668:iv.c          ****   display[3] = 0;
 1611               	.LM165:
 1612 0580 1092 0000 		sts display+3,__zero_reg__
 1613               	.LBB172:
1669:iv.c          ****   display[2] = pgm_read_byte(numbertable_p + (abs(h) % 10));
 1615               	.LM166:
 1616 0584 242F      		mov r18,r20
 1617 0586 3327      		clr r19
 1618 0588 27FD      		sbrc r18,7
 1619 058a 3095      		com r19
 1620 058c 37FF      		sbrs r19,7
 1621 058e 00C0      		rjmp .L67
 1622 0590 3095      		com r19
 1623 0592 2195      		neg r18
 1624 0594 3F4F      		sbci r19,lo8(-1)
 1625               	.L67:
 1626 0596 C901      		movw r24,r18
 1627 0598 6AE0      		ldi r22,lo8(10)
 1628 059a 70E0      		ldi r23,hi8(10)
 1629 059c 0E94 0000 		call __divmodhi4
 1630 05a0 FC01      		movw r30,r24
 1631 05a2 E050      		subi r30,lo8(-(numbertable))
 1632 05a4 F040      		sbci r31,hi8(-(numbertable))
 1633               	/* #APP */
 1634               	 ;  1670 "iv.c" 1
 1635 05a6 E491      		lpm r30, Z
 1636               		
 1637               	 ;  0 "" 2
 1638               	/* #NOAPP */
 1639               	.LBE172:
 1640 05a8 E093 0000 		sts display+2,r30
 1641               	.LBB173:
1670:iv.c          ****   display[1] = pgm_read_byte(numbertable_p + (abs(h) / 10));
 1643               	.LM167:
 1644 05ac C901      		movw r24,r18
 1645 05ae 6AE0      		ldi r22,lo8(10)
 1646 05b0 70E0      		ldi r23,hi8(10)
 1647 05b2 0E94 0000 		call __divmodhi4
 1648 05b6 FB01      		movw r30,r22
 1649 05b8 E050      		subi r30,lo8(-(numbertable))
 1650 05ba F040      		sbci r31,hi8(-(numbertable))
 1651               	/* #APP */
 1652               	 ;  1671 "iv.c" 1
 1653 05bc E491      		lpm r30, Z
 1654               		
 1655               	 ;  0 "" 2
 1656               	/* #NOAPP */
 1657               	.LBE173:
 1658 05be E093 0000 		sts display+1,r30
1671:iv.c          ****   // We use the '-' as a negative sign
1672:iv.c          ****   if (h >= 0)
 1660               	.LM168:
 1661 05c2 47FD      		sbrc r20,7
 1662 05c4 00C0      		rjmp .L68
1673:iv.c          ****     display[0] &= ~0x2;  // positive numbers, implicit sign
 1664               	.LM169:
 1665 05c6 8091 0000 		lds r24,display
 1666 05ca 8D7F      		andi r24,lo8(-3)
 1667 05cc 00C0      		rjmp .L71
 1668               	.L68:
1674:iv.c          ****   else 
1675:iv.c          ****     display[0] |= 0x2;  // negative numbers, display negative sign
 1670               	.LM170:
 1671 05ce 8091 0000 		lds r24,display
 1672 05d2 8260      		ori r24,lo8(2)
 1673               	.L71:
 1674 05d4 8093 0000 		sts display,r24
 1675 05d8 0895      		ret
 1698               	.Lscope16:
 1700               		.stabd	78,0,0
 1702               	.global	display_str
 1704               	display_str:
 1705               		.stabd	46,0,0
1676:iv.c          **** 
1677:iv.c          **** }
1678:iv.c          **** 
1679:iv.c          **** // display words (menus, prompts, etc)
1680:iv.c          **** void display_str(char *s) {
 1707               	.LM171:
 1708               	.LFBB17:
 1709 05da CF93      		push r28
 1710 05dc DF93      		push r29
 1711               	/* prologue: function */
 1712               	/* frame size = 0 */
1681:iv.c          ****   uint8_t i;
1682:iv.c          **** 
1683:iv.c          ****   // don't use the lefthand dot/slash digit
1684:iv.c          ****   display[0] = 0;
 1714               	.LM172:
 1715 05de 1092 0000 		sts display,__zero_reg__
 1716 05e2 EC01      		movw r28,r24
 1717 05e4 A0E0      		ldi r26,lo8(display+1)
 1718 05e6 B0E0      		ldi r27,hi8(display+1)
 1719               	.L77:
1685:iv.c          **** 
1686:iv.c          ****   // up to 8 characters
1687:iv.c          ****   for (i=1; i<9; i++) {
1688:iv.c          ****     // check for null-termination
1689:iv.c          ****     if (s[i-1] == 0)
 1721               	.LM173:
 1722 05e8 E881      		ld r30,Y
 1723 05ea EE23      		tst r30
 1724 05ec 01F0      		breq .L78
1690:iv.c          ****       return;
1691:iv.c          **** 
1692:iv.c          ****     // Numbers and leters are looked up in the font table!
1693:iv.c          ****     if ((s[i-1] >= 'a') && (s[i-1] <= 'z')) {
 1726               	.LM174:
 1727 05ee 8E2F      		mov r24,r30
 1728 05f0 8156      		subi r24,lo8(-(-97))
 1729 05f2 8A31      		cpi r24,lo8(26)
 1730 05f4 00F4      		brsh .L74
 1731               	.LBB174:
1694:iv.c          ****       display[i] =  pgm_read_byte(alphatable_p + s[i-1] - 'a');
 1733               	.LM175:
 1734 05f6 F0E0      		ldi r31,lo8(0)
 1735 05f8 E050      		subi r30,lo8(-(alphatable-97))
 1736 05fa F040      		sbci r31,hi8(-(alphatable-97))
 1737               	/* #APP */
 1738               	 ;  1695 "iv.c" 1
 1739 05fc E491      		lpm r30, Z
 1740               		
 1741               	 ;  0 "" 2
 1742               	/* #NOAPP */
 1743 05fe 00C0      		rjmp .L80
 1744               	.L74:
 1745               	.LBE174:
1695:iv.c          ****     } else if ((s[i-1] >= '0') && (s[i-1] <= '9')) {
 1747               	.LM176:
 1748 0600 8E2F      		mov r24,r30
 1749 0602 8053      		subi r24,lo8(-(-48))
 1750 0604 8A30      		cpi r24,lo8(10)
 1751 0606 00F4      		brsh .L76
 1752               	.LBB175:
1696:iv.c          ****       display[i] =  pgm_read_byte(numbertable_p + s[i-1] - '0');
 1754               	.LM177:
 1755 0608 F0E0      		ldi r31,lo8(0)
 1756 060a E050      		subi r30,lo8(-(numbertable-48))
 1757 060c F040      		sbci r31,hi8(-(numbertable-48))
 1758               	/* #APP */
 1759               	 ;  1697 "iv.c" 1
 1760 060e E491      		lpm r30, Z
 1761               		
 1762               	 ;  0 "" 2
 1763               	/* #NOAPP */
 1764               	.L80:
 1765               	.LBE175:
 1766 0610 EC93      		st X,r30
 1767 0612 00C0      		rjmp .L75
 1768               	.L76:
1697:iv.c          ****     } else {
1698:iv.c          ****       display[i] = 0;      // spaces and other stuff are ignored :(
 1770               	.LM178:
 1771 0614 1C92      		st X,__zero_reg__
 1772               	.L75:
 1773 0616 2196      		adiw r28,1
 1774 0618 1196      		adiw r26,1
1688:iv.c          ****   for (i=1; i<9; i++) {
 1776               	.LM179:
 1777 061a 80E0      		ldi r24,hi8(display+9)
 1778 061c A030      		cpi r26,lo8(display+9)
 1779 061e B807      		cpc r27,r24
 1780 0620 01F4      		brne .L77
 1781               	.L78:
 1782               	/* epilogue start */
1699:iv.c          ****     }
1700:iv.c          ****   }
1701:iv.c          **** }
 1784               	.LM180:
 1785 0622 DF91      		pop r29
 1786 0624 CF91      		pop r28
 1787 0626 0895      		ret
 1795               	.Lscope17:
 1797               		.stabd	78,0,0
 1798               		.data
 1799               	.LC0:
 1800 0000 7375 6E64 		.string	"sunday"
 1800      6179 00
 1801               	.LC1:
 1802 0007 6D6F 6E64 		.string	"monday"
 1802      6179 00
 1803               	.LC2:
 1804 000e 7475 6573 		.string	"tuesday"
 1804      6461 7900 
 1805               	.LC3:
 1806 0016 7765 646E 		.string	"wednsday"
 1806      7364 6179 
 1806      00
 1807               	.LC4:
 1808 001f 7468 7572 		.string	"thursday"
 1808      7364 6179 
 1808      00
 1809               	.LC5:
 1810 0028 6672 6964 		.string	"friday"
 1810      6179 00
 1811               	.LC6:
 1812 002f 7361 7475 		.string	"saturday"
 1812      7264 6179 
 1812      00
 1813               	.LC7:
 1814 0038 6A61 6E00 		.string	"jan"
 1815               	.LC8:
 1816 003c 6665 6200 		.string	"feb"
 1817               	.LC9:
 1818 0040 6D61 7263 		.string	"march"
 1818      6800 
 1819               	.LC10:
 1820 0046 6170 7269 		.string	"april"
 1820      6C00 
 1821               	.LC11:
 1822 004c 6D61 7900 		.string	"may"
 1823               	.LC12:
 1824 0050 6A75 6E65 		.string	"june"
 1824      00
 1825               	.LC13:
 1826 0055 6A75 6C79 		.string	"july"
 1826      00
 1827               	.LC14:
 1828 005a 6175 6773 		.string	"augst"
 1828      7400 
 1829               	.LC15:
 1830 0060 7365 7074 		.string	"sept"
 1830      00
 1831               	.LC16:
 1832 0065 6F63 746F 		.string	"octob"
 1832      6200 
 1833               	.LC17:
 1834 006b 6E6F 7665 		.string	"novem"
 1834      6D00 
 1835               	.LC18:
 1836 0071 6465 6365 		.string	"decem"
 1836      6D00 
 1837               		.text
 1840               	.global	display_date
 1842               	display_date:
 1843               		.stabd	46,0,0
1511:iv.c          **** void display_date(uint8_t style) {
 1845               	.LM181:
 1846               	.LFBB18:
 1847 0628 CF93      		push r28
 1848 062a DF93      		push r29
 1849               	/* prologue: function */
 1850               	/* frame size = 0 */
1514:iv.c          ****   if (style == DATE) {
 1852               	.LM182:
 1853 062c 8823      		tst r24
 1854 062e 01F0      		breq .+2
 1855 0630 00C0      		rjmp .L82
1515:iv.c          ****     display[0] = 0;
 1857               	.LM183:
 1858 0632 1092 0000 		sts display,__zero_reg__
1516:iv.c          ****     display[6] = display[3] = 0x02;     // put dashes between num
 1860               	.LM184:
 1861 0636 82E0      		ldi r24,lo8(2)
 1862 0638 8093 0000 		sts display+3,r24
 1863 063c 8093 0000 		sts display+6,r24
1518:iv.c          ****     if (region == REGION_US) {
 1865               	.LM185:
 1866 0640 8091 0000 		lds r24,region
 1867 0644 8823      		tst r24
 1868 0646 01F0      		breq .+2
 1869 0648 00C0      		rjmp .L83
 1870               	.LBB176:
1520:iv.c          ****       display[1] = pgm_read_byte(numbertable_p + (date_m / 10));
 1872               	.LM186:
 1873 064a 8091 0000 		lds r24,date_m
 1874 064e 6AE0      		ldi r22,lo8(10)
 1875 0650 0E94 0000 		call __divmodqi4
 1876 0654 E82F      		mov r30,r24
 1877 0656 FF27      		clr r31
 1878 0658 E7FD      		sbrc r30,7
 1879 065a F095      		com r31
 1880 065c E050      		subi r30,lo8(-(numbertable))
 1881 065e F040      		sbci r31,hi8(-(numbertable))
 1882               	/* #APP */
 1883               	 ;  1520 "iv.c" 1
 1884 0660 E491      		lpm r30, Z
 1885               		
 1886               	 ;  0 "" 2
 1887               	/* #NOAPP */
 1888               	.LBE176:
 1889 0662 E093 0000 		sts display+1,r30
 1890               	.LBB177:
1521:iv.c          ****       display[2] = pgm_read_byte(numbertable_p + (date_m % 10));
 1892               	.LM187:
 1893 0666 8091 0000 		lds r24,date_m
 1894 066a 6AE0      		ldi r22,lo8(10)
 1895 066c 0E94 0000 		call __divmodqi4
 1896 0670 E92F      		mov r30,r25
 1897 0672 FF27      		clr r31
 1898 0674 E7FD      		sbrc r30,7
 1899 0676 F095      		com r31
 1900 0678 E050      		subi r30,lo8(-(numbertable))
 1901 067a F040      		sbci r31,hi8(-(numbertable))
 1902               	/* #APP */
 1903               	 ;  1521 "iv.c" 1
 1904 067c E491      		lpm r30, Z
 1905               		
 1906               	 ;  0 "" 2
 1907               	/* #NOAPP */
 1908               	.LBE177:
 1909 067e E093 0000 		sts display+2,r30
 1910               	.LBB178:
1522:iv.c          ****       display[4] = pgm_read_byte(numbertable_p + (date_d / 10));
 1912               	.LM188:
 1913 0682 8091 0000 		lds r24,date_d
 1914 0686 6AE0      		ldi r22,lo8(10)
 1915 0688 0E94 0000 		call __divmodqi4
 1916 068c E82F      		mov r30,r24
 1917 068e FF27      		clr r31
 1918 0690 E7FD      		sbrc r30,7
 1919 0692 F095      		com r31
 1920 0694 E050      		subi r30,lo8(-(numbertable))
 1921 0696 F040      		sbci r31,hi8(-(numbertable))
 1922               	/* #APP */
 1923               	 ;  1522 "iv.c" 1
 1924 0698 E491      		lpm r30, Z
 1925               		
 1926               	 ;  0 "" 2
 1927               	/* #NOAPP */
 1928               	.LBE178:
 1929 069a E093 0000 		sts display+4,r30
 1930               	.LBB179:
1523:iv.c          ****       display[5] = pgm_read_byte(numbertable_p + (date_d % 10));
 1932               	.LM189:
 1933 069e 8091 0000 		lds r24,date_d
 1934 06a2 6AE0      		ldi r22,lo8(10)
 1935 06a4 0E94 0000 		call __divmodqi4
 1936 06a8 E92F      		mov r30,r25
 1937 06aa FF27      		clr r31
 1938 06ac E7FD      		sbrc r30,7
 1939 06ae F095      		com r31
 1940 06b0 E050      		subi r30,lo8(-(numbertable))
 1941 06b2 F040      		sbci r31,hi8(-(numbertable))
 1942               	/* #APP */
 1943               	 ;  1523 "iv.c" 1
 1944 06b4 E491      		lpm r30, Z
 1945               		
 1946               	 ;  0 "" 2
 1947               	/* #NOAPP */
 1948 06b6 00C0      		rjmp .L116
 1949               	.L83:
 1950               	.LBE179:
 1951               	.LBB180:
1526:iv.c          ****       display[1] = pgm_read_byte(numbertable_p + (date_d / 10));
 1953               	.LM190:
 1954 06b8 8091 0000 		lds r24,date_d
 1955 06bc 6AE0      		ldi r22,lo8(10)
 1956 06be 0E94 0000 		call __divmodqi4
 1957 06c2 E82F      		mov r30,r24
 1958 06c4 FF27      		clr r31
 1959 06c6 E7FD      		sbrc r30,7
 1960 06c8 F095      		com r31
 1961 06ca E050      		subi r30,lo8(-(numbertable))
 1962 06cc F040      		sbci r31,hi8(-(numbertable))
 1963               	/* #APP */
 1964               	 ;  1526 "iv.c" 1
 1965 06ce E491      		lpm r30, Z
 1966               		
 1967               	 ;  0 "" 2
 1968               	/* #NOAPP */
 1969               	.LBE180:
 1970 06d0 E093 0000 		sts display+1,r30
 1971               	.LBB181:
1527:iv.c          ****       display[2] = pgm_read_byte(numbertable_p + (date_d % 10));
 1973               	.LM191:
 1974 06d4 8091 0000 		lds r24,date_d
 1975 06d8 6AE0      		ldi r22,lo8(10)
 1976 06da 0E94 0000 		call __divmodqi4
 1977 06de E92F      		mov r30,r25
 1978 06e0 FF27      		clr r31
 1979 06e2 E7FD      		sbrc r30,7
 1980 06e4 F095      		com r31
 1981 06e6 E050      		subi r30,lo8(-(numbertable))
 1982 06e8 F040      		sbci r31,hi8(-(numbertable))
 1983               	/* #APP */
 1984               	 ;  1527 "iv.c" 1
 1985 06ea E491      		lpm r30, Z
 1986               		
 1987               	 ;  0 "" 2
 1988               	/* #NOAPP */
 1989               	.LBE181:
 1990 06ec E093 0000 		sts display+2,r30
 1991               	.LBB182:
1528:iv.c          ****       display[4] = pgm_read_byte(numbertable_p + (date_m / 10));
 1993               	.LM192:
 1994 06f0 8091 0000 		lds r24,date_m
 1995 06f4 6AE0      		ldi r22,lo8(10)
 1996 06f6 0E94 0000 		call __divmodqi4
 1997 06fa E82F      		mov r30,r24
 1998 06fc FF27      		clr r31
 1999 06fe E7FD      		sbrc r30,7
 2000 0700 F095      		com r31
 2001 0702 E050      		subi r30,lo8(-(numbertable))
 2002 0704 F040      		sbci r31,hi8(-(numbertable))
 2003               	/* #APP */
 2004               	 ;  1528 "iv.c" 1
 2005 0706 E491      		lpm r30, Z
 2006               		
 2007               	 ;  0 "" 2
 2008               	/* #NOAPP */
 2009               	.LBE182:
 2010 0708 E093 0000 		sts display+4,r30
 2011               	.LBB183:
1529:iv.c          ****       display[5] = pgm_read_byte(numbertable_p + (date_m % 10));
 2013               	.LM193:
 2014 070c 8091 0000 		lds r24,date_m
 2015 0710 6AE0      		ldi r22,lo8(10)
 2016 0712 0E94 0000 		call __divmodqi4
 2017 0716 E92F      		mov r30,r25
 2018 0718 FF27      		clr r31
 2019 071a E7FD      		sbrc r30,7
 2020 071c F095      		com r31
 2021 071e E050      		subi r30,lo8(-(numbertable))
 2022 0720 F040      		sbci r31,hi8(-(numbertable))
 2023               	/* #APP */
 2024               	 ;  1529 "iv.c" 1
 2025 0722 E491      		lpm r30, Z
 2026               		
 2027               	 ;  0 "" 2
 2028               	/* #NOAPP */
 2029               	.L116:
 2030               	.LBE183:
 2031 0724 E093 0000 		sts display+5,r30
 2032               	.LBB184:
1532:iv.c          ****     display[7] = pgm_read_byte(numbertable_p + (date_y / 10));
 2034               	.LM194:
 2035 0728 8091 0000 		lds r24,date_y
 2036 072c 6AE0      		ldi r22,lo8(10)
 2037 072e 0E94 0000 		call __divmodqi4
 2038 0732 E82F      		mov r30,r24
 2039 0734 FF27      		clr r31
 2040 0736 E7FD      		sbrc r30,7
 2041 0738 F095      		com r31
 2042 073a E050      		subi r30,lo8(-(numbertable))
 2043 073c F040      		sbci r31,hi8(-(numbertable))
 2044               	/* #APP */
 2045               	 ;  1532 "iv.c" 1
 2046 073e E491      		lpm r30, Z
 2047               		
 2048               	 ;  0 "" 2
 2049               	/* #NOAPP */
 2050               	.LBE184:
 2051 0740 E093 0000 		sts display+7,r30
 2052               	.LBB185:
1533:iv.c          ****     display[8] = pgm_read_byte(numbertable_p + (date_y % 10));
 2054               	.LM195:
 2055 0744 8091 0000 		lds r24,date_y
 2056 0748 6AE0      		ldi r22,lo8(10)
 2057 074a 0E94 0000 		call __divmodqi4
 2058 074e E92F      		mov r30,r25
 2059 0750 FF27      		clr r31
 2060 0752 E7FD      		sbrc r30,7
 2061 0754 F095      		com r31
 2062 0756 E050      		subi r30,lo8(-(numbertable))
 2063 0758 F040      		sbci r31,hi8(-(numbertable))
 2064               	/* #APP */
 2065               	 ;  1533 "iv.c" 1
 2066 075a E491      		lpm r30, Z
 2067               		
 2068               	 ;  0 "" 2
 2069               	/* #NOAPP */
 2070 075c 00C0      		rjmp .L119
 2071               	.L82:
 2072               	.LBE185:
1535:iv.c          ****   } else if (style == DAY) {
 2074               	.LM196:
 2075 075e 8130      		cpi r24,lo8(1)
 2076 0760 01F0      		breq .+2
 2077 0762 00C0      		rjmp .L113
 2078               	.LBB186:
1543:iv.c          ****     month = date_m;
 2080               	.LM197:
 2081 0764 8091 0000 		lds r24,date_m
 2082 0768 C82F      		mov r28,r24
 2083 076a DD27      		clr r29
 2084 076c C7FD      		sbrc r28,7
 2085 076e D095      		com r29
1544:iv.c          ****     year = 2000 + date_y;
 2087               	.LM198:
 2088 0770 8091 0000 		lds r24,date_y
 2089 0774 E82F      		mov r30,r24
 2090 0776 FF27      		clr r31
 2091 0778 E7FD      		sbrc r30,7
 2092 077a F095      		com r31
 2093 077c E053      		subi r30,lo8(-(2000))
 2094 077e F84F      		sbci r31,hi8(-(2000))
1545:iv.c          ****     if (date_m < 3)  {
 2096               	.LM199:
 2097 0780 8091 0000 		lds r24,date_m
 2098 0784 8330      		cpi r24,lo8(3)
 2099 0786 04F4      		brge .L86
1546:iv.c          ****       month += 12;
 2101               	.LM200:
 2102 0788 2C96      		adiw r28,12
1547:iv.c          ****       year -= 1;
 2104               	.LM201:
 2105 078a 3197      		sbiw r30,1
 2106               	.L86:
1549:iv.c          ****     dotw = (date_d + (2 * month) + (6 * (month+1)/10) + year + (year/4) - (year/100) + (year/400) +
 2108               	.LM202:
 2109 078c 2091 0000 		lds r18,date_d
1552:iv.c          ****     display[8] = display[7] = 0;
 2111               	.LM203:
 2112 0790 1092 0000 		sts display+7,__zero_reg__
 2113 0794 1092 0000 		sts display+8,__zero_reg__
1553:iv.c          ****     switch (dotw) {
 2115               	.LM204:
 2116 0798 3327      		clr r19
 2117 079a 27FD      		sbrc r18,7
 2118 079c 3095      		com r19
 2119 079e 2F5F      		subi r18,lo8(-(1))
 2120 07a0 3F4F      		sbci r19,hi8(-(1))
 2121 07a2 2E0F      		add r18,r30
 2122 07a4 3F1F      		adc r19,r31
 2123 07a6 CE01      		movw r24,r28
 2124 07a8 880F      		lsl r24
 2125 07aa 991F      		rol r25
 2126 07ac 280F      		add r18,r24
 2127 07ae 391F      		adc r19,r25
 2128 07b0 CF01      		movw r24,r30
 2129 07b2 9695      		lsr r25
 2130 07b4 8795      		ror r24
 2131 07b6 9695      		lsr r25
 2132 07b8 8795      		ror r24
 2133 07ba 280F      		add r18,r24
 2134 07bc 391F      		adc r19,r25
 2135 07be CF01      		movw r24,r30
 2136 07c0 60E9      		ldi r22,lo8(400)
 2137 07c2 71E0      		ldi r23,hi8(400)
 2138 07c4 0E94 0000 		call __udivmodhi4
 2139 07c8 260F      		add r18,r22
 2140 07ca 371F      		adc r19,r23
 2141 07cc CF01      		movw r24,r30
 2142 07ce 64E6      		ldi r22,lo8(100)
 2143 07d0 70E0      		ldi r23,hi8(100)
 2144 07d2 0E94 0000 		call __udivmodhi4
 2145 07d6 261B      		sub r18,r22
 2146 07d8 370B      		sbc r19,r23
 2147 07da AE01      		movw r20,r28
 2148 07dc 4F5F      		subi r20,lo8(-(1))
 2149 07de 5F4F      		sbci r21,hi8(-(1))
 2150 07e0 CA01      		movw r24,r20
 2151 07e2 880F      		lsl r24
 2152 07e4 991F      		rol r25
 2153 07e6 840F      		add r24,r20
 2154 07e8 951F      		adc r25,r21
 2155 07ea 880F      		lsl r24
 2156 07ec 991F      		rol r25
 2157 07ee 6AE0      		ldi r22,lo8(10)
 2158 07f0 70E0      		ldi r23,hi8(10)
 2159 07f2 0E94 0000 		call __udivmodhi4
 2160 07f6 C901      		movw r24,r18
 2161 07f8 860F      		add r24,r22
 2162 07fa 971F      		adc r25,r23
 2163 07fc 67E0      		ldi r22,lo8(7)
 2164 07fe 70E0      		ldi r23,hi8(7)
 2165 0800 0E94 0000 		call __udivmodhi4
 2166 0804 8330      		cpi r24,lo8(3)
 2167 0806 01F0      		breq .L91
 2168 0808 8430      		cpi r24,lo8(4)
 2169 080a 00F4      		brsh .L95
 2170 080c 8130      		cpi r24,lo8(1)
 2171 080e 01F0      		breq .L89
 2172 0810 8230      		cpi r24,lo8(2)
 2173 0812 00F4      		brsh .L90
 2174 0814 00C0      		rjmp .L120
 2175               	.L95:
 2176 0816 8530      		cpi r24,lo8(5)
 2177 0818 01F0      		breq .L93
 2178 081a 8530      		cpi r24,lo8(5)
 2179 081c 00F0      		brlo .L92
 2180 081e 8630      		cpi r24,lo8(6)
 2181 0820 01F4      		brne .L87
 2182 0822 00C0      		rjmp .L121
 2183               	.L120:
1555:iv.c          ****       display_str("sunday"); break;
 2185               	.LM205:
 2186 0824 80E0      		ldi r24,lo8(.LC0)
 2187 0826 90E0      		ldi r25,hi8(.LC0)
 2188 0828 00C0      		rjmp .L117
 2189               	.L89:
1557:iv.c          ****       display_str("monday"); break;
 2191               	.LM206:
 2192 082a 80E0      		ldi r24,lo8(.LC1)
 2193 082c 90E0      		ldi r25,hi8(.LC1)
 2194 082e 00C0      		rjmp .L117
 2195               	.L90:
1559:iv.c          ****       display_str("tuesday"); break;
 2197               	.LM207:
 2198 0830 80E0      		ldi r24,lo8(.LC2)
 2199 0832 90E0      		ldi r25,hi8(.LC2)
 2200 0834 00C0      		rjmp .L117
 2201               	.L91:
1561:iv.c          ****       display_str("wednsday"); break;
 2203               	.LM208:
 2204 0836 80E0      		ldi r24,lo8(.LC3)
 2205 0838 90E0      		ldi r25,hi8(.LC3)
 2206 083a 00C0      		rjmp .L117
 2207               	.L92:
1563:iv.c          ****       display_str("thursday"); break;
 2209               	.LM209:
 2210 083c 80E0      		ldi r24,lo8(.LC4)
 2211 083e 90E0      		ldi r25,hi8(.LC4)
 2212 0840 00C0      		rjmp .L117
 2213               	.L93:
1565:iv.c          ****       display_str("friday"); break;
 2215               	.LM210:
 2216 0842 80E0      		ldi r24,lo8(.LC5)
 2217 0844 90E0      		ldi r25,hi8(.LC5)
 2218 0846 00C0      		rjmp .L117
 2219               	.L121:
1567:iv.c          ****       display_str("saturday"); break;
 2221               	.LM211:
 2222 0848 80E0      		ldi r24,lo8(.LC6)
 2223 084a 90E0      		ldi r25,hi8(.LC6)
 2224               	.L117:
 2225 084c 0E94 0000 		call display_str
 2226               	.L87:
 2227               	.LBB187:
 2228               	.LBB188:
 116:iv.c          ****   sei();
 2230               	.LM212:
 2231               	/* #APP */
 2232               	 ;  116 "iv.c" 1
 2233 0850 7894      		sei
 2234               	 ;  0 "" 2
 118:iv.c          ****   milliseconds = 0;
 2236               	.LM213:
 2237               	/* #NOAPP */
 2238 0852 1092 0000 		sts (milliseconds)+1,__zero_reg__
 2239 0856 1092 0000 		sts milliseconds,__zero_reg__
 2240               	.L96:
 119:iv.c          ****   while (milliseconds < ms);
 2242               	.LM214:
 2243 085a 8091 0000 		lds r24,milliseconds
 2244 085e 9091 0000 		lds r25,(milliseconds)+1
 2245 0862 885E      		subi r24,lo8(1000)
 2246 0864 9340      		sbci r25,hi8(1000)
 2247 0866 00F0      		brlo .L96
 2248               	.LBE188:
 2249               	.LBE187:
1574:iv.c          ****     display[6] = display[5] = display[4] = 0;
 2251               	.LM215:
 2252 0868 1092 0000 		sts display+4,__zero_reg__
 2253 086c 1092 0000 		sts display+5,__zero_reg__
 2254 0870 1092 0000 		sts display+6,__zero_reg__
1575:iv.c          ****     switch (date_m) {
 2256               	.LM216:
 2257 0874 8091 0000 		lds r24,date_m
 2258 0878 8630      		cpi r24,lo8(6)
 2259 087a 01F0      		breq .L103
 2260 087c 8730      		cpi r24,lo8(7)
 2261 087e 04F4      		brge .L110
 2262 0880 8330      		cpi r24,lo8(3)
 2263 0882 01F0      		breq .L100
 2264 0884 8430      		cpi r24,lo8(4)
 2265 0886 04F4      		brge .L111
 2266 0888 8130      		cpi r24,lo8(1)
 2267 088a 01F0      		breq .L98
 2268 088c 8230      		cpi r24,lo8(2)
 2269 088e 01F4      		brne .L97
 2270 0890 00C0      		rjmp .L122
 2271               	.L111:
 2272 0892 8430      		cpi r24,lo8(4)
 2273 0894 01F0      		breq .L101
 2274 0896 8530      		cpi r24,lo8(5)
 2275 0898 01F4      		brne .L97
 2276 089a 00C0      		rjmp .L123
 2277               	.L110:
 2278 089c 8930      		cpi r24,lo8(9)
 2279 089e 01F0      		breq .L106
 2280 08a0 8A30      		cpi r24,lo8(10)
 2281 08a2 04F4      		brge .L112
 2282 08a4 8730      		cpi r24,lo8(7)
 2283 08a6 01F0      		breq .L104
 2284 08a8 8830      		cpi r24,lo8(8)
 2285 08aa 01F4      		brne .L97
 2286 08ac 00C0      		rjmp .L124
 2287               	.L112:
 2288 08ae 8B30      		cpi r24,lo8(11)
 2289 08b0 01F0      		breq .L108
 2290 08b2 8B30      		cpi r24,lo8(11)
 2291 08b4 04F0      		brlt .L107
 2292 08b6 8C30      		cpi r24,lo8(12)
 2293 08b8 01F4      		brne .L97
 2294 08ba 00C0      		rjmp .L125
 2295               	.L98:
1577:iv.c          ****       display_str("jan"); break;
 2297               	.LM217:
 2298 08bc 80E0      		ldi r24,lo8(.LC7)
 2299 08be 90E0      		ldi r25,hi8(.LC7)
 2300 08c0 00C0      		rjmp .L118
 2301               	.L122:
1579:iv.c          ****       display_str("feb"); break;
 2303               	.LM218:
 2304 08c2 80E0      		ldi r24,lo8(.LC8)
 2305 08c4 90E0      		ldi r25,hi8(.LC8)
 2306 08c6 00C0      		rjmp .L118
 2307               	.L100:
1581:iv.c          ****       display_str("march"); break;
 2309               	.LM219:
 2310 08c8 80E0      		ldi r24,lo8(.LC9)
 2311 08ca 90E0      		ldi r25,hi8(.LC9)
 2312 08cc 00C0      		rjmp .L118
 2313               	.L101:
1583:iv.c          ****       display_str("april"); break;
 2315               	.LM220:
 2316 08ce 80E0      		ldi r24,lo8(.LC10)
 2317 08d0 90E0      		ldi r25,hi8(.LC10)
 2318 08d2 00C0      		rjmp .L118
 2319               	.L123:
1585:iv.c          ****       display_str("may"); break;
 2321               	.LM221:
 2322 08d4 80E0      		ldi r24,lo8(.LC11)
 2323 08d6 90E0      		ldi r25,hi8(.LC11)
 2324 08d8 00C0      		rjmp .L118
 2325               	.L103:
1587:iv.c          ****       display_str("june"); break;
 2327               	.LM222:
 2328 08da 80E0      		ldi r24,lo8(.LC12)
 2329 08dc 90E0      		ldi r25,hi8(.LC12)
 2330 08de 00C0      		rjmp .L118
 2331               	.L104:
1589:iv.c          ****       display_str("july"); break;
 2333               	.LM223:
 2334 08e0 80E0      		ldi r24,lo8(.LC13)
 2335 08e2 90E0      		ldi r25,hi8(.LC13)
 2336 08e4 00C0      		rjmp .L118
 2337               	.L124:
1591:iv.c          ****       display_str("augst"); break;
 2339               	.LM224:
 2340 08e6 80E0      		ldi r24,lo8(.LC14)
 2341 08e8 90E0      		ldi r25,hi8(.LC14)
 2342 08ea 00C0      		rjmp .L118
 2343               	.L106:
1593:iv.c          ****       display_str("sept"); break;
 2345               	.LM225:
 2346 08ec 80E0      		ldi r24,lo8(.LC15)
 2347 08ee 90E0      		ldi r25,hi8(.LC15)
 2348 08f0 00C0      		rjmp .L118
 2349               	.L107:
1595:iv.c          ****       display_str("octob"); break;
 2351               	.LM226:
 2352 08f2 80E0      		ldi r24,lo8(.LC16)
 2353 08f4 90E0      		ldi r25,hi8(.LC16)
 2354 08f6 00C0      		rjmp .L118
 2355               	.L108:
1597:iv.c          ****       display_str("novem"); break;
 2357               	.LM227:
 2358 08f8 80E0      		ldi r24,lo8(.LC17)
 2359 08fa 90E0      		ldi r25,hi8(.LC17)
 2360 08fc 00C0      		rjmp .L118
 2361               	.L125:
1599:iv.c          ****       display_str("decem"); break;
 2363               	.LM228:
 2364 08fe 80E0      		ldi r24,lo8(.LC18)
 2365 0900 90E0      		ldi r25,hi8(.LC18)
 2366               	.L118:
 2367 0902 0E94 0000 		call display_str
 2368               	.L97:
 2369               	.LBB189:
1601:iv.c          ****     display[7] = pgm_read_byte(numbertable_p + (date_d / 10));
 2371               	.LM229:
 2372 0906 8091 0000 		lds r24,date_d
 2373 090a 6AE0      		ldi r22,lo8(10)
 2374 090c 0E94 0000 		call __divmodqi4
 2375 0910 E82F      		mov r30,r24
 2376 0912 FF27      		clr r31
 2377 0914 E7FD      		sbrc r30,7
 2378 0916 F095      		com r31
 2379 0918 E050      		subi r30,lo8(-(numbertable))
 2380 091a F040      		sbci r31,hi8(-(numbertable))
 2381               	/* #APP */
 2382               	 ;  1601 "iv.c" 1
 2383 091c E491      		lpm r30, Z
 2384               		
 2385               	 ;  0 "" 2
 2386               	/* #NOAPP */
 2387               	.LBE189:
 2388 091e E093 0000 		sts display+7,r30
 2389               	.LBB190:
1602:iv.c          ****     display[8] = pgm_read_byte(numbertable_p + (date_d % 10));
 2391               	.LM230:
 2392 0922 8091 0000 		lds r24,date_d
 2393 0926 6AE0      		ldi r22,lo8(10)
 2394 0928 0E94 0000 		call __divmodqi4
 2395 092c E92F      		mov r30,r25
 2396 092e FF27      		clr r31
 2397 0930 E7FD      		sbrc r30,7
 2398 0932 F095      		com r31
 2399 0934 E050      		subi r30,lo8(-(numbertable))
 2400 0936 F040      		sbci r31,hi8(-(numbertable))
 2401               	/* #APP */
 2402               	 ;  1602 "iv.c" 1
 2403 0938 E491      		lpm r30, Z
 2404               		
 2405               	 ;  0 "" 2
 2406               	/* #NOAPP */
 2407               	.L119:
 2408               	.LBE190:
 2409 093a E093 0000 		sts display+8,r30
 2410               	.L113:
 2411               	/* epilogue start */
 2412               	.LBE186:
1605:iv.c          **** }
 2414               	.LM231:
 2415 093e DF91      		pop r29
 2416 0940 CF91      		pop r28
 2417 0942 0895      		ret
 2459               	.Lscope18:
 2461               		.stabd	78,0,0
 2463               	.global	vfd_init
 2465               	vfd_init:
 2466               		.stabd	46,0,0
1702:iv.c          **** 
1703:iv.c          **** /************************* LOW LEVEL DISPLAY ************************/
1704:iv.c          **** 
1705:iv.c          **** // Setup SPI
1706:iv.c          **** void vfd_init(void) {
 2468               	.LM232:
 2469               	.LFBB19:
 2470               	/* prologue: function */
 2471               	/* frame size = 0 */
1707:iv.c          ****   SPCR  = _BV(SPE) | _BV(MSTR) | _BV(SPR0);
 2473               	.LM233:
 2474 0944 81E5      		ldi r24,lo8(81)
 2475 0946 8CBD      		out 76-32,r24
 2476               	/* epilogue start */
1708:iv.c          **** }
 2478               	.LM234:
 2479 0948 0895      		ret
 2481               	.Lscope19:
 2483               		.stabd	78,0,0
 2486               	.global	vfd_send
 2488               	vfd_send:
 2489               		.stabd	46,0,0
1709:iv.c          **** 
1710:iv.c          **** // This changes and updates the display
1711:iv.c          **** // We use the digit/segment table to determine which
1712:iv.c          **** // pins on the MAX6921 to turn on
1713:iv.c          **** void setdisplay(uint8_t digit, uint8_t segments) {
1714:iv.c          ****   uint32_t d = 0;  // we only need 20 bits but 32 will do
1715:iv.c          ****   uint8_t i;
1716:iv.c          **** 
1717:iv.c          ****   // Set the digit selection pin
1718:iv.c          ****   d |= _BV(pgm_read_byte(digittable_p + digit));
1719:iv.c          **** 
1720:iv.c          ****   
1721:iv.c          ****   // Set the individual segments for this digit
1722:iv.c          ****   for (i=0; i<8; i++) {
1723:iv.c          ****     if (segments & _BV(i)) {
1724:iv.c          ****       t = 1;
1725:iv.c          ****       t <<= pgm_read_byte(segmenttable_p + i);
1726:iv.c          ****       d |= t;
1727:iv.c          ****     }
1728:iv.c          ****   }
1729:iv.c          **** 
1730:iv.c          ****   // Shift the data out to the display
1731:iv.c          ****   vfd_send(d);
1732:iv.c          **** }
1733:iv.c          **** 
1734:iv.c          **** // send raw data to display, its pretty straightforward. Just send 32 bits via SPI
1735:iv.c          **** // the bottom 20 define the segments
1736:iv.c          **** void vfd_send(uint32_t d) {
 2491               	.LM235:
 2492               	.LFBB20:
 2493               	/* prologue: function */
 2494               	/* frame size = 0 */
 2495 094a 9B01      		movw r18,r22
 2496 094c AC01      		movw r20,r24
1737:iv.c          ****   // send lowest 20 bits
1738:iv.c          ****   cli();       // to prevent flicker we turn off interrupts
 2498               	.LM236:
 2499               	/* #APP */
 2500               	 ;  1739 "iv.c" 1
 2501 094e F894      		cli
 2502               	 ;  0 "" 2
1739:iv.c          ****   spi_xfer(d >> 16);
 2504               	.LM237:
 2505               	/* #NOAPP */
 2506 0950 CA01      		movw r24,r20
 2507 0952 AA27      		clr r26
 2508 0954 BB27      		clr r27
 2509               	.LBB191:
 2510               	.LBB192:
1740:iv.c          ****   spi_xfer(d >> 8);
1741:iv.c          ****   spi_xfer(d);
1742:iv.c          **** 
1743:iv.c          ****   // latch data
1744:iv.c          ****   VFDLOAD_PORT |= _BV(VFDLOAD);
1745:iv.c          ****   VFDLOAD_PORT &= ~_BV(VFDLOAD);
1746:iv.c          ****   sei();
1747:iv.c          **** }
1748:iv.c          **** 
1749:iv.c          **** // Send 1 byte via SPI
1750:iv.c          **** void spi_xfer(uint8_t c) {
1751:iv.c          **** 
1752:iv.c          ****   SPDR = c;
 2512               	.LM238:
 2513 0956 8EBD      		out 78-32,r24
 2514               	.L129:
1753:iv.c          ****   while (! (SPSR & _BV(SPIF)));
 2516               	.LM239:
 2517 0958 0DB4      		in __tmp_reg__,77-32
 2518 095a 07FE      		sbrs __tmp_reg__,7
 2519 095c 00C0      		rjmp .L129
 2520               	.LBE192:
 2521               	.LBE191:
1741:iv.c          ****   spi_xfer(d >> 8);
 2523               	.LM240:
 2524 095e BB27      		clr r27
 2525 0960 A52F      		mov r26,r21
 2526 0962 942F      		mov r25,r20
 2527 0964 832F      		mov r24,r19
 2528               	.LBB193:
 2529               	.LBB194:
1753:iv.c          ****   while (! (SPSR & _BV(SPIF)));
 2531               	.LM241:
 2532 0966 8EBD      		out 78-32,r24
 2533               	.L130:
 2535               	.LM242:
 2536 0968 0DB4      		in __tmp_reg__,77-32
 2537 096a 07FE      		sbrs __tmp_reg__,7
 2538 096c 00C0      		rjmp .L130
 2539               	.LBE194:
 2540               	.LBE193:
 2541               	.LBB195:
 2542               	.LBB196:
1753:iv.c          ****   while (! (SPSR & _BV(SPIF)));
 2544               	.LM243:
 2545 096e 2EBD      		out 78-32,r18
 2546               	.L131:
 2548               	.LM244:
 2549 0970 0DB4      		in __tmp_reg__,77-32
 2550 0972 07FE      		sbrs __tmp_reg__,7
 2551 0974 00C0      		rjmp .L131
 2552               	.LBE196:
 2553               	.LBE195:
1745:iv.c          ****   VFDLOAD_PORT |= _BV(VFDLOAD);
 2555               	.LM245:
 2556 0976 409A      		sbi 40-32,0
1746:iv.c          ****   VFDLOAD_PORT &= ~_BV(VFDLOAD);
 2558               	.LM246:
 2559 0978 4098      		cbi 40-32,0
1747:iv.c          ****   sei();
 2561               	.LM247:
 2562               	/* #APP */
 2563               	 ;  1747 "iv.c" 1
 2564 097a 7894      		sei
 2565               	 ;  0 "" 2
 2566               	/* epilogue start */
1748:iv.c          **** }
 2568               	.LM248:
 2569               	/* #NOAPP */
 2570 097c 0895      		ret
 2572               	.Lscope20:
 2574               		.stabd	78,0,0
 2578               	.global	setdisplay
 2580               	setdisplay:
 2581               		.stabd	46,0,0
1714:iv.c          **** void setdisplay(uint8_t digit, uint8_t segments) {
 2583               	.LM249:
 2584               	.LFBB21:
 2585 097e AF92      		push r10
 2586 0980 BF92      		push r11
 2587 0982 CF92      		push r12
 2588 0984 DF92      		push r13
 2589 0986 EF92      		push r14
 2590 0988 FF92      		push r15
 2591 098a 0F93      		push r16
 2592 098c 1F93      		push r17
 2593               	/* prologue: function */
 2594               	/* frame size = 0 */
 2595               	.LBB197:
1719:iv.c          ****   d |= _BV(pgm_read_byte(digittable_p + digit));
 2597               	.LM250:
 2598 098e E82F      		mov r30,r24
 2599 0990 F0E0      		ldi r31,lo8(0)
 2600 0992 E050      		subi r30,lo8(-(digittable))
 2601 0994 F040      		sbci r31,hi8(-(digittable))
 2602               	/* #APP */
 2603               	 ;  1719 "iv.c" 1
 2604 0996 E491      		lpm r30, Z
 2605               		
 2606               	 ;  0 "" 2
 2607               	/* #NOAPP */
 2608               	.LBE197:
 2609 0998 81E0      		ldi r24,lo8(1)
 2610 099a 90E0      		ldi r25,hi8(1)
 2611 099c 00C0      		rjmp 2f
 2612 099e 880F      	1:	lsl r24
 2613 09a0 991F      		rol r25
 2614 09a2 EA95      	2:	dec r30
 2615 09a4 02F4      		brpl 1b
 2616 09a6 7C01      		movw r14,r24
 2617 09a8 0027      		clr r16
 2618 09aa F7FC      		sbrc r15,7
 2619 09ac 0095      		com r16
 2620 09ae 102F      		mov r17,r16
 2621 09b0 2091 0000 		lds r18,t
 2622 09b4 3091 0000 		lds r19,(t)+1
 2623 09b8 4091 0000 		lds r20,(t)+2
 2624 09bc 5091 0000 		lds r21,(t)+3
 2625 09c0 A0E0      		ldi r26,lo8(0)
 2626 09c2 B0E0      		ldi r27,hi8(0)
1724:iv.c          ****     if (segments & _BV(i)) {
 2628               	.LM251:
 2629 09c4 70E0      		ldi r23,lo8(0)
1726:iv.c          ****       t <<= pgm_read_byte(segmenttable_p + i);
 2631               	.LM252:
 2632 09c6 91E0      		ldi r25,lo8(1)
 2633 09c8 A92E      		mov r10,r25
 2634 09ca B12C      		mov r11,__zero_reg__
 2635 09cc C12C      		mov r12,__zero_reg__
 2636 09ce D12C      		mov r13,__zero_reg__
 2637               	.L138:
1724:iv.c          ****     if (segments & _BV(i)) {
 2639               	.LM253:
 2640 09d0 CB01      		movw r24,r22
 2641 09d2 0A2E      		mov r0,r26
 2642 09d4 00C0      		rjmp 2f
 2643 09d6 9595      	1:	asr r25
 2644 09d8 8795      		ror r24
 2645 09da 0A94      	2:	dec r0
 2646 09dc 02F4      		brpl 1b
 2647 09de 80FF      		sbrs r24,0
 2648 09e0 00C0      		rjmp .L137
 2649               	.LBB198:
1726:iv.c          ****       t <<= pgm_read_byte(segmenttable_p + i);
 2651               	.LM254:
 2652 09e2 FD01      		movw r30,r26
 2653 09e4 E050      		subi r30,lo8(-(segmenttable))
 2654 09e6 F040      		sbci r31,hi8(-(segmenttable))
 2655               	/* #APP */
 2656               	 ;  1726 "iv.c" 1
 2657 09e8 E491      		lpm r30, Z
 2658               		
 2659               	 ;  0 "" 2
 2660               	/* #NOAPP */
 2661               	.LBE198:
 2662 09ea A601      		movw r20,r12
 2663 09ec 9501      		movw r18,r10
 2664 09ee 00C0      		rjmp 2f
 2665 09f0 220F      	1:	lsl r18
 2666 09f2 331F      		rol r19
 2667 09f4 441F      		rol r20
 2668 09f6 551F      		rol r21
 2669 09f8 EA95      	2:	dec r30
 2670 09fa 02F4      		brpl 1b
1727:iv.c          ****       d |= t;
 2672               	.LM255:
 2673 09fc E22A      		or r14,r18
 2674 09fe F32A      		or r15,r19
 2675 0a00 042B      		or r16,r20
 2676 0a02 152B      		or r17,r21
 2677               	.L137:
 2678 0a04 1196      		adiw r26,1
1723:iv.c          ****   for (i=0; i<8; i++) {
 2680               	.LM256:
 2681 0a06 A830      		cpi r26,8
 2682 0a08 B105      		cpc r27,__zero_reg__
 2683 0a0a 01F4      		brne .L138
 2684 0a0c 2093 0000 		sts t,r18
 2685 0a10 3093 0000 		sts (t)+1,r19
 2686 0a14 4093 0000 		sts (t)+2,r20
 2687 0a18 5093 0000 		sts (t)+3,r21
1732:iv.c          ****   vfd_send(d);
 2689               	.LM257:
 2690 0a1c C801      		movw r24,r16
 2691 0a1e B701      		movw r22,r14
 2692 0a20 0E94 0000 		call vfd_send
 2693               	/* epilogue start */
1733:iv.c          **** }
 2695               	.LM258:
 2696 0a24 1F91      		pop r17
 2697 0a26 0F91      		pop r16
 2698 0a28 FF90      		pop r15
 2699 0a2a EF90      		pop r14
 2700 0a2c DF90      		pop r13
 2701 0a2e CF90      		pop r12
 2702 0a30 BF90      		pop r11
 2703 0a32 AF90      		pop r10
 2704 0a34 0895      		ret
 2715               	.Lscope21:
 2717               		.stabd	78,0,0
 2719               	.global	__vector_16
 2721               	__vector_16:
 2722               		.stabd	46,0,0
 142:iv.c          **** SIGNAL (SIG_OVERFLOW0) {
 2724               	.LM259:
 2725               	.LFBB22:
 2726 0a36 1F92      		push __zero_reg__
 2727 0a38 0F92      		push r0
 2728 0a3a 0FB6      		in r0,__SREG__
 2729 0a3c 0F92      		push r0
 2730 0a3e 1124      		clr __zero_reg__
 2731 0a40 2F93      		push r18
 2732 0a42 3F93      		push r19
 2733 0a44 4F93      		push r20
 2734 0a46 5F93      		push r21
 2735 0a48 6F93      		push r22
 2736 0a4a 7F93      		push r23
 2737 0a4c 8F93      		push r24
 2738 0a4e 9F93      		push r25
 2739 0a50 AF93      		push r26
 2740 0a52 BF93      		push r27
 2741 0a54 EF93      		push r30
 2742 0a56 FF93      		push r31
 2743               	/* prologue: Signal */
 2744               	/* frame size = 0 */
 144:iv.c          ****   sei();
 2746               	.LM260:
 2747               	/* #APP */
 2748               	 ;  144 "iv.c" 1
 2749 0a58 7894      		sei
 2750               	 ;  0 "" 2
 2751               	/* #NOAPP */
 2752               	.LBB199:
 2753               	.LBB200:
 138:iv.c          ****   wdt_reset();
 2755               	.LM261:
 2756               	/* #APP */
 2757               	 ;  138 "iv.c" 1
 2758 0a5a A895      		wdr
 2759               	 ;  0 "" 2
 2760               	/* #NOAPP */
 2761               	.LBE200:
 2762               	.LBE199:
 150:iv.c          ****   muxdiv++;
 2764               	.LM262:
 2765 0a5c 8091 0000 		lds r24,muxdiv
 2766 0a60 9091 0000 		lds r25,(muxdiv)+1
 2767 0a64 0196      		adiw r24,1
 2768 0a66 9093 0000 		sts (muxdiv)+1,r25
 2769 0a6a 8093 0000 		sts muxdiv,r24
 151:iv.c          ****   if (muxdiv < MUX_DIVIDER)
 2771               	.LM263:
 2772 0a6e 8197      		sbiw r24,33
 2773 0a70 00F4      		brsh .+2
 2774 0a72 00C0      		rjmp .L145
 153:iv.c          ****   muxdiv = 0;
 2776               	.LM264:
 2777 0a74 1092 0000 		sts (muxdiv)+1,__zero_reg__
 2778 0a78 1092 0000 		sts muxdiv,__zero_reg__
 157:iv.c          ****   milliseconds++;
 2780               	.LM265:
 2781 0a7c 8091 0000 		lds r24,milliseconds
 2782 0a80 9091 0000 		lds r25,(milliseconds)+1
 2783 0a84 0196      		adiw r24,1
 2784 0a86 9093 0000 		sts (milliseconds)+1,r25
 2785 0a8a 8093 0000 		sts milliseconds,r24
 160:iv.c          ****   if (currdigit >= DISPLAYSIZE)
 2787               	.LM266:
 2788 0a8e 8091 0000 		lds r24,currdigit
 2789 0a92 8930      		cpi r24,lo8(9)
 2790 0a94 00F0      		brlo .L143
 161:iv.c          ****     currdigit = 0;
 2792               	.LM267:
 2793 0a96 1092 0000 		sts currdigit,__zero_reg__
 2794               	.L143:
 164:iv.c          ****   setdisplay(currdigit, display[currdigit]);
 2796               	.LM268:
 2797 0a9a 8091 0000 		lds r24,currdigit
 2798 0a9e E82F      		mov r30,r24
 2799 0aa0 F0E0      		ldi r31,lo8(0)
 2800 0aa2 E050      		subi r30,lo8(-(display))
 2801 0aa4 F040      		sbci r31,hi8(-(display))
 2802 0aa6 6081      		ld r22,Z
 2803 0aa8 0E94 0000 		call setdisplay
 166:iv.c          ****   currdigit++;
 2805               	.LM269:
 2806 0aac 8091 0000 		lds r24,currdigit
 2807 0ab0 8F5F      		subi r24,lo8(-(1))
 2808 0ab2 8093 0000 		sts currdigit,r24
 169:iv.c          ****   if (alarming && !snoozetimer) {
 2810               	.LM270:
 2811 0ab6 8091 0000 		lds r24,alarming
 2812 0aba 8823      		tst r24
 2813 0abc 01F4      		brne .+2
 2814 0abe 00C0      		rjmp .L145
 2815 0ac0 8091 0000 		lds r24,snoozetimer
 2816 0ac4 9091 0000 		lds r25,(snoozetimer)+1
 2817 0ac8 892B      		or r24,r25
 2818 0aca 01F0      		breq .+2
 2819 0acc 00C0      		rjmp .L145
 170:iv.c          ****     alarmdiv++;
 2821               	.LM271:
 2822 0ace 8091 0000 		lds r24,alarmdiv
 2823 0ad2 9091 0000 		lds r25,(alarmdiv)+1
 2824 0ad6 0196      		adiw r24,1
 2825 0ad8 9093 0000 		sts (alarmdiv)+1,r25
 2826 0adc 8093 0000 		sts alarmdiv,r24
 171:iv.c          ****     if (alarmdiv > ALARM_DIVIDER) {
 2828               	.LM272:
 2829 0ae0 8536      		cpi r24,101
 2830 0ae2 9105      		cpc r25,__zero_reg__
 2831 0ae4 00F0      		brlo .L145
 172:iv.c          ****       alarmdiv = 0;
 2833               	.LM273:
 2834 0ae6 1092 0000 		sts (alarmdiv)+1,__zero_reg__
 2835 0aea 1092 0000 		sts alarmdiv,__zero_reg__
 179:iv.c          ****     ICR1 = 250;
 2837               	.LM274:
 2838 0aee 8AEF      		ldi r24,lo8(250)
 2839 0af0 90E0      		ldi r25,hi8(250)
 2840 0af2 9093 8700 		sts (134)+1,r25
 2841 0af6 8093 8600 		sts 134,r24
 180:iv.c          ****     OCR1A = OCR1B = ICR1/2;
 2843               	.LM275:
 2844 0afa 8091 8600 		lds r24,134
 2845 0afe 9091 8700 		lds r25,(134)+1
 2846 0b02 9695      		lsr r25
 2847 0b04 8795      		ror r24
 2848 0b06 9093 8B00 		sts (138)+1,r25
 2849 0b0a 8093 8A00 		sts 138,r24
 2850 0b0e 8091 8A00 		lds r24,138
 2851 0b12 9091 8B00 		lds r25,(138)+1
 2852 0b16 9093 8900 		sts (136)+1,r25
 2853 0b1a 8093 8800 		sts 136,r24
 183:iv.c          ****     if (alarming & 0xF0) { // top bit indicates pulsing alarm state
 2855               	.LM276:
 2856 0b1e 8091 0000 		lds r24,alarming
 2857 0b22 807F      		andi r24,lo8(-16)
 2858 0b24 01F0      		breq .L144
 184:iv.c          ****       alarming &= ~0xF0;
 2860               	.LM277:
 2861 0b26 8091 0000 		lds r24,alarming
 2862 0b2a 8F70      		andi r24,lo8(15)
 2863 0b2c 8093 0000 		sts alarming,r24
 185:iv.c          ****       TCCR1B &= ~_BV(CS11); // turn buzzer off!
 2865               	.LM278:
 2866 0b30 8091 8100 		lds r24,129
 2867 0b34 8D7F      		andi r24,lo8(-3)
 2868 0b36 00C0      		rjmp .L146
 2869               	.L144:
 187:iv.c          ****       alarming |= 0xF0;
 2871               	.LM279:
 2872 0b38 8091 0000 		lds r24,alarming
 2873 0b3c 806F      		ori r24,lo8(-16)
 2874 0b3e 8093 0000 		sts alarming,r24
 188:iv.c          ****       TCCR1B |= _BV(CS11); // turn buzzer on!
 2876               	.LM280:
 2877 0b42 8091 8100 		lds r24,129
 2878 0b46 8260      		ori r24,lo8(2)
 2879               	.L146:
 2880 0b48 8093 8100 		sts 129,r24
 2881               	.L145:
 2882               	/* epilogue start */
 192:iv.c          **** }
 2884               	.LM281:
 2885 0b4c FF91      		pop r31
 2886 0b4e EF91      		pop r30
 2887 0b50 BF91      		pop r27
 2888 0b52 AF91      		pop r26
 2889 0b54 9F91      		pop r25
 2890 0b56 8F91      		pop r24
 2891 0b58 7F91      		pop r23
 2892 0b5a 6F91      		pop r22
 2893 0b5c 5F91      		pop r21
 2894 0b5e 4F91      		pop r20
 2895 0b60 3F91      		pop r19
 2896 0b62 2F91      		pop r18
 2897 0b64 0F90      		pop r0
 2898 0b66 0FBE      		out __SREG__,r0
 2899 0b68 0F90      		pop r0
 2900 0b6a 1F90      		pop __zero_reg__
 2901 0b6c 1895      		reti
 2903               	.Lscope22:
 2905               		.stabd	78,0,0
 2908               	.global	spi_xfer
 2910               	spi_xfer:
 2911               		.stabd	46,0,0
1751:iv.c          **** void spi_xfer(uint8_t c) {
 2913               	.LM282:
 2914               	.LFBB23:
 2915               	/* prologue: function */
 2916               	/* frame size = 0 */
1753:iv.c          ****   SPDR = c;
 2918               	.LM283:
 2919 0b6e 8EBD      		out 78-32,r24
 2920               	.L148:
 2922               	.LM284:
 2923 0b70 0DB4      		in __tmp_reg__,77-32
 2924 0b72 07FE      		sbrs __tmp_reg__,7
 2925 0b74 00C0      		rjmp .L148
 2926               	/* epilogue start */
1754:iv.c          **** }
 2928               	.LM285:
 2929 0b76 0895      		ret
 2931               	.Lscope23:
 2933               		.stabd	78,0,0
 2935               	.global	gpsdataready
 2937               	gpsdataready:
 2938               		.stabd	46,0,0
1755:iv.c          **** 
1756:iv.c          **** //GPS serial data handling functions:
1757:iv.c          **** 
1758:iv.c          **** //Check to see if there is any serial data.
1759:iv.c          **** uint8_t gpsdataready(void) {
 2940               	.LM286:
 2941               	.LFBB24:
 2942               	/* prologue: function */
 2943               	/* frame size = 0 */
1760:iv.c          **** 
1761:iv.c          ****   return (UCSR0A & _BV(RXC0));
 2945               	.LM287:
 2946 0b78 8091 C000 		lds r24,192
1762:iv.c          **** 
1763:iv.c          **** }
 2948               	.LM288:
 2949 0b7c 8078      		andi r24,lo8(-128)
 2950               	/* epilogue start */
 2951 0b7e 0895      		ret
 2953               	.Lscope24:
 2955               		.stabd	78,0,0
 2958               	.global	setgpstime
 2960               	setgpstime:
 2961               		.stabd	46,0,0
1764:iv.c          **** 
1765:iv.c          **** 
1766:iv.c          **** void getgpstime(void) {
1767:iv.c          **** 
1768:iv.c          ****   uint8_t intOldHr = 0;
1769:iv.c          ****   uint8_t intOldMin = 0;
1770:iv.c          ****   uint8_t intOldSec = 0;
1771:iv.c          **** 
1772:iv.c          ****   char charReceived = UDR0;
1773:iv.c          **** 
1774:iv.c          ****   char *strPointer1;
1775:iv.c          ****   char strTime[7];
1776:iv.c          ****   char strDate[7];
1777:iv.c          ****   
1778:iv.c          ****   //If the buffer has not been started because a '$' has not been encountered
1779:iv.c          ****   //but a '$' is just now encountered, then start filling the buffer.
1780:iv.c          ****   if ( ( 0 == intBufferStatus ) && ( '$' == charReceived ) ) {
1781:iv.c          ****     intBufferStatus = 1;
1782:iv.c          ****     strncat(strBuffer, &charReceived, 1);
1783:iv.c          ****     return;
1784:iv.c          ****   }
1785:iv.c          **** 
1786:iv.c          ****   //If the buffer has started to fill...
1787:iv.c          ****   if ( 0 != intBufferStatus ) {
1788:iv.c          ****     //If for some reason, the buffer is full, clear it, and start over.
1789:iv.c          ****     if ( ! ( ( strlen(strBuffer) < BUFFERSIZE ) ) ) {
1790:iv.c          ****       memset( strBuffer, 0, BUFFERSIZE );
1791:iv.c          ****       intBufferStatus = 0;
1792:iv.c          ****       return;
1793:iv.c          ****     }
1794:iv.c          ****     //If the buffer has 6 characters in it, it is time to check to see if it is 
1795:iv.c          ****     //the line we are looking for that starts with "$GPRMC"
1796:iv.c          ****     else if ( 6 == strlen(strBuffer) ) {
1797:iv.c          ****       //If the buffer does contain the characters we are looking for,
1798:iv.c          ****       //then update the status, add to the buffer, and then return for more.
1799:iv.c          ****       if ( 0 == strcmp( strBuffer, "$GPRMC" ) ) {
1800:iv.c          ****         //uart_puts("\n\r$GPRMC Found \n\r");
1801:iv.c          ****         intBufferStatus = 2;
1802:iv.c          ****         strncat(strBuffer, &charReceived, 1);
1803:iv.c          ****         return;
1804:iv.c          ****       }
1805:iv.c          ****       //If the buffer does not contain the characters we are looking for,
1806:iv.c          ****       //then clear the buffer and start over..
1807:iv.c          ****       else {
1808:iv.c          ****         //uart_puts("\n\r$GPRMC Not Found:\t\t");
1809:iv.c          ****         //uart_puts(strBuffer);
1810:iv.c          ****         memset( strBuffer, 0, BUFFERSIZE );
1811:iv.c          ****         intBufferStatus = 0;
1812:iv.c          ****         return;
1813:iv.c          ****       }
1814:iv.c          ****     }
1815:iv.c          **** 
1816:iv.c          ****     //If the asterix at the start of the checksum at the end of the line is encountered,
1817:iv.c          ****     //then parse the buffer.
1818:iv.c          ****     else if ( '*' == charReceived ) {
1819:iv.c          ****       //If the buffer status indicates we have not already found the
1820:iv.c          ****       //needed start of the string, then start over.
1821:iv.c          ****       if ( 2 != intBufferStatus ) {
1822:iv.c          ****         memset( strBuffer, 0, BUFFERSIZE );
1823:iv.c          ****         intBufferStatus = 0;
1824:iv.c          ****         return;
1825:iv.c          ****       }
1826:iv.c          ****       //If the buffer status indicates we have already found the needed start of the string,
1827:iv.c          ****       //then go on to parse the buffer.
1828:iv.c          ****       else {
1829:iv.c          ****         //Parse the buffer here...
1830:iv.c          ****         //Let's test to see if this works:
1831:iv.c          ****         uart_puts("\n\r");
1832:iv.c          ****         uart_puts(strBuffer);
1833:iv.c          **** 
1834:iv.c          ****         //Find the first comma:
1835:iv.c          ****         strPointer1 = strchr( strBuffer, ',');
1836:iv.c          **** 
1837:iv.c          ****         //Copy the section of memory in the buffer that contains the time.
1838:iv.c          ****         memcpy( strTime, strPointer1 + 1, 6 );
1839:iv.c          ****         //add a null character to the end of the time string.
1840:iv.c          ****         strTime[6] = 0;
1841:iv.c          **** 
1842:iv.c          **** 
1843:iv.c          **** 
1844:iv.c          ****         //Find eight more commas to get the date:
1845:iv.c          ****         for ( int i = 0; i < 8; i++ ) {
1846:iv.c          ****           strPointer1 = strchr( strPointer1 + 1, ',');
1847:iv.c          ****         }
1848:iv.c          **** 
1849:iv.c          ****         //Copy the section of memory in the buffer that contains the date.
1850:iv.c          ****         memcpy( strDate, strPointer1 + 1, 6 );
1851:iv.c          ****         //add a null character to the end of the date string.
1852:iv.c          ****         strDate[6] = 0;
1853:iv.c          **** 
1854:iv.c          ****         //The GPS unit will not have the proper date unless it has received a time update.
1855:iv.c          ****         //NOTE: at the turn of the century, the clock will not get updates from GPS
1856:iv.c          ****         //for as many years as the value of PROGRAMMING_YEAR
1857:iv.c          ****         if ( PROGRAMMING_YEAR <= ( ( (strDate[4] - '0') * 10 ) ) + (strDate[5] - '0') ) {
1858:iv.c          ****           //Get the 'old' values of the time:
1859:iv.c          ****           intOldHr = time_h;
1860:iv.c          ****           intOldMin = time_m;
1861:iv.c          ****           intOldSec = time_s;
1862:iv.c          **** 
1863:iv.c          ****           //Change the time:
1864:iv.c          ****           setgpstime(strTime);
1865:iv.c          ****           //Change the date:
1866:iv.c          ****           setgpsdate(strDate);
1867:iv.c          **** 
1868:iv.c          **** 	  //Gussy up the time and date, make the numbers come out right:
1869:iv.c          ****           fix_time();
1870:iv.c          **** 
1871:iv.c          ****           //Turn the two time values into minutes past midnight
1872:iv.c          ****           uint16_t timeMinutes = ((time_h * 60) + (time_m));
1873:iv.c          ****           uint16_t oldTimeMinutes = ((intOldHr * 60) + (intOldMin));
1874:iv.c          **** 
1875:iv.c          ****           int8_t intTempHr = time_h;
1876:iv.c          ****           int8_t intTempMin = time_m;
1877:iv.c          **** 
1878:iv.c          ****           //If midnight happened between the old time and the new time
1879:iv.c          ****           //and we did not just go back in time...
1880:iv.c          ****           if ( ( 0 > (int16_t)( timeMinutes - oldTimeMinutes ) )
1881:iv.c          ****                && ( (timeMinutes + 1440) >= oldTimeMinutes )
1882:iv.c          ****                && ( abs( timeMinutes + 1440 - oldTimeMinutes ) < abs( timeMinutes - oldTimeMinutes 
1883:iv.c          ****             timeMinutes += 1440;
1884:iv.c          ****             intTempHr += 24;
1885:iv.c          ****           }
1886:iv.c          **** 
1887:iv.c          ****           if ( timeMinutes > oldTimeMinutes ) {
1888:iv.c          **** 
1889:iv.c          ****             //Count backwards in time to the old time, checking the alarm for each minute.
1890:iv.c          ****             for ( ; intTempHr >= intOldHr; intTempHr-- ) {
1891:iv.c          ****               for ( ; intTempMin >= 0; intTempMin-- ) {
1892:iv.c          ****                 check_alarm( (uint8_t)intTempHr, (uint8_t)intTempMin, 0 );
1893:iv.c          ****               }
1894:iv.c          ****               intTempMin = 59;
1895:iv.c          ****             }
1896:iv.c          **** 
1897:iv.c          ****           }
1898:iv.c          **** 
1899:iv.c          ****         }
1900:iv.c          **** 
1901:iv.c          ****         //We've done what we needed to do, so start over.
1902:iv.c          ****         memset( strBuffer, 0, BUFFERSIZE );
1903:iv.c          ****         intBufferStatus = 0;
1904:iv.c          ****         return;
1905:iv.c          ****       }
1906:iv.c          ****     }
1907:iv.c          ****     //If nothing else was found, add to the buffer.
1908:iv.c          ****     else {
1909:iv.c          ****       strncat(strBuffer, &charReceived, 1);
1910:iv.c          ****     }
1911:iv.c          **** 
1912:iv.c          **** 
1913:iv.c          ****   }
1914:iv.c          **** 
1915:iv.c          **** }
1916:iv.c          **** 
1917:iv.c          **** //Set the time with a string taken from GPS data:
1918:iv.c          **** void setgpstime(char* str) {
 2963               	.LM289:
 2964               	.LFBB25:
 2965               	/* prologue: function */
 2966               	/* frame size = 0 */
 2967 0b80 FC01      		movw r30,r24
1919:iv.c          ****   uint8_t intTempHr = 0;
1920:iv.c          ****   uint8_t intTempMin = 0;
1921:iv.c          ****   uint8_t intTempSec = 0;
1922:iv.c          **** 
1923:iv.c          ****   intTempHr = (str[0] - '0') * 10;
1924:iv.c          ****   intTempHr = intTempHr + (str[1] - '0');
1925:iv.c          **** 
1926:iv.c          ****   intTempMin = (str[2] - '0') * 10;
1927:iv.c          ****   intTempMin = intTempMin + (str[3] - '0');
 2969               	.LM290:
 2970 0b82 5381      		ldd r21,Z+3
 2971 0b84 5051      		subi r21,lo8(-(-16))
 2972 0b86 8281      		ldd r24,Z+2
 2973 0b88 4AE0      		ldi r20,lo8(10)
 2974 0b8a 849F      		mul r24,r20
 2975 0b8c C001      		movw r24,r0
 2976 0b8e 1124      		clr r1
 2977 0b90 580F      		add r21,r24
1928:iv.c          **** 
1929:iv.c          ****   intTempSec = (str[4] - '0') * 10;
 2979               	.LM291:
 2980 0b92 7481      		ldd r23,Z+4
1930:iv.c          ****   intTempSec = intTempSec + (str[5] - '0');
 2982               	.LM292:
 2983 0b94 6581      		ldd r22,Z+5
1931:iv.c          **** 
1932:iv.c          ****   time_h = intTempHr + intTimeZoneHour;
 2985               	.LM293:
 2986 0b96 3091 0000 		lds r19,intTimeZoneHour
 2987 0b9a 232F      		mov r18,r19
 2988 0b9c 2051      		subi r18,lo8(-(-16))
 2989 0b9e 8181      		ldd r24,Z+1
 2990 0ba0 280F      		add r18,r24
 2991 0ba2 8081      		ld r24,Z
 2992 0ba4 849F      		mul r24,r20
 2993 0ba6 C001      		movw r24,r0
 2994 0ba8 1124      		clr r1
 2995 0baa 280F      		add r18,r24
 2996 0bac 2093 0000 		sts time_h,r18
 2997 0bb0 8091 0000 		lds r24,intTimeZoneMin
1933:iv.c          **** 
1934:iv.c          ****   //If the time zone offset is negative, then subtract minutes
1935:iv.c          ****   if ( 0 > intTimeZoneHour )
 2999               	.LM294:
 3000 0bb4 37FF      		sbrs r19,7
 3001 0bb6 00C0      		rjmp .L154
1936:iv.c          ****     time_m = intTempMin - intTimeZoneMin;
 3003               	.LM295:
 3004 0bb8 581B      		sub r21,r24
 3005 0bba 00C0      		rjmp .L157
 3006               	.L154:
1937:iv.c          ****   else
1938:iv.c          ****     time_m = intTempMin + intTimeZoneMin;
 3008               	.LM296:
 3009 0bbc 580F      		add r21,r24
 3010               	.L157:
 3011 0bbe 5093 0000 		sts time_m,r21
1939:iv.c          **** 
1940:iv.c          ****   time_s = intTempSec;
 3013               	.LM297:
 3014 0bc2 6051      		subi r22,lo8(-(-16))
 3015 0bc4 8AE0      		ldi r24,lo8(10)
 3016 0bc6 789F      		mul r23,r24
 3017 0bc8 C001      		movw r24,r0
 3018 0bca 1124      		clr r1
 3019 0bcc 680F      		add r22,r24
 3020 0bce 6093 0000 		sts time_s,r22
 3021               	/* epilogue start */
1941:iv.c          **** 
1942:iv.c          **** }
 3023               	.LM298:
 3024 0bd2 0895      		ret
 3029               	.Lscope25:
 3031               		.stabd	78,0,0
 3034               	.global	setgpsdate
 3036               	setgpsdate:
 3037               		.stabd	46,0,0
1943:iv.c          **** 
1944:iv.c          **** //Set the date with a string taken from GPS data:
1945:iv.c          **** void setgpsdate(char* str) {
 3039               	.LM299:
 3040               	.LFBB26:
 3041               	/* prologue: function */
 3042               	/* frame size = 0 */
 3043 0bd4 FC01      		movw r30,r24
1946:iv.c          ****   uint8_t intTempDay = 0;
1947:iv.c          ****   uint8_t intTempMon = 0;
1948:iv.c          ****   uint8_t intTempYr = 0;
1949:iv.c          **** 
1950:iv.c          ****   intTempDay = (str[0] - '0') * 10;
1951:iv.c          ****   intTempDay = intTempDay + (str[1] - '0');
 3045               	.LM300:
 3046 0bd6 5181      		ldd r21,Z+1
 3047 0bd8 5051      		subi r21,lo8(-(-16))
 3048 0bda 8081      		ld r24,Z
 3049 0bdc 4AE0      		ldi r20,lo8(10)
 3050 0bde 849F      		mul r24,r20
 3051 0be0 C001      		movw r24,r0
 3052 0be2 1124      		clr r1
 3053 0be4 580F      		add r21,r24
1952:iv.c          **** 
1953:iv.c          ****   intTempMon = (str[2] - '0') * 10;
1954:iv.c          ****   intTempMon = intTempMon + (str[3] - '0');
 3055               	.LM301:
 3056 0be6 3381      		ldd r19,Z+3
 3057 0be8 3051      		subi r19,lo8(-(-16))
 3058 0bea 8281      		ldd r24,Z+2
 3059 0bec 849F      		mul r24,r20
 3060 0bee C001      		movw r24,r0
 3061 0bf0 1124      		clr r1
 3062 0bf2 380F      		add r19,r24
1955:iv.c          **** 
1956:iv.c          ****   intTempYr = (str[4] - '0') * 10;
1957:iv.c          ****   intTempYr = intTempYr + (str[5] - '0');
 3064               	.LM302:
 3065 0bf4 2581      		ldd r18,Z+5
 3066 0bf6 2051      		subi r18,lo8(-(-16))
 3067 0bf8 8481      		ldd r24,Z+4
 3068 0bfa 849F      		mul r24,r20
 3069 0bfc C001      		movw r24,r0
 3070 0bfe 1124      		clr r1
 3071 0c00 280F      		add r18,r24
1958:iv.c          **** 
1959:iv.c          ****   timeunknown = 0;
 3073               	.LM303:
 3074 0c02 1092 0000 		sts timeunknown,__zero_reg__
1960:iv.c          ****   restored = 0;
 3076               	.LM304:
 3077 0c06 1092 0000 		sts restored,__zero_reg__
1961:iv.c          **** 
1962:iv.c          ****   date_d = intTempDay;
 3079               	.LM305:
 3080 0c0a 5093 0000 		sts date_d,r21
1963:iv.c          ****   date_m = intTempMon;
 3082               	.LM306:
 3083 0c0e 3093 0000 		sts date_m,r19
1964:iv.c          ****   date_y = intTempYr;
 3085               	.LM307:
 3086 0c12 2093 0000 		sts date_y,r18
 3087               	/* epilogue start */
1965:iv.c          **** 
1966:iv.c          **** }
 3089               	.LM308:
 3090 0c16 0895      		ret
 3092               	.Lscope26:
 3094               		.stabd	78,0,0
 3096               	.global	fix_time
 3098               	fix_time:
 3099               		.stabd	46,0,0
1967:iv.c          **** 
1968:iv.c          **** //Checks the alarm against the passed time.
1969:iv.c          **** void check_alarm(uint8_t h, uint8_t m, uint8_t s) {
1970:iv.c          **** 
1971:iv.c          ****   if (alarm_on && (alarm_h == h) && (alarm_m == m) && (0 == s)) {
1972:iv.c          ****     DEBUGP("alarm on!");
1973:iv.c          ****     alarming = 1;
1974:iv.c          ****     snoozetimer = 0;
1975:iv.c          ****   }
1976:iv.c          **** 
1977:iv.c          **** }
1978:iv.c          **** 
1979:iv.c          **** 
1980:iv.c          **** //Fixes the time variables whenever time is changed
1981:iv.c          **** void fix_time(void) {
 3101               	.LM309:
 3102               	.LFBB27:
 3103               	/* prologue: function */
 3104               	/* frame size = 0 */
1982:iv.c          **** 
1983:iv.c          ****   // a minute!
1984:iv.c          ****   if (time_s >= 60) {
 3106               	.LM310:
 3107 0c18 8091 0000 		lds r24,time_s
 3108 0c1c 8C33      		cpi r24,lo8(60)
 3109 0c1e 04F0      		brlt .L161
1985:iv.c          ****     time_s = time_s - 60;
 3111               	.LM311:
 3112 0c20 8091 0000 		lds r24,time_s
 3113 0c24 8C53      		subi r24,lo8(-(-60))
 3114 0c26 8093 0000 		sts time_s,r24
1986:iv.c          ****     time_m++;
 3116               	.LM312:
 3117 0c2a 8091 0000 		lds r24,time_m
 3118 0c2e 8F5F      		subi r24,lo8(-(1))
 3119 0c30 8093 0000 		sts time_m,r24
 3120               	.L161:
1987:iv.c          ****   }
1988:iv.c          ****   // If someone decides to make offset seconds with a negative number...
1989:iv.c          ****   if (time_s < 0) {
 3122               	.LM313:
 3123 0c34 8091 0000 		lds r24,time_s
 3124 0c38 87FF      		sbrs r24,7
 3125 0c3a 00C0      		rjmp .L162
1990:iv.c          ****     time_s =  60 + time_s;
 3127               	.LM314:
 3128 0c3c 8091 0000 		lds r24,time_s
 3129 0c40 845C      		subi r24,lo8(-(60))
 3130 0c42 8093 0000 		sts time_s,r24
1991:iv.c          ****     time_m--;
 3132               	.LM315:
 3133 0c46 8091 0000 		lds r24,time_m
 3134 0c4a 8150      		subi r24,lo8(-(-1))
 3135 0c4c 8093 0000 		sts time_m,r24
 3136               	.L162:
1992:iv.c          ****   }
1993:iv.c          **** 
1994:iv.c          ****   // an hour...
1995:iv.c          ****   if (time_m >= 60) {
 3138               	.LM316:
 3139 0c50 8091 0000 		lds r24,time_m
 3140 0c54 8C33      		cpi r24,lo8(60)
 3141 0c56 04F0      		brlt .L163
1996:iv.c          ****     time_m = time_m - 60;
 3143               	.LM317:
 3144 0c58 8091 0000 		lds r24,time_m
 3145 0c5c 8C53      		subi r24,lo8(-(-60))
 3146 0c5e 8093 0000 		sts time_m,r24
1997:iv.c          ****     time_h++; 
 3148               	.LM318:
 3149 0c62 8091 0000 		lds r24,time_h
 3150 0c66 8F5F      		subi r24,lo8(-(1))
 3151 0c68 8093 0000 		sts time_h,r24
1998:iv.c          ****     // let's write the time to the EEPROM
1999:iv.c          ****     eeprom_write_byte((uint8_t *)EE_HOUR, time_h);
 3153               	.LM319:
 3154 0c6c 6091 0000 		lds r22,time_h
 3155 0c70 84E0      		ldi r24,lo8(4)
 3156 0c72 90E0      		ldi r25,hi8(4)
 3157 0c74 0E94 0000 		call __eewr_byte_m168
2000:iv.c          ****     eeprom_write_byte((uint8_t *)EE_MIN, time_m);
 3159               	.LM320:
 3160 0c78 6091 0000 		lds r22,time_m
 3161 0c7c 85E0      		ldi r24,lo8(5)
 3162 0c7e 90E0      		ldi r25,hi8(5)
 3163 0c80 0E94 0000 		call __eewr_byte_m168
 3164               	.L163:
2001:iv.c          ****   }
2002:iv.c          ****   // When offsets create negative minutes...
2003:iv.c          ****   if (time_m < 0) {
 3166               	.LM321:
 3167 0c84 8091 0000 		lds r24,time_m
 3168 0c88 87FF      		sbrs r24,7
 3169 0c8a 00C0      		rjmp .L164
2004:iv.c          ****     time_m = 60 + time_m;
 3171               	.LM322:
 3172 0c8c 8091 0000 		lds r24,time_m
 3173 0c90 845C      		subi r24,lo8(-(60))
 3174 0c92 8093 0000 		sts time_m,r24
2005:iv.c          ****     time_h--; 
 3176               	.LM323:
 3177 0c96 8091 0000 		lds r24,time_h
 3178 0c9a 8150      		subi r24,lo8(-(-1))
 3179 0c9c 8093 0000 		sts time_h,r24
2006:iv.c          ****     eeprom_write_byte((uint8_t *)EE_HOUR, time_h);
 3181               	.LM324:
 3182 0ca0 6091 0000 		lds r22,time_h
 3183 0ca4 84E0      		ldi r24,lo8(4)
 3184 0ca6 90E0      		ldi r25,hi8(4)
 3185 0ca8 0E94 0000 		call __eewr_byte_m168
2007:iv.c          ****     eeprom_write_byte((uint8_t *)EE_MIN, time_m);
 3187               	.LM325:
 3188 0cac 6091 0000 		lds r22,time_m
 3189 0cb0 85E0      		ldi r24,lo8(5)
 3190 0cb2 90E0      		ldi r25,hi8(5)
 3191 0cb4 0E94 0000 		call __eewr_byte_m168
 3192               	.L164:
2008:iv.c          ****   }
2009:iv.c          **** 
2010:iv.c          ****   // a day....
2011:iv.c          ****   if (time_h >= 24) {
 3194               	.LM326:
 3195 0cb8 8091 0000 		lds r24,time_h
 3196 0cbc 8831      		cpi r24,lo8(24)
 3197 0cbe 04F0      		brlt .L165
2012:iv.c          ****     time_h = time_h - 24;
 3199               	.LM327:
 3200 0cc0 8091 0000 		lds r24,time_h
 3201 0cc4 8851      		subi r24,lo8(-(-24))
 3202 0cc6 8093 0000 		sts time_h,r24
2013:iv.c          ****     date_d++;
 3204               	.LM328:
 3205 0cca 8091 0000 		lds r24,date_d
 3206 0cce 8F5F      		subi r24,lo8(-(1))
 3207 0cd0 8093 0000 		sts date_d,r24
2014:iv.c          ****     eeprom_write_byte((uint8_t *)EE_DAY, date_d);
 3209               	.LM329:
 3210 0cd4 6091 0000 		lds r22,date_d
 3211 0cd8 83E0      		ldi r24,lo8(3)
 3212 0cda 90E0      		ldi r25,hi8(3)
 3213 0cdc 0E94 0000 		call __eewr_byte_m168
 3214               	.L165:
2015:iv.c          ****   }
2016:iv.c          ****   // When offsets create negative hours...
2017:iv.c          ****   if (time_h < 0) {
 3216               	.LM330:
 3217 0ce0 8091 0000 		lds r24,time_h
 3218 0ce4 87FF      		sbrs r24,7
 3219 0ce6 00C0      		rjmp .L166
2018:iv.c          ****     time_h = 24 + time_h;
 3221               	.LM331:
 3222 0ce8 8091 0000 		lds r24,time_h
 3223 0cec 885E      		subi r24,lo8(-(24))
 3224 0cee 8093 0000 		sts time_h,r24
2019:iv.c          ****     date_d--;
 3226               	.LM332:
 3227 0cf2 8091 0000 		lds r24,date_d
 3228 0cf6 8150      		subi r24,lo8(-(-1))
 3229 0cf8 8093 0000 		sts date_d,r24
2020:iv.c          ****     eeprom_write_byte((uint8_t *)EE_DAY, date_d);
 3231               	.LM333:
 3232 0cfc 6091 0000 		lds r22,date_d
 3233 0d00 83E0      		ldi r24,lo8(3)
 3234 0d02 90E0      		ldi r25,hi8(3)
 3235 0d04 0E94 0000 		call __eewr_byte_m168
 3236               	.L166:
2021:iv.c          ****   }
2022:iv.c          ****   
2023:iv.c          ****   //if (! sleepmode) {
2024:iv.c          ****   //  uart_putw_dec(time_h);
2025:iv.c          ****   //  uart_putchar(':');
2026:iv.c          ****   //  uart_putw_dec(time_m);
2027:iv.c          ****   //  uart_putchar(':');
2028:iv.c          ****   //  uart_putw_dec(time_s);
2029:iv.c          ****   //  putstring_nl("");
2030:iv.c          ****   //}
2031:iv.c          ****   
2032:iv.c          **** 
2033:iv.c          ****   // a full month!
2034:iv.c          ****   // we check the leapyear and date to verify when it's time to roll over months
2035:iv.c          ****   if ((date_d > 31) ||
 3238               	.LM334:
 3239 0d08 8091 0000 		lds r24,date_d
 3240 0d0c 8032      		cpi r24,lo8(32)
 3241 0d0e 04F4      		brge .L167
 3242 0d10 8091 0000 		lds r24,date_d
 3243 0d14 8F31      		cpi r24,lo8(31)
 3244 0d16 01F4      		brne .L168
 3245 0d18 8091 0000 		lds r24,date_m
 3246 0d1c 8430      		cpi r24,lo8(4)
 3247 0d1e 01F0      		breq .L167
 3248 0d20 8091 0000 		lds r24,date_m
 3249 0d24 8630      		cpi r24,lo8(6)
 3250 0d26 01F0      		breq .L167
 3251 0d28 8091 0000 		lds r24,date_m
 3252 0d2c 8930      		cpi r24,lo8(9)
 3253 0d2e 01F0      		breq .L167
 3254 0d30 8091 0000 		lds r24,date_m
 3255 0d34 8B30      		cpi r24,lo8(11)
 3256 0d36 01F0      		breq .L167
 3257               	.L168:
 3258 0d38 8091 0000 		lds r24,date_d
 3259 0d3c 8E31      		cpi r24,lo8(30)
 3260 0d3e 01F4      		brne .L169
 3261 0d40 8091 0000 		lds r24,date_m
 3262 0d44 8230      		cpi r24,lo8(2)
 3263 0d46 01F0      		breq .L167
 3264               	.L169:
 3265 0d48 8091 0000 		lds r24,date_d
 3266 0d4c 8D31      		cpi r24,lo8(29)
 3267 0d4e 01F4      		brne .L170
 3268 0d50 8091 0000 		lds r24,date_m
 3269 0d54 8230      		cpi r24,lo8(2)
 3270 0d56 01F4      		brne .L170
 3271 0d58 8091 0000 		lds r24,date_y
 3272 0d5c 9927      		clr r25
 3273 0d5e 87FD      		sbrc r24,7
 3274 0d60 9095      		com r25
 3275 0d62 8053      		subi r24,lo8(-(2000))
 3276 0d64 984F      		sbci r25,hi8(-(2000))
 3277 0d66 0E94 0000 		call leapyear
 3278 0d6a 8823      		tst r24
 3279 0d6c 01F4      		brne .L170
 3280               	.L167:
2036:iv.c          ****       ((date_d == 31) && ((date_m == 4)||(date_m == 6)||(date_m == 9)||(date_m == 11))) ||
2037:iv.c          ****       ((date_d == 30) && (date_m == 2)) ||
2038:iv.c          ****       ((date_d == 29) && (date_m == 2) && !leapyear(2000+date_y))) {
2039:iv.c          ****     date_d = 1;
 3282               	.LM335:
 3283 0d6e 81E0      		ldi r24,lo8(1)
 3284 0d70 8093 0000 		sts date_d,r24
2040:iv.c          ****     date_m++;
 3286               	.LM336:
 3287 0d74 8091 0000 		lds r24,date_m
 3288 0d78 8F5F      		subi r24,lo8(-(1))
 3289 0d7a 8093 0000 		sts date_m,r24
2041:iv.c          ****     eeprom_write_byte((uint8_t *)EE_MONTH, date_m);
 3291               	.LM337:
 3292 0d7e 6091 0000 		lds r22,date_m
 3293 0d82 82E0      		ldi r24,lo8(2)
 3294 0d84 90E0      		ldi r25,hi8(2)
 3295 0d86 0E94 0000 		call __eewr_byte_m168
 3296               	.L170:
2042:iv.c          ****   }
2043:iv.c          ****   // When offsets create negative days...
2044:iv.c          ****   if (date_d < 1) {
 3298               	.LM338:
 3299 0d8a 8091 0000 		lds r24,date_d
 3300 0d8e 1816      		cp __zero_reg__,r24
 3301 0d90 04F4      		brge .+2
 3302 0d92 00C0      		rjmp .L171
2045:iv.c          ****     //Find which month we are going back to:
2046:iv.c          ****     switch (date_m) {
 3304               	.LM339:
 3305 0d94 8091 0000 		lds r24,date_m
 3306 0d98 8630      		cpi r24,lo8(6)
 3307 0d9a 01F0      		breq .L173
 3308 0d9c 8730      		cpi r24,lo8(7)
 3309 0d9e 04F4      		brge .L176
 3310 0da0 8330      		cpi r24,lo8(3)
 3311 0da2 01F0      		breq .L174
 3312 0da4 8430      		cpi r24,lo8(4)
 3313 0da6 04F4      		brge .L177
 3314 0da8 8130      		cpi r24,lo8(1)
 3315 0daa 04F4      		brge .L173
 3316 0dac 00C0      		rjmp .L172
 3317               	.L177:
 3318 0dae 8430      		cpi r24,lo8(4)
 3319 0db0 01F0      		breq .L173
 3320 0db2 8530      		cpi r24,lo8(5)
 3321 0db4 01F4      		brne .L172
 3322 0db6 00C0      		rjmp .L175
 3323               	.L176:
 3324 0db8 8A30      		cpi r24,lo8(10)
 3325 0dba 04F4      		brge .L178
 3326 0dbc 8830      		cpi r24,lo8(8)
 3327 0dbe 04F4      		brge .L173
 3328 0dc0 00C0      		rjmp .L175
 3329               	.L178:
 3330 0dc2 8B30      		cpi r24,lo8(11)
 3331 0dc4 01F0      		breq .L173
 3332 0dc6 8B30      		cpi r24,lo8(11)
 3333 0dc8 04F0      		brlt .L175
 3334 0dca 8C30      		cpi r24,lo8(12)
 3335 0dcc 01F4      		brne .L172
 3336 0dce 00C0      		rjmp .L175
 3337               	.L173:
2047:iv.c          ****       case 1: //January -> December
2048:iv.c          ****       case 2: //February -> January
2049:iv.c          ****       case 4: //April -> March
2050:iv.c          ****       case 6: //June -> May
2051:iv.c          ****       case 8: //August -> July
2052:iv.c          ****       case 9: //September -> August
2053:iv.c          ****       case 11: //November -> October
2054:iv.c          ****         date_d = 31 + date_d;
 3339               	.LM340:
 3340 0dd0 8091 0000 		lds r24,date_d
 3341 0dd4 815E      		subi r24,lo8(-(31))
 3342 0dd6 00C0      		rjmp .L186
 3343               	.L175:
2055:iv.c          ****         date_m--;
2056:iv.c          ****         break;
2057:iv.c          **** 
2058:iv.c          ****       case 5: //May -> April
2059:iv.c          ****       case 7: //July -> June
2060:iv.c          ****       case 10: //October -> September
2061:iv.c          ****       case 12: //December -> November
2062:iv.c          ****         date_d = 30 + date_d;
 3345               	.LM341:
 3346 0dd8 8091 0000 		lds r24,date_d
 3347 0ddc 825E      		subi r24,lo8(-(30))
 3348               	.L186:
 3349 0dde 8093 0000 		sts date_d,r24
2063:iv.c          ****         date_m--;
 3351               	.LM342:
 3352 0de2 8091 0000 		lds r24,date_m
 3353 0de6 8150      		subi r24,lo8(-(-1))
 3354 0de8 8093 0000 		sts date_m,r24
 3355 0dec 00C0      		rjmp .L179
 3356               	.L174:
2064:iv.c          ****         break;
2065:iv.c          **** 
2066:iv.c          ****       case 3: //March -> February, the fun case
2067:iv.c          ****         //If we are in a leapyear, February is 29 days long...
2068:iv.c          ****         if ( leapyear(2000+date_y) )
 3358               	.LM343:
 3359 0dee 8091 0000 		lds r24,date_y
 3360 0df2 9927      		clr r25
 3361 0df4 87FD      		sbrc r24,7
 3362 0df6 9095      		com r25
 3363 0df8 8053      		subi r24,lo8(-(2000))
 3364 0dfa 984F      		sbci r25,hi8(-(2000))
 3365 0dfc 0E94 0000 		call leapyear
 3366 0e00 8823      		tst r24
 3367 0e02 01F0      		breq .L180
2069:iv.c          ****           date_d = 29 + date_d;
 3369               	.LM344:
 3370 0e04 8091 0000 		lds r24,date_d
 3371 0e08 835E      		subi r24,lo8(-(29))
 3372 0e0a 00C0      		rjmp .L186
 3373               	.L180:
2070:iv.c          ****         else //otherwise, it is 28 days long...
2071:iv.c          ****           date_d = 28 + date_d;
 3375               	.LM345:
 3376 0e0c 8091 0000 		lds r24,date_d
 3377 0e10 845E      		subi r24,lo8(-(28))
 3378 0e12 00C0      		rjmp .L186
 3379               	.L172:
2072:iv.c          ****         date_m--;
2073:iv.c          ****         break;
2074:iv.c          ****       default:
2075:iv.c          ****         date_d = 1;
 3381               	.LM346:
 3382 0e14 81E0      		ldi r24,lo8(1)
 3383 0e16 8093 0000 		sts date_d,r24
 3384               	.L179:
2076:iv.c          ****         break;
2077:iv.c          ****     }
2078:iv.c          **** 
2079:iv.c          ****     eeprom_write_byte((uint8_t *)EE_MONTH, date_m);
 3386               	.LM347:
 3387 0e1a 6091 0000 		lds r22,date_m
 3388 0e1e 82E0      		ldi r24,lo8(2)
 3389 0e20 90E0      		ldi r25,hi8(2)
 3390 0e22 0E94 0000 		call __eewr_byte_m168
 3391               	.L171:
2080:iv.c          ****   }
2081:iv.c          ****   
2082:iv.c          ****   // HAPPY NEW YEAR!
2083:iv.c          ****   if (date_m >= 13) {
 3393               	.LM348:
 3394 0e26 8091 0000 		lds r24,date_m
 3395 0e2a 8D30      		cpi r24,lo8(13)
 3396 0e2c 04F0      		brlt .L182
2084:iv.c          ****     date_y++;
 3398               	.LM349:
 3399 0e2e 8091 0000 		lds r24,date_y
 3400 0e32 8F5F      		subi r24,lo8(-(1))
 3401 0e34 8093 0000 		sts date_y,r24
2085:iv.c          ****     date_m = 1;
 3403               	.LM350:
 3404 0e38 81E0      		ldi r24,lo8(1)
 3405 0e3a 8093 0000 		sts date_m,r24
2086:iv.c          ****     eeprom_write_byte((uint8_t *)EE_YEAR, date_y);
 3407               	.LM351:
 3408 0e3e 6091 0000 		lds r22,date_y
 3409 0e42 81E0      		ldi r24,lo8(1)
 3410 0e44 90E0      		ldi r25,hi8(1)
 3411 0e46 0E94 0000 		call __eewr_byte_m168
 3412               	.L182:
2087:iv.c          ****   }
2088:iv.c          ****   //This takes away the years and is cheaper than any cream you can buy...
2089:iv.c          ****   if (date_m < 1) {
 3414               	.LM352:
 3415 0e4a 8091 0000 		lds r24,date_m
 3416 0e4e 1816      		cp __zero_reg__,r24
 3417 0e50 04F0      		brlt .L184
2090:iv.c          ****     date_m = 12 + date_m;
 3419               	.LM353:
 3420 0e52 8091 0000 		lds r24,date_m
 3421 0e56 845F      		subi r24,lo8(-(12))
 3422 0e58 8093 0000 		sts date_m,r24
2091:iv.c          ****     date_y--;
 3424               	.LM354:
 3425 0e5c 8091 0000 		lds r24,date_y
 3426 0e60 8150      		subi r24,lo8(-(-1))
 3427 0e62 8093 0000 		sts date_y,r24
2092:iv.c          ****     eeprom_write_byte((uint8_t *)EE_MONTH, date_m);
 3429               	.LM355:
 3430 0e66 6091 0000 		lds r22,date_m
 3431 0e6a 82E0      		ldi r24,lo8(2)
 3432 0e6c 90E0      		ldi r25,hi8(2)
 3433 0e6e 0E94 0000 		call __eewr_byte_m168
2093:iv.c          ****     eeprom_write_byte((uint8_t *)EE_YEAR, date_y);
 3435               	.LM356:
 3436 0e72 6091 0000 		lds r22,date_y
 3437 0e76 81E0      		ldi r24,lo8(1)
 3438 0e78 90E0      		ldi r25,hi8(1)
 3439 0e7a 0E94 0000 		call __eewr_byte_m168
 3440               	.L184:
 3441 0e7e 0895      		ret
 3443               	.Lscope27:
 3445               		.stabd	78,0,0
 3446               		.data
 3447               	.LC19:
 3448 0077 6272 6974 		.string	"brite "
 3448      6520 00
 3449               		.text
 3451               	.global	set_brightness
 3453               	set_brightness:
 3454               		.stabd	46,0,0
1039:iv.c          **** void set_brightness(void) {
 3456               	.LM357:
 3457               	.LFBB28:
 3458 0e80 FF92      		push r15
 3459 0e82 0F93      		push r16
 3460 0e84 1F93      		push r17
 3461               	/* prologue: function */
 3462               	/* frame size = 0 */
1042:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;;  
 3464               	.LM358:
 3465 0e86 8AE0      		ldi r24,lo8(10)
 3466 0e88 8093 0000 		sts timeoutcounter,r24
 3467 0e8c 10E0      		ldi r17,lo8(0)
1046:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
 3469               	.LM359:
 3470 0e8e 3AE0      		ldi r19,lo8(10)
 3471 0e90 F32E      		mov r15,r19
1077:iv.c          **** 	  brightness_level = BRIGHTNESS_MIN;
 3473               	.LM360:
 3474 0e92 0EE1      		ldi r16,lo8(30)
 3475 0e94 00C0      		rjmp .L204
 3476               	.L198:
1042:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;;  
 3478               	.LM361:
 3479 0e96 10E0      		ldi r17,lo8(0)
 3480               	.L204:
1045:iv.c          ****     if (just_pressed || pressed) {
 3482               	.LM362:
 3483 0e98 8091 0000 		lds r24,just_pressed
 3484 0e9c 8823      		tst r24
 3485 0e9e 01F4      		brne .L191
 3486 0ea0 8091 0000 		lds r24,pressed
 3487 0ea4 8823      		tst r24
 3488 0ea6 01F0      		breq .L192
 3489               	.L191:
1046:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
 3491               	.LM363:
 3492 0ea8 F092 0000 		sts timeoutcounter,r15
 3493 0eac 00C0      		rjmp .L193
 3494               	.L192:
1048:iv.c          ****     } else if (!timeoutcounter) {
 3496               	.LM364:
 3497 0eae 8091 0000 		lds r24,timeoutcounter
 3498 0eb2 8823      		tst r24
 3499 0eb4 01F0      		breq .L196
 3500               	.L193:
1054:iv.c          ****     if (just_pressed & 0x1) { // mode change
 3502               	.LM365:
 3503 0eb6 8091 0000 		lds r24,just_pressed
 3504 0eba 80FD      		sbrc r24,0
 3505 0ebc 00C0      		rjmp .L201
1057:iv.c          ****     if (just_pressed & 0x2) {
 3507               	.LM366:
 3508 0ebe 8091 0000 		lds r24,just_pressed
 3509 0ec2 81FF      		sbrs r24,1
 3510 0ec4 00C0      		rjmp .L195
1059:iv.c          ****       just_pressed = 0;
 3512               	.LM367:
 3513 0ec6 1092 0000 		sts just_pressed,__zero_reg__
1060:iv.c          ****       if (mode == SHOW_MENU) {
 3515               	.LM368:
 3516 0eca 1123      		tst r17
 3517 0ecc 01F4      		brne .L196
1064:iv.c          **** 	display_str("brite ");
 3519               	.LM369:
 3520 0ece 80E0      		ldi r24,lo8(.LC19)
 3521 0ed0 90E0      		ldi r25,hi8(.LC19)
 3522 0ed2 0E94 0000 		call display_str
1065:iv.c          **** 	display_brightness(brightness_level);
 3524               	.LM370:
 3525 0ed6 8091 0000 		lds r24,brightness_level
 3526 0eda 90E0      		ldi r25,lo8(0)
 3527 0edc 0E94 0000 		call display_brightness
 3528 0ee0 11E0      		ldi r17,lo8(1)
 3529 0ee2 00C0      		rjmp .L195
 3530               	.L196:
1067:iv.c          **** 	displaymode = SHOW_TIME;
 3532               	.LM371:
 3533 0ee4 1092 0000 		sts displaymode,__zero_reg__
1068:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_BRIGHT, brightness_level);
 3535               	.LM372:
 3536 0ee8 6091 0000 		lds r22,brightness_level
 3537 0eec 89E0      		ldi r24,lo8(9)
 3538 0eee 90E0      		ldi r25,hi8(9)
 3539 0ef0 0E94 0000 		call __eewr_byte_m168
 3540 0ef4 00C0      		rjmp .L201
 3541               	.L195:
1072:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
 3543               	.LM373:
 3544 0ef6 8091 0000 		lds r24,just_pressed
 3545 0efa 82FD      		sbrc r24,2
 3546 0efc 00C0      		rjmp .L197
 3547 0efe 8091 0000 		lds r24,pressed
 3548 0f02 82FF      		sbrs r24,2
 3549 0f04 00C0      		rjmp .L204
 3550               	.L197:
1073:iv.c          ****       just_pressed = 0;
 3552               	.LM374:
 3553 0f06 1092 0000 		sts just_pressed,__zero_reg__
1074:iv.c          ****       if (mode == SET_BRITE) {
 3555               	.LM375:
 3556 0f0a 1130      		cpi r17,lo8(1)
 3557 0f0c 01F4      		brne .L198
1076:iv.c          **** 	if (brightness_level == 0) {
 3559               	.LM376:
 3560 0f0e 8091 0000 		lds r24,brightness_level
 3561 0f12 8823      		tst r24
 3562 0f14 01F4      		brne .L199
1077:iv.c          **** 	  brightness_level = BRIGHTNESS_MIN;
 3564               	.LM377:
 3565 0f16 0093 0000 		sts brightness_level,r16
 3566 0f1a 00C0      		rjmp .L200
 3567               	.L199:
1079:iv.c          **** 	  brightness_level += BRIGHTNESS_INCREMENT;
 3569               	.LM378:
 3570 0f1c 8091 0000 		lds r24,brightness_level
 3571 0f20 8B5F      		subi r24,lo8(-(5))
 3572 0f22 8093 0000 		sts brightness_level,r24
1080:iv.c          **** 	  if (brightness_level > BRIGHTNESS_MAX) {
 3574               	.LM379:
 3575 0f26 8091 0000 		lds r24,brightness_level
 3576 0f2a 8B35      		cpi r24,lo8(91)
 3577 0f2c 00F0      		brlo .L200
1082:iv.c          **** 	    brightness_level = 0;
 3579               	.LM380:
 3580 0f2e 1092 0000 		sts brightness_level,__zero_reg__
 3581               	.L200:
1088:iv.c          **** 	display_brightness(brightness_level);
 3583               	.LM381:
 3584 0f32 8091 0000 		lds r24,brightness_level
 3585 0f36 90E0      		ldi r25,lo8(0)
 3586 0f38 0E94 0000 		call display_brightness
 3587 0f3c 00C0      		rjmp .L204
 3588               	.L201:
 3589               	/* epilogue start */
1092:iv.c          **** }
 3591               	.LM382:
 3592 0f3e 1F91      		pop r17
 3593 0f40 0F91      		pop r16
 3594 0f42 FF90      		pop r15
 3595 0f44 0895      		ret
 3600               	.Lscope28:
 3602               		.stabd	78,0,0
 3604               	.global	set_time
 3606               	set_time:
 3607               		.stabd	46,0,0
 782:iv.c          **** {
 3609               	.LM383:
 3610               	.LFBB29:
 3611 0f46 DF92      		push r13
 3612 0f48 EF92      		push r14
 3613 0f4a FF92      		push r15
 3614 0f4c 0F93      		push r16
 3615 0f4e 1F93      		push r17
 3616               	/* prologue: function */
 3617               	/* frame size = 0 */
 786:iv.c          ****   hour = time_h;
 3619               	.LM384:
 3620 0f50 E090 0000 		lds r14,time_h
 787:iv.c          ****   min = time_m;
 3622               	.LM385:
 3623 0f54 F090 0000 		lds r15,time_m
 788:iv.c          ****   sec = time_s;
 3625               	.LM386:
 3626 0f58 0091 0000 		lds r16,time_s
 791:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;
 3628               	.LM387:
 3629 0f5c 8AE0      		ldi r24,lo8(10)
 3630 0f5e 8093 0000 		sts timeoutcounter,r24
 3631 0f62 10E0      		ldi r17,lo8(0)
 798:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;  
 3633               	.LM388:
 3634 0f64 4AE0      		ldi r20,lo8(10)
 3635 0f66 D42E      		mov r13,r20
 3636               	.L224:
 794:iv.c          ****     if (just_pressed & 0x1) { // mode change
 3638               	.LM389:
 3639 0f68 8091 0000 		lds r24,just_pressed
 3640 0f6c 80FD      		sbrc r24,0
 3641 0f6e 00C0      		rjmp .L220
 797:iv.c          ****     if (just_pressed || pressed) {
 3643               	.LM390:
 3644 0f70 8091 0000 		lds r24,just_pressed
 3645 0f74 8823      		tst r24
 3646 0f76 01F4      		brne .L207
 3647 0f78 8091 0000 		lds r24,pressed
 3648 0f7c 8823      		tst r24
 3649 0f7e 01F0      		breq .L208
 3650               	.L207:
 798:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;  
 3652               	.LM391:
 3653 0f80 D092 0000 		sts timeoutcounter,r13
 3654 0f84 00C0      		rjmp .L209
 3655               	.L208:
 800:iv.c          ****     } else if (!timeoutcounter) {
 3657               	.LM392:
 3658 0f86 8091 0000 		lds r24,timeoutcounter
 3659 0f8a 8823      		tst r24
 3660 0f8c 01F4      		brne .+2
 3661 0f8e 00C0      		rjmp .L225
 3662               	.L209:
 805:iv.c          ****     if (just_pressed & 0x2) {
 3664               	.LM393:
 3665 0f90 8091 0000 		lds r24,just_pressed
 3666 0f94 81FF      		sbrs r24,1
 3667 0f96 00C0      		rjmp .L210
 806:iv.c          ****       just_pressed = 0;
 3669               	.LM394:
 3670 0f98 1092 0000 		sts just_pressed,__zero_reg__
 807:iv.c          ****       if (mode == SHOW_MENU) {
 3672               	.LM395:
 3673 0f9c 1123      		tst r17
 3674 0f9e 01F4      		brne .L211
 808:iv.c          **** 	hour = time_h;
 3676               	.LM396:
 3677 0fa0 E090 0000 		lds r14,time_h
 809:iv.c          **** 	min = time_m;
 3679               	.LM397:
 3680 0fa4 F090 0000 		lds r15,time_m
 810:iv.c          **** 	sec = time_s;
 3682               	.LM398:
 3683 0fa8 0091 0000 		lds r16,time_s
 814:iv.c          **** 	display_time(hour, min, sec);
 3685               	.LM399:
 3686 0fac 8E2D      		mov r24,r14
 3687 0fae 6F2D      		mov r22,r15
 3688 0fb0 402F      		mov r20,r16
 3689 0fb2 0E94 0000 		call display_time
 815:iv.c          **** 	display[1] |= 0x1;
 3691               	.LM400:
 3692 0fb6 8091 0000 		lds r24,display+1
 3693 0fba 8160      		ori r24,lo8(1)
 3694 0fbc 8093 0000 		sts display+1,r24
 816:iv.c          **** 	display[2] |= 0x1;	
 3696               	.LM401:
 3697 0fc0 8091 0000 		lds r24,display+2
 3698 0fc4 8160      		ori r24,lo8(1)
 3699 0fc6 8093 0000 		sts display+2,r24
 3700 0fca 11E0      		ldi r17,lo8(1)
 3701 0fcc 00C0      		rjmp .L210
 3702               	.L211:
 817:iv.c          ****       } else if (mode == SET_HOUR) {
 3704               	.LM402:
 3705 0fce 1130      		cpi r17,lo8(1)
 3706 0fd0 01F4      		brne .L212
 819:iv.c          **** 	display_time(hour, min, sec);
 3708               	.LM403:
 3709 0fd2 8E2D      		mov r24,r14
 3710 0fd4 6F2D      		mov r22,r15
 3711 0fd6 402F      		mov r20,r16
 3712 0fd8 0E94 0000 		call display_time
 820:iv.c          **** 	display[4] |= 0x1;
 3714               	.LM404:
 3715 0fdc 8091 0000 		lds r24,display+4
 3716 0fe0 8160      		ori r24,lo8(1)
 3717 0fe2 8093 0000 		sts display+4,r24
 821:iv.c          **** 	display[5] |= 0x1;
 3719               	.LM405:
 3720 0fe6 8091 0000 		lds r24,display+5
 3721 0fea 8160      		ori r24,lo8(1)
 3722 0fec 8093 0000 		sts display+5,r24
 3723 0ff0 12E0      		ldi r17,lo8(2)
 3724 0ff2 00C0      		rjmp .L210
 3725               	.L212:
 822:iv.c          ****       } else if (mode == SET_MIN) {
 3727               	.LM406:
 3728 0ff4 1230      		cpi r17,lo8(2)
 3729 0ff6 01F4      		brne .L213
 824:iv.c          **** 	display_time(hour, min, sec);
 3731               	.LM407:
 3732 0ff8 8E2D      		mov r24,r14
 3733 0ffa 6F2D      		mov r22,r15
 3734 0ffc 402F      		mov r20,r16
 3735 0ffe 0E94 0000 		call display_time
 825:iv.c          **** 	display[7] |= 0x1;
 3737               	.LM408:
 3738 1002 8091 0000 		lds r24,display+7
 3739 1006 8160      		ori r24,lo8(1)
 3740 1008 8093 0000 		sts display+7,r24
 826:iv.c          **** 	display[8] |= 0x1;
 3742               	.LM409:
 3743 100c 8091 0000 		lds r24,display+8
 3744 1010 8160      		ori r24,lo8(1)
 3745 1012 8093 0000 		sts display+8,r24
 3746 1016 13E0      		ldi r17,lo8(3)
 3747 1018 00C0      		rjmp .L210
 3748               	.L213:
 829:iv.c          **** 	time_h = hour;
 3750               	.LM410:
 3751 101a E092 0000 		sts time_h,r14
 830:iv.c          **** 	time_m = min;
 3753               	.LM411:
 3754 101e F092 0000 		sts time_m,r15
 831:iv.c          **** 	time_s = sec;
 3756               	.LM412:
 3757 1022 0093 0000 		sts time_s,r16
 3758               	.L225:
 832:iv.c          **** 	displaymode = SHOW_TIME;
 3760               	.LM413:
 3761 1026 1092 0000 		sts displaymode,__zero_reg__
 3762 102a 00C0      		rjmp .L220
 3763               	.L210:
 836:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
 3765               	.LM414:
 3766 102c 8091 0000 		lds r24,just_pressed
 3767 1030 82FD      		sbrc r24,2
 3768 1032 00C0      		rjmp .L214
 3769 1034 8091 0000 		lds r24,pressed
 3770 1038 82FF      		sbrs r24,2
 3771 103a 00C0      		rjmp .L224
 3772               	.L214:
 837:iv.c          ****       just_pressed = 0;
 3774               	.LM415:
 3775 103c 1092 0000 		sts just_pressed,__zero_reg__
 839:iv.c          ****       if (mode == SET_HOUR) {
 3777               	.LM416:
 3778 1040 1130      		cpi r17,lo8(1)
 3779 1042 01F4      		brne .L216
 840:iv.c          **** 	hour = (hour+1) % 24;
 3781               	.LM417:
 3782 1044 8E2D      		mov r24,r14
 3783 1046 90E0      		ldi r25,lo8(0)
 3784 1048 0196      		adiw r24,1
 3785 104a 68E1      		ldi r22,lo8(24)
 3786 104c 70E0      		ldi r23,hi8(24)
 3787 104e 0E94 0000 		call __divmodhi4
 3788 1052 E82E      		mov r14,r24
 841:iv.c          **** 	display_time(hour, min, sec);
 3790               	.LM418:
 3791 1054 6F2D      		mov r22,r15
 3792 1056 402F      		mov r20,r16
 3793 1058 0E94 0000 		call display_time
 842:iv.c          **** 	display[1] |= 0x1;
 3795               	.LM419:
 3796 105c 8091 0000 		lds r24,display+1
 3797 1060 8160      		ori r24,lo8(1)
 3798 1062 8093 0000 		sts display+1,r24
 843:iv.c          **** 	display[2] |= 0x1;
 3800               	.LM420:
 3801 1066 8091 0000 		lds r24,display+2
 3802 106a 8160      		ori r24,lo8(1)
 3803 106c 8093 0000 		sts display+2,r24
 844:iv.c          **** 	time_h = hour;
 3805               	.LM421:
 3806 1070 E092 0000 		sts time_h,r14
 845:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_HOUR, time_h);    
 3808               	.LM422:
 3809 1074 6091 0000 		lds r22,time_h
 3810 1078 84E0      		ldi r24,lo8(4)
 3811 107a 90E0      		ldi r25,hi8(4)
 3812 107c 0E94 0000 		call __eewr_byte_m168
 3813 1080 00C0      		rjmp .L217
 3814               	.L216:
 847:iv.c          ****       if (mode == SET_MIN) {
 3816               	.LM423:
 3817 1082 1230      		cpi r17,lo8(2)
 3818 1084 01F4      		brne .L218
 848:iv.c          **** 	min = (min+1) % 60;
 3820               	.LM424:
 3821 1086 8F2D      		mov r24,r15
 3822 1088 90E0      		ldi r25,lo8(0)
 3823 108a 0196      		adiw r24,1
 3824 108c 6CE3      		ldi r22,lo8(60)
 3825 108e 70E0      		ldi r23,hi8(60)
 3826 1090 0E94 0000 		call __divmodhi4
 3827 1094 F82E      		mov r15,r24
 849:iv.c          **** 	display_time(hour, min, sec);
 3829               	.LM425:
 3830 1096 8E2D      		mov r24,r14
 3831 1098 6F2D      		mov r22,r15
 3832 109a 402F      		mov r20,r16
 3833 109c 0E94 0000 		call display_time
 850:iv.c          **** 	display[4] |= 0x1;
 3835               	.LM426:
 3836 10a0 8091 0000 		lds r24,display+4
 3837 10a4 8160      		ori r24,lo8(1)
 3838 10a6 8093 0000 		sts display+4,r24
 851:iv.c          **** 	display[5] |= 0x1;
 3840               	.LM427:
 3841 10aa 8091 0000 		lds r24,display+5
 3842 10ae 8160      		ori r24,lo8(1)
 3843 10b0 8093 0000 		sts display+5,r24
 852:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_MIN, time_m);
 3845               	.LM428:
 3846 10b4 6091 0000 		lds r22,time_m
 3847 10b8 85E0      		ldi r24,lo8(5)
 3848 10ba 90E0      		ldi r25,hi8(5)
 3849 10bc 0E94 0000 		call __eewr_byte_m168
 853:iv.c          **** 	time_m = min;
 3851               	.LM429:
 3852 10c0 F092 0000 		sts time_m,r15
 3853 10c4 00C0      		rjmp .L217
 3854               	.L218:
 855:iv.c          ****       if ((mode == SET_SEC) ) {
 3856               	.LM430:
 3857 10c6 1330      		cpi r17,lo8(3)
 3858 10c8 01F4      		brne .L217
 856:iv.c          **** 	sec = (sec+1) % 60;
 3860               	.LM431:
 3861 10ca 802F      		mov r24,r16
 3862 10cc 90E0      		ldi r25,lo8(0)
 3863 10ce 0196      		adiw r24,1
 3864 10d0 6CE3      		ldi r22,lo8(60)
 3865 10d2 70E0      		ldi r23,hi8(60)
 3866 10d4 0E94 0000 		call __divmodhi4
 3867 10d8 082F      		mov r16,r24
 857:iv.c          **** 	display_time(hour, min, sec);
 3869               	.LM432:
 3870 10da 8E2D      		mov r24,r14
 3871 10dc 6F2D      		mov r22,r15
 3872 10de 402F      		mov r20,r16
 3873 10e0 0E94 0000 		call display_time
 858:iv.c          **** 	display[7] |= 0x1;
 3875               	.LM433:
 3876 10e4 8091 0000 		lds r24,display+7
 3877 10e8 8160      		ori r24,lo8(1)
 3878 10ea 8093 0000 		sts display+7,r24
 859:iv.c          **** 	display[8] |= 0x1;
 3880               	.LM434:
 3881 10ee 8091 0000 		lds r24,display+8
 3882 10f2 8160      		ori r24,lo8(1)
 3883 10f4 8093 0000 		sts display+8,r24
 860:iv.c          **** 	time_s = sec;
 3885               	.LM435:
 3886 10f8 0093 0000 		sts time_s,r16
 3887               	.L217:
 863:iv.c          ****       if (pressed & 0x4)
 3889               	.LM436:
 3890 10fc 8091 0000 		lds r24,pressed
 3891 1100 82FF      		sbrs r24,2
 3892 1102 00C0      		rjmp .L224
 3893               	.LBB201:
 3894               	.LBB202:
 116:iv.c          ****   sei();
 3896               	.LM437:
 3897               	/* #APP */
 3898               	 ;  116 "iv.c" 1
 3899 1104 7894      		sei
 3900               	 ;  0 "" 2
 118:iv.c          ****   milliseconds = 0;
 3902               	.LM438:
 3903               	/* #NOAPP */
 3904 1106 1092 0000 		sts (milliseconds)+1,__zero_reg__
 3905 110a 1092 0000 		sts milliseconds,__zero_reg__
 3906               	.L219:
 119:iv.c          ****   while (milliseconds < ms);
 3908               	.LM439:
 3909 110e 8091 0000 		lds r24,milliseconds
 3910 1112 9091 0000 		lds r25,(milliseconds)+1
 3911 1116 8B34      		cpi r24,75
 3912 1118 9105      		cpc r25,__zero_reg__
 3913 111a 00F0      		brlo .L219
 3914 111c 00C0      		rjmp .L224
 3915               	.L220:
 3916               	/* epilogue start */
 3917               	.LBE202:
 3918               	.LBE201:
 867:iv.c          **** }
 3920               	.LM440:
 3921 111e 1F91      		pop r17
 3922 1120 0F91      		pop r16
 3923 1122 FF90      		pop r15
 3924 1124 EF90      		pop r14
 3925 1126 DF90      		pop r13
 3926 1128 0895      		ret
 3934               	.Lscope29:
 3936               		.stabd	78,0,0
 3938               	.global	set_alarm
 3940               	set_alarm:
 3941               		.stabd	46,0,0
 707:iv.c          **** {
 3943               	.LM441:
 3944               	.LFBB30:
 3945 112a EF92      		push r14
 3946 112c FF92      		push r15
 3947 112e 0F93      		push r16
 3948 1130 1F93      		push r17
 3949               	/* prologue: function */
 3950               	/* frame size = 0 */
 714:iv.c          ****   hour = alarm_h;
 3952               	.LM442:
 3953 1132 1091 0000 		lds r17,alarm_h
 715:iv.c          ****   min = alarm_m;
 3955               	.LM443:
 3956 1136 0091 0000 		lds r16,alarm_m
 718:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;
 3958               	.LM444:
 3959 113a 8AE0      		ldi r24,lo8(10)
 3960 113c 8093 0000 		sts timeoutcounter,r24
 3961 1140 FF24      		clr r15
 725:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;  
 3963               	.LM445:
 3964 1142 6AE0      		ldi r22,lo8(10)
 3965 1144 E62E      		mov r14,r22
 3966               	.L243:
 721:iv.c          ****     if (just_pressed & 0x1) { // mode change
 3968               	.LM446:
 3969 1146 8091 0000 		lds r24,just_pressed
 3970 114a 80FD      		sbrc r24,0
 3971 114c 00C0      		rjmp .L239
 724:iv.c          ****     if (just_pressed || pressed) {
 3973               	.LM447:
 3974 114e 8091 0000 		lds r24,just_pressed
 3975 1152 8823      		tst r24
 3976 1154 01F4      		brne .L228
 3977 1156 8091 0000 		lds r24,pressed
 3978 115a 8823      		tst r24
 3979 115c 01F0      		breq .L229
 3980               	.L228:
 725:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;  
 3982               	.LM448:
 3983 115e E092 0000 		sts timeoutcounter,r14
 3984 1162 00C0      		rjmp .L230
 3985               	.L229:
 727:iv.c          ****     } else if (!timeoutcounter) {
 3987               	.LM449:
 3988 1164 8091 0000 		lds r24,timeoutcounter
 3989 1168 8823      		tst r24
 3990 116a 01F4      		brne .L230
 729:iv.c          ****       displaymode = SHOW_TIME;     
 3992               	.LM450:
 3993 116c 1092 0000 		sts displaymode,__zero_reg__
 730:iv.c          ****       alarm_h = hour;
 3995               	.LM451:
 3996 1170 1093 0000 		sts alarm_h,r17
 731:iv.c          ****       alarm_m = min;
 3998               	.LM452:
 3999 1174 0093 0000 		sts alarm_m,r16
 732:iv.c          ****       eeprom_write_byte((uint8_t *)EE_ALARM_HOUR, alarm_h);    
 4001               	.LM453:
 4002 1178 6091 0000 		lds r22,alarm_h
 4003 117c 87E0      		ldi r24,lo8(7)
 4004 117e 90E0      		ldi r25,hi8(7)
 4005 1180 0E94 0000 		call __eewr_byte_m168
 733:iv.c          ****       eeprom_write_byte((uint8_t *)EE_ALARM_MIN, alarm_m);    
 4007               	.LM454:
 4008 1184 6091 0000 		lds r22,alarm_m
 4009 1188 88E0      		ldi r24,lo8(8)
 4010 118a 90E0      		ldi r25,hi8(8)
 4011 118c 0E94 0000 		call __eewr_byte_m168
 4012 1190 00C0      		rjmp .L239
 4013               	.L230:
 736:iv.c          ****     if (just_pressed & 0x2) {
 4015               	.LM455:
 4016 1192 8091 0000 		lds r24,just_pressed
 4017 1196 81FF      		sbrs r24,1
 4018 1198 00C0      		rjmp .L231
 737:iv.c          ****       just_pressed = 0;
 4020               	.LM456:
 4021 119a 1092 0000 		sts just_pressed,__zero_reg__
 738:iv.c          ****       if (mode == SHOW_MENU) {
 4023               	.LM457:
 4024 119e FF20      		tst r15
 4025 11a0 01F4      		brne .L232
 741:iv.c          **** 	display_alarm(hour, min);
 4027               	.LM458:
 4028 11a2 812F      		mov r24,r17
 4029 11a4 602F      		mov r22,r16
 4030 11a6 0E94 0000 		call display_alarm
 742:iv.c          **** 	display[1] |= 0x1;
 4032               	.LM459:
 4033 11aa 8091 0000 		lds r24,display+1
 4034 11ae 8160      		ori r24,lo8(1)
 4035 11b0 8093 0000 		sts display+1,r24
 743:iv.c          **** 	display[2] |= 0x1;	
 4037               	.LM460:
 4038 11b4 8091 0000 		lds r24,display+2
 4039 11b8 8160      		ori r24,lo8(1)
 4040 11ba 8093 0000 		sts display+2,r24
 4041 11be FF24      		clr r15
 4042 11c0 F394      		inc r15
 4043 11c2 00C0      		rjmp .L231
 4044               	.L232:
 744:iv.c          ****       } else if (mode == SET_HOUR) {
 4046               	.LM461:
 4047 11c4 81E0      		ldi r24,lo8(1)
 4048 11c6 F816      		cp r15,r24
 4049 11c8 01F4      		brne .L233
 746:iv.c          **** 	display_alarm(hour, min);
 4051               	.LM462:
 4052 11ca 812F      		mov r24,r17
 4053 11cc 602F      		mov r22,r16
 4054 11ce 0E94 0000 		call display_alarm
 747:iv.c          **** 	display[4] |= 0x1;
 4056               	.LM463:
 4057 11d2 8091 0000 		lds r24,display+4
 4058 11d6 8160      		ori r24,lo8(1)
 4059 11d8 8093 0000 		sts display+4,r24
 748:iv.c          **** 	display[5] |= 0x1;
 4061               	.LM464:
 4062 11dc 8091 0000 		lds r24,display+5
 4063 11e0 8160      		ori r24,lo8(1)
 4064 11e2 8093 0000 		sts display+5,r24
 4065 11e6 52E0      		ldi r21,lo8(2)
 4066 11e8 F52E      		mov r15,r21
 4067 11ea 00C0      		rjmp .L231
 4068               	.L233:
 751:iv.c          **** 	alarm_h = hour;
 4070               	.LM465:
 4071 11ec 1093 0000 		sts alarm_h,r17
 752:iv.c          **** 	alarm_m = min;
 4073               	.LM466:
 4074 11f0 0093 0000 		sts alarm_m,r16
 753:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_ALARM_HOUR, alarm_h);    
 4076               	.LM467:
 4077 11f4 6091 0000 		lds r22,alarm_h
 4078 11f8 87E0      		ldi r24,lo8(7)
 4079 11fa 90E0      		ldi r25,hi8(7)
 4080 11fc 0E94 0000 		call __eewr_byte_m168
 754:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_ALARM_MIN, alarm_m);    
 4082               	.LM468:
 4083 1200 6091 0000 		lds r22,alarm_m
 4084 1204 88E0      		ldi r24,lo8(8)
 4085 1206 90E0      		ldi r25,hi8(8)
 4086 1208 0E94 0000 		call __eewr_byte_m168
 755:iv.c          **** 	displaymode = SHOW_TIME;
 4088               	.LM469:
 4089 120c 1092 0000 		sts displaymode,__zero_reg__
 4090 1210 00C0      		rjmp .L239
 4091               	.L231:
 759:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
 4093               	.LM470:
 4094 1212 8091 0000 		lds r24,just_pressed
 4095 1216 82FD      		sbrc r24,2
 4096 1218 00C0      		rjmp .L234
 4097 121a 8091 0000 		lds r24,pressed
 4098 121e 82FF      		sbrs r24,2
 4099 1220 00C0      		rjmp .L243
 4100               	.L234:
 760:iv.c          ****       just_pressed = 0;
 4102               	.LM471:
 4103 1222 1092 0000 		sts just_pressed,__zero_reg__
 762:iv.c          ****       if (mode == SET_HOUR) {
 4105               	.LM472:
 4106 1226 81E0      		ldi r24,lo8(1)
 4107 1228 F816      		cp r15,r24
 4108 122a 01F4      		brne .L236
 763:iv.c          **** 	hour = (hour+1) % 24;
 4110               	.LM473:
 4111 122c 812F      		mov r24,r17
 4112 122e 90E0      		ldi r25,lo8(0)
 4113 1230 0196      		adiw r24,1
 4114 1232 68E1      		ldi r22,lo8(24)
 4115 1234 70E0      		ldi r23,hi8(24)
 4116 1236 0E94 0000 		call __divmodhi4
 4117 123a 182F      		mov r17,r24
 764:iv.c          **** 	display_alarm(hour, min);
 4119               	.LM474:
 4120 123c 602F      		mov r22,r16
 4121 123e 0E94 0000 		call display_alarm
 765:iv.c          **** 	display[1] |= 0x1;
 4123               	.LM475:
 4124 1242 8091 0000 		lds r24,display+1
 4125 1246 8160      		ori r24,lo8(1)
 4126 1248 8093 0000 		sts display+1,r24
 766:iv.c          **** 	display[2] |= 0x1;
 4128               	.LM476:
 4129 124c 8091 0000 		lds r24,display+2
 4130 1250 8160      		ori r24,lo8(1)
 4131 1252 8093 0000 		sts display+2,r24
 4132 1256 00C0      		rjmp .L237
 4133               	.L236:
 768:iv.c          ****       if (mode == SET_MIN) {
 4135               	.LM477:
 4136 1258 82E0      		ldi r24,lo8(2)
 4137 125a F816      		cp r15,r24
 4138 125c 01F4      		brne .L237
 769:iv.c          **** 	min = (min+1) % 60;
 4140               	.LM478:
 4141 125e 802F      		mov r24,r16
 4142 1260 90E0      		ldi r25,lo8(0)
 4143 1262 0196      		adiw r24,1
 4144 1264 6CE3      		ldi r22,lo8(60)
 4145 1266 70E0      		ldi r23,hi8(60)
 4146 1268 0E94 0000 		call __divmodhi4
 4147 126c 082F      		mov r16,r24
 770:iv.c          **** 	display_alarm(hour, min);
 4149               	.LM479:
 4150 126e 812F      		mov r24,r17
 4151 1270 602F      		mov r22,r16
 4152 1272 0E94 0000 		call display_alarm
 771:iv.c          **** 	display[4] |= 0x1;
 4154               	.LM480:
 4155 1276 8091 0000 		lds r24,display+4
 4156 127a 8160      		ori r24,lo8(1)
 4157 127c 8093 0000 		sts display+4,r24
 772:iv.c          **** 	display[5] |= 0x1;
 4159               	.LM481:
 4160 1280 8091 0000 		lds r24,display+5
 4161 1284 8160      		ori r24,lo8(1)
 4162 1286 8093 0000 		sts display+5,r24
 4163               	.L237:
 775:iv.c          ****       if (pressed & 0x4)
 4165               	.LM482:
 4166 128a 8091 0000 		lds r24,pressed
 4167 128e 82FF      		sbrs r24,2
 4168 1290 00C0      		rjmp .L243
 4169               	.LBB203:
 4170               	.LBB204:
 116:iv.c          ****   sei();
 4172               	.LM483:
 4173               	/* #APP */
 4174               	 ;  116 "iv.c" 1
 4175 1292 7894      		sei
 4176               	 ;  0 "" 2
 118:iv.c          ****   milliseconds = 0;
 4178               	.LM484:
 4179               	/* #NOAPP */
 4180 1294 1092 0000 		sts (milliseconds)+1,__zero_reg__
 4181 1298 1092 0000 		sts milliseconds,__zero_reg__
 4182               	.L238:
 119:iv.c          ****   while (milliseconds < ms);
 4184               	.LM485:
 4185 129c 8091 0000 		lds r24,milliseconds
 4186 12a0 9091 0000 		lds r25,(milliseconds)+1
 4187 12a4 8B34      		cpi r24,75
 4188 12a6 9105      		cpc r25,__zero_reg__
 4189 12a8 00F0      		brlo .L238
 4190 12aa 00C0      		rjmp .L243
 4191               	.L239:
 4192               	/* epilogue start */
 4193               	.LBE204:
 4194               	.LBE203:
 779:iv.c          **** }
 4196               	.LM486:
 4197 12ac 1F91      		pop r17
 4198 12ae 0F91      		pop r16
 4199 12b0 FF90      		pop r15
 4200 12b2 EF90      		pop r14
 4201 12b4 0895      		ret
 4208               	.Lscope30:
 4210               		.stabd	78,0,0
 4215               	.global	check_alarm
 4217               	check_alarm:
 4218               		.stabd	46,0,0
1970:iv.c          **** void check_alarm(uint8_t h, uint8_t m, uint8_t s) {
 4220               	.LM487:
 4221               	.LFBB31:
 4222               	/* prologue: function */
 4223               	/* frame size = 0 */
 4224 12b6 982F      		mov r25,r24
1972:iv.c          ****   if (alarm_on && (alarm_h == h) && (alarm_m == m) && (0 == s)) {
 4226               	.LM488:
 4227 12b8 8091 0000 		lds r24,alarm_on
 4228 12bc 8823      		tst r24
 4229 12be 01F0      		breq .L246
 4230 12c0 8091 0000 		lds r24,alarm_h
 4231 12c4 8917      		cp r24,r25
 4232 12c6 01F4      		brne .L246
 4233 12c8 8091 0000 		lds r24,alarm_m
 4234 12cc 8617      		cp r24,r22
 4235 12ce 01F4      		brne .L246
 4236 12d0 4423      		tst r20
 4237 12d2 01F4      		brne .L246
1973:iv.c          ****     DEBUGP("alarm on!");
 4239               	.LM489:
 4240 12d4 80E0      		ldi r24,lo8(__c.3243)
 4241 12d6 90E0      		ldi r25,hi8(__c.3243)
 4242 12d8 61E0      		ldi r22,lo8(1)
 4243 12da 0E94 0000 		call ROM_putstring
1974:iv.c          ****     alarming = 1;
 4245               	.LM490:
 4246 12de 81E0      		ldi r24,lo8(1)
 4247 12e0 8093 0000 		sts alarming,r24
1975:iv.c          ****     snoozetimer = 0;
 4249               	.LM491:
 4250 12e4 1092 0000 		sts (snoozetimer)+1,__zero_reg__
 4251 12e8 1092 0000 		sts snoozetimer,__zero_reg__
 4252               	.L246:
 4253 12ec 0895      		ret
 4255               	.Lscope31:
 4257               		.stabd	78,0,0
 4258               		.data
 4259               	.LC20:
 4260 007e 2020 2020 		.string	"        "
 4260      2020 2020 
 4260      00
 4261               		.text
 4263               	.global	__vector_9
 4265               	__vector_9:
 4266               		.stabd	46,0,0
 308:iv.c          **** SIGNAL (TIMER2_OVF_vect) {
 4268               	.LM492:
 4269               	.LFBB32:
 4270 12ee 1F92      		push __zero_reg__
 4271 12f0 0F92      		push r0
 4272 12f2 0FB6      		in r0,__SREG__
 4273 12f4 0F92      		push r0
 4274 12f6 1124      		clr __zero_reg__
 4275 12f8 2F93      		push r18
 4276 12fa 3F93      		push r19
 4277 12fc 4F93      		push r20
 4278 12fe 5F93      		push r21
 4279 1300 6F93      		push r22
 4280 1302 7F93      		push r23
 4281 1304 8F93      		push r24
 4282 1306 9F93      		push r25
 4283 1308 AF93      		push r26
 4284 130a BF93      		push r27
 4285 130c EF93      		push r30
 4286 130e FF93      		push r31
 4287               	/* prologue: Signal */
 4288               	/* frame size = 0 */
 309:iv.c          ****   CLKPR = _BV(CLKPCE);  //MEME
 4290               	.LM493:
 4291 1310 80E8      		ldi r24,lo8(-128)
 4292 1312 8093 6100 		sts 97,r24
 310:iv.c          ****   CLKPR = 0;
 4294               	.LM494:
 4295 1316 1092 6100 		sts 97,__zero_reg__
 312:iv.c          ****   time_s++;             // one second has gone by
 4297               	.LM495:
 4298 131a 8091 0000 		lds r24,time_s
 4299 131e 8F5F      		subi r24,lo8(-(1))
 4300 1320 8093 0000 		sts time_s,r24
 314:iv.c          ****   fix_time();
 4302               	.LM496:
 4303 1324 0E94 0000 		call fix_time
 317:iv.c          ****   if (sleepmode)
 4305               	.LM497:
 4306 1328 8091 0000 		lds r24,sleepmode
 4307 132c 8823      		tst r24
 4308 132e 01F0      		breq .+2
 4309 1330 00C0      		rjmp .L257
 321:iv.c          ****   if (displaymode == SHOW_TIME) {
 4311               	.LM498:
 4312 1332 8091 0000 		lds r24,displaymode
 4313 1336 8823      		tst r24
 4314 1338 01F4      		brne .L249
 322:iv.c          ****     if (timeunknown && (time_s % 2)) {
 4316               	.LM499:
 4317 133a 8091 0000 		lds r24,timeunknown
 4318 133e 8823      		tst r24
 4319 1340 01F0      		breq .L250
 4320 1342 8091 0000 		lds r24,time_s
 4321 1346 80FF      		sbrs r24,0
 4322 1348 00C0      		rjmp .L250
 323:iv.c          ****       display_str("        ");
 4324               	.LM500:
 4325 134a 80E0      		ldi r24,lo8(.LC20)
 4326 134c 90E0      		ldi r25,hi8(.LC20)
 4327 134e 0E94 0000 		call display_str
 4328 1352 00C0      		rjmp .L251
 4329               	.L250:
 325:iv.c          ****       display_time(time_h, time_m, time_s);
 4331               	.LM501:
 4332 1354 8091 0000 		lds r24,time_h
 4333 1358 6091 0000 		lds r22,time_m
 4334 135c 4091 0000 		lds r20,time_s
 4335 1360 0E94 0000 		call display_time
 4336               	.L251:
 327:iv.c          ****     if (alarm_on)
 4338               	.LM502:
 4339 1364 8091 0000 		lds r24,alarm_on
 4340 1368 8823      		tst r24
 4341 136a 01F0      		breq .L252
 328:iv.c          ****       display[0] |= 0x2;
 4343               	.LM503:
 4344 136c 8091 0000 		lds r24,display
 4345 1370 8260      		ori r24,lo8(2)
 4346 1372 00C0      		rjmp .L258
 4347               	.L252:
 330:iv.c          ****       display[0] &= ~0x2;
 4349               	.LM504:
 4350 1374 8091 0000 		lds r24,display
 4351 1378 8D7F      		andi r24,lo8(-3)
 4352               	.L258:
 4353 137a 8093 0000 		sts display,r24
 4354               	.L249:
 4355               	.LBB205:
 4356               	.LBB206:
1441:iv.c          ****   if (brightness_level == 0) 
 4358               	.LM505:
 4359 137e 8091 0000 		lds r24,brightness_level
 4360 1382 8823      		tst r24
 4361 1384 01F4      		brne .L253
1442:iv.c          ****     ADCSRA |= _BV(ADSC);
 4363               	.LM506:
 4364 1386 8091 7A00 		lds r24,122
 4365 138a 8064      		ori r24,lo8(64)
 4366 138c 8093 7A00 		sts 122,r24
 4367               	.L253:
 4368               	.LBE206:
 4369               	.LBE205:
 337:iv.c          ****   check_alarm(time_h, time_m, time_s);
 4371               	.LM507:
 4372 1390 8091 0000 		lds r24,time_h
 4373 1394 6091 0000 		lds r22,time_m
 4374 1398 4091 0000 		lds r20,time_s
 4375 139c 0E94 0000 		call check_alarm
 339:iv.c          ****   if (timeoutcounter)
 4377               	.LM508:
 4378 13a0 8091 0000 		lds r24,timeoutcounter
 4379 13a4 8823      		tst r24
 4380 13a6 01F0      		breq .L254
 340:iv.c          ****     timeoutcounter--;
 4382               	.LM509:
 4383 13a8 8091 0000 		lds r24,timeoutcounter
 4384 13ac 8150      		subi r24,lo8(-(-1))
 4385 13ae 8093 0000 		sts timeoutcounter,r24
 4386               	.L254:
 341:iv.c          ****   if (buttonholdcounter)
 4388               	.LM510:
 4389 13b2 8091 0000 		lds r24,buttonholdcounter
 4390 13b6 8823      		tst r24
 4391 13b8 01F0      		breq .L255
 342:iv.c          ****     buttonholdcounter--;
 4393               	.LM511:
 4394 13ba 8091 0000 		lds r24,buttonholdcounter
 4395 13be 8150      		subi r24,lo8(-(-1))
 4396 13c0 8093 0000 		sts buttonholdcounter,r24
 4397               	.L255:
 343:iv.c          ****   if (snoozetimer) {
 4399               	.LM512:
 4400 13c4 8091 0000 		lds r24,snoozetimer
 4401 13c8 9091 0000 		lds r25,(snoozetimer)+1
 4402 13cc 0097      		sbiw r24,0
 4403 13ce 01F0      		breq .L257
 344:iv.c          ****     snoozetimer--;
 4405               	.LM513:
 4406 13d0 0197      		sbiw r24,1
 4407 13d2 9093 0000 		sts (snoozetimer)+1,r25
 4408 13d6 8093 0000 		sts snoozetimer,r24
 345:iv.c          ****     if (snoozetimer % 2) 
 4410               	.LM514:
 4411 13da 80FF      		sbrs r24,0
 4412 13dc 00C0      		rjmp .L256
 346:iv.c          ****       display[0] |= 0x2;
 4414               	.LM515:
 4415 13de 8091 0000 		lds r24,display
 4416 13e2 8260      		ori r24,lo8(2)
 4417 13e4 00C0      		rjmp .L259
 4418               	.L256:
 348:iv.c          ****       display[0] &= ~0x2;
 4420               	.LM516:
 4421 13e6 8091 0000 		lds r24,display
 4422 13ea 8D7F      		andi r24,lo8(-3)
 4423               	.L259:
 4424 13ec 8093 0000 		sts display,r24
 4425               	.L257:
 4426               	/* epilogue start */
 350:iv.c          **** }
 4428               	.LM517:
 4429 13f0 FF91      		pop r31
 4430 13f2 EF91      		pop r30
 4431 13f4 BF91      		pop r27
 4432 13f6 AF91      		pop r26
 4433 13f8 9F91      		pop r25
 4434 13fa 8F91      		pop r24
 4435 13fc 7F91      		pop r23
 4436 13fe 6F91      		pop r22
 4437 1400 5F91      		pop r21
 4438 1402 4F91      		pop r20
 4439 1404 3F91      		pop r19
 4440 1406 2F91      		pop r18
 4441 1408 0F90      		pop r0
 4442 140a 0FBE      		out __SREG__,r0
 4443 140c 0F90      		pop r0
 4444 140e 1F90      		pop __zero_reg__
 4445 1410 1895      		reti
 4447               	.Lscope32:
 4449               		.stabd	78,0,0
 4450               		.data
 4451               	.LC21:
 4452 0087 616C 6172 		.string	"alarm on"
 4452      6D20 6F6E 
 4452      00
 4453               		.text
 4455               	.global	setalarmstate
 4457               	setalarmstate:
 4458               		.stabd	46,0,0
1318:iv.c          **** void setalarmstate(void) {
 4460               	.LM518:
 4461               	.LFBB33:
 4462               	/* prologue: function */
 4463               	/* frame size = 0 */
1319:iv.c          ****   if (ALARM_PIN & _BV(ALARM)) { 
 4465               	.LM519:
 4466 1412 4A9B      		sbis 41-32,2
 4467 1414 00C0      		rjmp .L261
1321:iv.c          ****     if  (!alarm_on) {
 4469               	.LM520:
 4470 1416 8091 0000 		lds r24,alarm_on
 4471 141a 8823      		tst r24
 4472 141c 01F0      		breq .+2
 4473 141e 00C0      		rjmp .L265
1323:iv.c          ****       alarm_on = 1;
 4475               	.LM521:
 4476 1420 81E0      		ldi r24,lo8(1)
 4477 1422 8093 0000 		sts alarm_on,r24
1325:iv.c          ****       snoozetimer = 0;
 4479               	.LM522:
 4480 1426 1092 0000 		sts (snoozetimer)+1,__zero_reg__
 4481 142a 1092 0000 		sts snoozetimer,__zero_reg__
1327:iv.c          ****       display_str("alarm on");
 4483               	.LM523:
 4484 142e 80E0      		ldi r24,lo8(.LC21)
 4485 1430 90E0      		ldi r25,hi8(.LC21)
 4486 1432 0E94 0000 		call display_str
1329:iv.c          ****       displaymode = SHOW_SNOOZE;
 4488               	.LM524:
 4489 1436 89E0      		ldi r24,lo8(9)
 4490 1438 8093 0000 		sts displaymode,r24
 4491               	.LBB207:
 4492               	.LBB208:
 116:iv.c          ****   sei();
 4494               	.LM525:
 4495               	/* #APP */
 4496               	 ;  116 "iv.c" 1
 4497 143c 7894      		sei
 4498               	 ;  0 "" 2
 118:iv.c          ****   milliseconds = 0;
 4500               	.LM526:
 4501               	/* #NOAPP */
 4502 143e 1092 0000 		sts (milliseconds)+1,__zero_reg__
 4503 1442 1092 0000 		sts milliseconds,__zero_reg__
 4504               	.L263:
 119:iv.c          ****   while (milliseconds < ms);
 4506               	.LM527:
 4507 1446 8091 0000 		lds r24,milliseconds
 4508 144a 9091 0000 		lds r25,(milliseconds)+1
 4509 144e 885E      		subi r24,lo8(1000)
 4510 1450 9340      		sbci r25,hi8(1000)
 4511 1452 00F0      		brlo .L263
 4512               	.LBE208:
 4513               	.LBE207:
1332:iv.c          ****       display_alarm(alarm_h, alarm_m);
 4515               	.LM528:
 4516 1454 8091 0000 		lds r24,alarm_h
 4517 1458 6091 0000 		lds r22,alarm_m
 4518 145c 0E94 0000 		call display_alarm
 4519               	.LBB209:
 4520               	.LBB210:
 116:iv.c          ****   sei();
 4522               	.LM529:
 4523               	/* #APP */
 4524               	 ;  116 "iv.c" 1
 4525 1460 7894      		sei
 4526               	 ;  0 "" 2
 118:iv.c          ****   milliseconds = 0;
 4528               	.LM530:
 4529               	/* #NOAPP */
 4530 1462 1092 0000 		sts (milliseconds)+1,__zero_reg__
 4531 1466 1092 0000 		sts milliseconds,__zero_reg__
 4532               	.L264:
 119:iv.c          ****   while (milliseconds < ms);
 4534               	.LM531:
 4535 146a 8091 0000 		lds r24,milliseconds
 4536 146e 9091 0000 		lds r25,(milliseconds)+1
 4537 1472 885E      		subi r24,lo8(1000)
 4538 1474 9340      		sbci r25,hi8(1000)
 4539 1476 00F0      		brlo .L264
 4540               	.LBE210:
 4541               	.LBE209:
1335:iv.c          ****       displaymode = SHOW_TIME;
 4543               	.LM532:
 4544 1478 1092 0000 		sts displaymode,__zero_reg__
 4545 147c 0895      		ret
 4546               	.L261:
1338:iv.c          ****     if (alarm_on) {
 4548               	.LM533:
 4549 147e 8091 0000 		lds r24,alarm_on
 4550 1482 8823      		tst r24
 4551 1484 01F0      		breq .L265
1340:iv.c          ****       alarm_on = 0;
 4553               	.LM534:
 4554 1486 1092 0000 		sts alarm_on,__zero_reg__
1341:iv.c          ****       snoozetimer = 0;
 4556               	.LM535:
 4557 148a 1092 0000 		sts (snoozetimer)+1,__zero_reg__
 4558 148e 1092 0000 		sts snoozetimer,__zero_reg__
1342:iv.c          ****       if (alarming) {
 4560               	.LM536:
 4561 1492 8091 0000 		lds r24,alarming
 4562 1496 8823      		tst r24
 4563 1498 01F0      		breq .L265
1345:iv.c          **** 	DEBUGP("alarm off");
 4565               	.LM537:
 4566 149a 80E0      		ldi r24,lo8(__c.2550)
 4567 149c 90E0      		ldi r25,hi8(__c.2550)
 4568 149e 61E0      		ldi r22,lo8(1)
 4569 14a0 0E94 0000 		call ROM_putstring
1346:iv.c          **** 	alarming = 0;
 4571               	.LM538:
 4572 14a4 1092 0000 		sts alarming,__zero_reg__
1347:iv.c          **** 	TCCR1B &= ~_BV(CS11); // turn it off!
 4574               	.LM539:
 4575 14a8 8091 8100 		lds r24,129
 4576 14ac 8D7F      		andi r24,lo8(-3)
 4577 14ae 8093 8100 		sts 129,r24
1348:iv.c          **** 	PORTB |= _BV(SPK1) | _BV(SPK2);
 4579               	.LM540:
 4580 14b2 85B1      		in r24,37-32
 4581 14b4 8660      		ori r24,lo8(6)
 4582 14b6 85B9      		out 37-32,r24
 4583               	.L265:
 4584 14b8 0895      		ret
 4586               	.Lscope33:
 4588               		.stabd	78,0,0
 4590               	.global	set_date
 4592               	set_date:
 4593               		.stabd	46,0,0
 871:iv.c          **** void set_date(void) {
 4595               	.LM541:
 4596               	.LFBB34:
 4597 14ba FF92      		push r15
 4598 14bc 0F93      		push r16
 4599 14be 1F93      		push r17
 4600               	/* prologue: function */
 4601               	/* frame size = 0 */
 874:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;;  
 4603               	.LM542:
 4604 14c0 8AE0      		ldi r24,lo8(10)
 4605 14c2 8093 0000 		sts timeoutcounter,r24
 4606 14c6 10E0      		ldi r17,lo8(0)
 878:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
 4608               	.LM543:
 4609 14c8 0AE0      		ldi r16,lo8(10)
 905:iv.c          **** 	if (region == REGION_US)
 4611               	.LM544:
 4612 14ca FF24      		clr r15
 4613 14cc F394      		inc r15
 4614               	.L303:
 877:iv.c          ****     if (just_pressed || pressed) {
 4616               	.LM545:
 4617 14ce 8091 0000 		lds r24,just_pressed
 4618 14d2 8823      		tst r24
 4619 14d4 01F4      		brne .L269
 4620 14d6 8091 0000 		lds r24,pressed
 4621 14da 8823      		tst r24
 4622 14dc 01F0      		breq .L270
 4623               	.L269:
 878:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
 4625               	.LM546:
 4626 14de 0093 0000 		sts timeoutcounter,r16
 4627 14e2 00C0      		rjmp .L271
 4628               	.L270:
 880:iv.c          ****     } else if (!timeoutcounter) {
 4630               	.LM547:
 4631 14e4 8091 0000 		lds r24,timeoutcounter
 4632 14e8 8823      		tst r24
 4633 14ea 01F4      		brne .+2
 4634 14ec 00C0      		rjmp .L306
 4635               	.L271:
 885:iv.c          ****     if (just_pressed & 0x1) { // mode change
 4637               	.LM548:
 4638 14ee 8091 0000 		lds r24,just_pressed
 4639 14f2 80FD      		sbrc r24,0
 4640 14f4 00C0      		rjmp .L298
 888:iv.c          ****     if (just_pressed & 0x2) {
 4642               	.LM549:
 4643 14f6 8091 0000 		lds r24,just_pressed
 4644 14fa 81FF      		sbrs r24,1
 4645 14fc 00C0      		rjmp .L273
 890:iv.c          ****       just_pressed = 0;
 4647               	.LM550:
 4648 14fe 1092 0000 		sts just_pressed,__zero_reg__
 891:iv.c          ****       if (mode == SHOW_MENU) {
 4650               	.LM551:
 4651 1502 1123      		tst r17
 4652 1504 01F4      		brne .L274
 893:iv.c          **** 	if (region == REGION_US) {
 4654               	.LM552:
 4655 1506 8091 0000 		lds r24,region
 4656 150a 8823      		tst r24
 4657 150c 01F4      		brne .L275
 4658 150e 11E0      		ldi r17,lo8(1)
 4659 1510 00C0      		rjmp .L276
 4660               	.L275:
 897:iv.c          **** 	  DEBUGP("Set day");
 4662               	.LM553:
 4663 1512 80E0      		ldi r24,lo8(__c.2287)
 4664 1514 90E0      		ldi r25,hi8(__c.2287)
 4665 1516 61E0      		ldi r22,lo8(1)
 4666 1518 0E94 0000 		call ROM_putstring
 4667 151c 12E0      		ldi r17,lo8(2)
 4668               	.L276:
 900:iv.c          **** 	display_date(DATE);
 4670               	.LM554:
 4671 151e 80E0      		ldi r24,lo8(0)
 4672 1520 0E94 0000 		call display_date
 901:iv.c          **** 	display[1] |= 0x1;
 4674               	.LM555:
 4675 1524 8091 0000 		lds r24,display+1
 4676 1528 8160      		ori r24,lo8(1)
 4677 152a 8093 0000 		sts display+1,r24
 902:iv.c          **** 	display[2] |= 0x1;
 4679               	.LM556:
 4680 152e 8091 0000 		lds r24,display+2
 4681 1532 8160      		ori r24,lo8(1)
 4682 1534 8093 0000 		sts display+2,r24
 4683 1538 00C0      		rjmp .L273
 4684               	.L274:
 903:iv.c          ****       } else if (((mode == SET_MONTH) && (region == REGION_US)) ||
 4686               	.LM557:
 4687 153a 1130      		cpi r17,lo8(1)
 4688 153c 01F4      		brne .L277
 4689 153e 8091 0000 		lds r24,region
 4690 1542 8823      		tst r24
 4691 1544 01F0      		breq .L278
 4692 1546 00C0      		rjmp .L304
 4693               	.L277:
 4694 1548 1230      		cpi r17,lo8(2)
 4695 154a 01F4      		brne .L279
 4696 154c 8091 0000 		lds r24,region
 4697 1550 8130      		cpi r24,lo8(1)
 4698 1552 01F4      		brne .L280
 4699               	.L278:
 905:iv.c          **** 	if (region == REGION_US)
 4701               	.LM558:
 4702 1554 8091 0000 		lds r24,region
 4703 1558 8823      		tst r24
 4704 155a 01F0      		breq .L281
 4705 155c 11E0      		ldi r17,lo8(1)
 4706 155e 00C0      		rjmp .L282
 4707               	.L281:
 4708 1560 12E0      		ldi r17,lo8(2)
 4709               	.L282:
 909:iv.c          **** 	display_date(DATE);
 4711               	.LM559:
 4712 1562 80E0      		ldi r24,lo8(0)
 4713 1564 0E94 0000 		call display_date
 910:iv.c          **** 	display[4] |= 0x1;
 4715               	.LM560:
 4716 1568 8091 0000 		lds r24,display+4
 4717 156c 8160      		ori r24,lo8(1)
 4718 156e 8093 0000 		sts display+4,r24
 911:iv.c          **** 	display[5] |= 0x1;
 4720               	.LM561:
 4721 1572 8091 0000 		lds r24,display+5
 4722 1576 8160      		ori r24,lo8(1)
 4723 1578 8093 0000 		sts display+5,r24
 4724 157c 00C0      		rjmp .L273
 4725               	.L280:
 912:iv.c          ****       } else if (((mode == SET_DAY) && (region == REGION_US)) ||
 4727               	.LM562:
 4728 157e 8823      		tst r24
 4729 1580 01F0      		breq .L283
 4730 1582 00C0      		rjmp .L284
 4731               	.L279:
 4732 1584 1130      		cpi r17,lo8(1)
 4733 1586 01F4      		brne .L284
 4734               	.L304:
 4735 1588 8091 0000 		lds r24,region
 4736 158c 8130      		cpi r24,lo8(1)
 4737 158e 01F4      		brne .L284
 4738               	.L283:
 915:iv.c          **** 	display_date(DATE);
 4740               	.LM563:
 4741 1590 80E0      		ldi r24,lo8(0)
 4742 1592 0E94 0000 		call display_date
 916:iv.c          **** 	display[7] |= 0x1;
 4744               	.LM564:
 4745 1596 8091 0000 		lds r24,display+7
 4746 159a 8160      		ori r24,lo8(1)
 4747 159c 8093 0000 		sts display+7,r24
 917:iv.c          **** 	display[8] |= 0x1;
 4749               	.LM565:
 4750 15a0 8091 0000 		lds r24,display+8
 4751 15a4 8160      		ori r24,lo8(1)
 4752 15a6 8093 0000 		sts display+8,r24
 4753 15aa 13E0      		ldi r17,lo8(3)
 4754 15ac 00C0      		rjmp .L273
 4755               	.L284:
 919:iv.c          **** 	displaymode = NONE;
 4757               	.LM566:
 4758 15ae 83E6      		ldi r24,lo8(99)
 4759 15b0 8093 0000 		sts displaymode,r24
 920:iv.c          **** 	display_date(DATE);
 4761               	.LM567:
 4762 15b4 80E0      		ldi r24,lo8(0)
 4763 15b6 0E94 0000 		call display_date
 4764               	.LBB211:
 4765               	.LBB212:
 116:iv.c          ****   sei();
 4767               	.LM568:
 4768               	/* #APP */
 4769               	 ;  116 "iv.c" 1
 4770 15ba 7894      		sei
 4771               	 ;  0 "" 2
 118:iv.c          ****   milliseconds = 0;
 4773               	.LM569:
 4774               	/* #NOAPP */
 4775 15bc 1092 0000 		sts (milliseconds)+1,__zero_reg__
 4776 15c0 1092 0000 		sts milliseconds,__zero_reg__
 4777               	.L285:
 119:iv.c          ****   while (milliseconds < ms);
 4779               	.LM570:
 4780 15c4 8091 0000 		lds r24,milliseconds
 4781 15c8 9091 0000 		lds r25,(milliseconds)+1
 4782 15cc 8C5D      		subi r24,lo8(1500)
 4783 15ce 9540      		sbci r25,hi8(1500)
 4784 15d0 00F0      		brlo .L285
 4785               	.L306:
 4786               	.LBE212:
 4787               	.LBE211:
 922:iv.c          **** 	displaymode = SHOW_TIME;
 4789               	.LM571:
 4790 15d2 1092 0000 		sts displaymode,__zero_reg__
 4791 15d6 00C0      		rjmp .L298
 4792               	.L273:
 926:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
 4794               	.LM572:
 4795 15d8 8091 0000 		lds r24,just_pressed
 4796 15dc 82FD      		sbrc r24,2
 4797 15de 00C0      		rjmp .L286
 4798 15e0 8091 0000 		lds r24,pressed
 4799 15e4 82FF      		sbrs r24,2
 4800 15e6 00C0      		rjmp .L303
 4801               	.L286:
 927:iv.c          ****       just_pressed = 0;
 4803               	.LM573:
 4804 15e8 1092 0000 		sts just_pressed,__zero_reg__
 928:iv.c          ****       if (mode == SET_MONTH) {
 4806               	.LM574:
 4807 15ec 1130      		cpi r17,lo8(1)
 4808 15ee 01F4      		brne .L288
 929:iv.c          **** 	date_m++;
 4810               	.LM575:
 4811 15f0 8091 0000 		lds r24,date_m
 4812 15f4 8F5F      		subi r24,lo8(-(1))
 4813 15f6 8093 0000 		sts date_m,r24
 930:iv.c          **** 	if (date_m >= 13)
 4815               	.LM576:
 4816 15fa 8091 0000 		lds r24,date_m
 4817 15fe 8D30      		cpi r24,lo8(13)
 4818 1600 04F0      		brlt .L289
 931:iv.c          **** 	  date_m = 1;
 4820               	.LM577:
 4821 1602 1093 0000 		sts date_m,r17
 4822               	.L289:
 932:iv.c          **** 	display_date(DATE);
 4824               	.LM578:
 4825 1606 80E0      		ldi r24,lo8(0)
 4826 1608 0E94 0000 		call display_date
 933:iv.c          **** 	if (region == REGION_US) {
 4828               	.LM579:
 4829 160c 8091 0000 		lds r24,region
 4830 1610 8823      		tst r24
 4831 1612 01F4      		brne .L290
 934:iv.c          **** 	  display[1] |= 0x1;
 4833               	.LM580:
 4834 1614 8091 0000 		lds r24,display+1
 4835 1618 8160      		ori r24,lo8(1)
 4836 161a 8093 0000 		sts display+1,r24
 935:iv.c          **** 	  display[2] |= 0x1;
 4838               	.LM581:
 4839 161e 8091 0000 		lds r24,display+2
 4840 1622 8160      		ori r24,lo8(1)
 4841 1624 8093 0000 		sts display+2,r24
 4842 1628 00C0      		rjmp .L291
 4843               	.L290:
 937:iv.c          **** 	  display[4] |= 0x1;
 4845               	.LM582:
 4846 162a 8091 0000 		lds r24,display+4
 4847 162e 8160      		ori r24,lo8(1)
 4848 1630 8093 0000 		sts display+4,r24
 938:iv.c          **** 	  display[5] |= 0x1;
 4850               	.LM583:
 4851 1634 8091 0000 		lds r24,display+5
 4852 1638 8160      		ori r24,lo8(1)
 4853 163a 8093 0000 		sts display+5,r24
 4854               	.L291:
 940:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_MONTH, date_m);    
 4856               	.LM584:
 4857 163e 6091 0000 		lds r22,date_m
 4858 1642 82E0      		ldi r24,lo8(2)
 4859 1644 90E0      		ldi r25,hi8(2)
 4860 1646 00C0      		rjmp .L305
 4861               	.L288:
 942:iv.c          ****       if (mode == SET_DAY) {
 4863               	.LM585:
 4864 1648 1230      		cpi r17,lo8(2)
 4865 164a 01F4      		brne .L292
 943:iv.c          **** 	date_d++;
 4867               	.LM586:
 4868 164c 8091 0000 		lds r24,date_d
 4869 1650 8F5F      		subi r24,lo8(-(1))
 4870 1652 8093 0000 		sts date_d,r24
 944:iv.c          **** 	if (date_d > 31)
 4872               	.LM587:
 4873 1656 8091 0000 		lds r24,date_d
 4874 165a 8032      		cpi r24,lo8(32)
 4875 165c 04F0      		brlt .L293
 945:iv.c          **** 	  date_d = 1;
 4877               	.LM588:
 4878 165e F092 0000 		sts date_d,r15
 4879               	.L293:
 946:iv.c          **** 	display_date(DATE);
 4881               	.LM589:
 4882 1662 80E0      		ldi r24,lo8(0)
 4883 1664 0E94 0000 		call display_date
 948:iv.c          **** 	if (region == REGION_EU) {
 4885               	.LM590:
 4886 1668 8091 0000 		lds r24,region
 4887 166c 8130      		cpi r24,lo8(1)
 4888 166e 01F4      		brne .L294
 949:iv.c          **** 	  display[1] |= 0x1;
 4890               	.LM591:
 4891 1670 8091 0000 		lds r24,display+1
 4892 1674 8160      		ori r24,lo8(1)
 4893 1676 8093 0000 		sts display+1,r24
 950:iv.c          **** 	  display[2] |= 0x1;
 4895               	.LM592:
 4896 167a 8091 0000 		lds r24,display+2
 4897 167e 8160      		ori r24,lo8(1)
 4898 1680 8093 0000 		sts display+2,r24
 4899 1684 00C0      		rjmp .L295
 4900               	.L294:
 952:iv.c          **** 	  display[4] |= 0x1;
 4902               	.LM593:
 4903 1686 8091 0000 		lds r24,display+4
 4904 168a 8160      		ori r24,lo8(1)
 4905 168c 8093 0000 		sts display+4,r24
 953:iv.c          **** 	  display[5] |= 0x1;
 4907               	.LM594:
 4908 1690 8091 0000 		lds r24,display+5
 4909 1694 8160      		ori r24,lo8(1)
 4910 1696 8093 0000 		sts display+5,r24
 4911               	.L295:
 955:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_DAY, date_d);    
 4913               	.LM595:
 4914 169a 6091 0000 		lds r22,date_d
 4915 169e 83E0      		ldi r24,lo8(3)
 4916 16a0 90E0      		ldi r25,hi8(3)
 4917 16a2 00C0      		rjmp .L305
 4918               	.L292:
 957:iv.c          ****       if (mode == SET_YEAR) {
 4920               	.LM596:
 4921 16a4 1330      		cpi r17,lo8(3)
 4922 16a6 01F4      		brne .L296
 958:iv.c          **** 	date_y++;
 4924               	.LM597:
 4925 16a8 8091 0000 		lds r24,date_y
 4926 16ac 8F5F      		subi r24,lo8(-(1))
 4927 16ae 8093 0000 		sts date_y,r24
 959:iv.c          **** 	date_y %= 100;
 4929               	.LM598:
 4930 16b2 8091 0000 		lds r24,date_y
 4931 16b6 64E6      		ldi r22,lo8(100)
 4932 16b8 0E94 0000 		call __divmodqi4
 4933 16bc 9093 0000 		sts date_y,r25
 960:iv.c          **** 	display_date(DATE);
 4935               	.LM599:
 4936 16c0 80E0      		ldi r24,lo8(0)
 4937 16c2 0E94 0000 		call display_date
 961:iv.c          **** 	display[7] |= 0x1;
 4939               	.LM600:
 4940 16c6 8091 0000 		lds r24,display+7
 4941 16ca 8160      		ori r24,lo8(1)
 4942 16cc 8093 0000 		sts display+7,r24
 962:iv.c          **** 	display[8] |= 0x1;
 4944               	.LM601:
 4945 16d0 8091 0000 		lds r24,display+8
 4946 16d4 8160      		ori r24,lo8(1)
 4947 16d6 8093 0000 		sts display+8,r24
 963:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_YEAR, date_y);    
 4949               	.LM602:
 4950 16da 6091 0000 		lds r22,date_y
 4951 16de 81E0      		ldi r24,lo8(1)
 4952 16e0 90E0      		ldi r25,hi8(1)
 4953               	.L305:
 4954 16e2 0E94 0000 		call __eewr_byte_m168
 4955               	.L296:
 966:iv.c          ****       if (pressed & 0x4)
 4957               	.LM603:
 4958 16e6 8091 0000 		lds r24,pressed
 4959 16ea 82FF      		sbrs r24,2
 4960 16ec 00C0      		rjmp .L303
 4961               	.LBB213:
 4962               	.LBB214:
 116:iv.c          ****   sei();
 4964               	.LM604:
 4965               	/* #APP */
 4966               	 ;  116 "iv.c" 1
 4967 16ee 7894      		sei
 4968               	 ;  0 "" 2
 118:iv.c          ****   milliseconds = 0;
 4970               	.LM605:
 4971               	/* #NOAPP */
 4972 16f0 1092 0000 		sts (milliseconds)+1,__zero_reg__
 4973 16f4 1092 0000 		sts milliseconds,__zero_reg__
 4974               	.L297:
 119:iv.c          ****   while (milliseconds < ms);
 4976               	.LM606:
 4977 16f8 8091 0000 		lds r24,milliseconds
 4978 16fc 9091 0000 		lds r25,(milliseconds)+1
 4979 1700 CC97      		sbiw r24,60
 4980 1702 00F0      		brlo .L297
 4981 1704 00C0      		rjmp .L303
 4982               	.L298:
 4983               	/* epilogue start */
 4984               	.LBE214:
 4985               	.LBE213:
 970:iv.c          **** }
 4987               	.LM607:
 4988 1706 1F91      		pop r17
 4989 1708 0F91      		pop r16
 4990 170a FF90      		pop r15
 4991 170c 0895      		ret
 4996               	.Lscope34:
 4998               		.stabd	78,0,0
 5000               	.global	__vector_23
 5002               	__vector_23:
 5003               		.stabd	46,0,0
 369:iv.c          **** SIGNAL(SIG_COMPARATOR) {
 5005               	.LM608:
 5006               	.LFBB35:
 5007 170e 1F92      		push __zero_reg__
 5008 1710 0F92      		push r0
 5009 1712 0FB6      		in r0,__SREG__
 5010 1714 0F92      		push r0
 5011 1716 1124      		clr __zero_reg__
 5012 1718 2F93      		push r18
 5013 171a 3F93      		push r19
 5014 171c 4F93      		push r20
 5015 171e 5F93      		push r21
 5016 1720 6F93      		push r22
 5017 1722 7F93      		push r23
 5018 1724 8F93      		push r24
 5019 1726 9F93      		push r25
 5020 1728 AF93      		push r26
 5021 172a BF93      		push r27
 5022 172c EF93      		push r30
 5023 172e FF93      		push r31
 5024               	/* prologue: Signal */
 5025               	/* frame size = 0 */
 371:iv.c          ****   if (ACSR & _BV(ACO)) {
 5027               	.LM609:
 5028 1730 00B6      		in __tmp_reg__,80-32
 5029 1732 05FE      		sbrs __tmp_reg__,5
 5030 1734 00C0      		rjmp .L308
 373:iv.c          ****     if (!sleepmode) {
 5032               	.LM610:
 5033 1736 8091 0000 		lds r24,sleepmode
 5034 173a 8823      		tst r24
 5035 173c 01F0      		breq .+2
 5036 173e 00C0      		rjmp .L312
 374:iv.c          ****       VFDSWITCH_PORT |= _BV(VFDSWITCH); // turn off display
 5038               	.LM611:
 5039 1740 5B9A      		sbi 43-32,3
 375:iv.c          ****       VFDCLK_PORT &= ~_BV(VFDCLK) & ~_BV(VFDDATA); // no power to vfdchip
 5041               	.LM612:
 5042 1742 85B1      		in r24,37-32
 5043 1744 877D      		andi r24,lo8(-41)
 5044 1746 85B9      		out 37-32,r24
 376:iv.c          ****       BOOST_PORT &= ~_BV(BOOST); // pull boost fet low
 5046               	.LM613:
 5047 1748 5E98      		cbi 43-32,6
 377:iv.c          ****       SPCR  &= ~_BV(SPE); // turn off spi
 5049               	.LM614:
 5050 174a 8CB5      		in r24,76-32
 5051 174c 8F7B      		andi r24,lo8(-65)
 5052 174e 8CBD      		out 76-32,r24
 378:iv.c          ****       if (restored) {
 5054               	.LM615:
 5055 1750 8091 0000 		lds r24,restored
 5056 1754 8823      		tst r24
 5057 1756 01F0      		breq .L310
 379:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_MIN, time_m);
 5059               	.LM616:
 5060 1758 6091 0000 		lds r22,time_m
 5061 175c 85E0      		ldi r24,lo8(5)
 5062 175e 90E0      		ldi r25,hi8(5)
 5063 1760 0E94 0000 		call __eewr_byte_m168
 380:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_SEC, time_s);
 5065               	.LM617:
 5066 1764 6091 0000 		lds r22,time_s
 5067 1768 86E0      		ldi r24,lo8(6)
 5068 176a 90E0      		ldi r25,hi8(6)
 5069 176c 0E94 0000 		call __eewr_byte_m168
 5070               	.L310:
 382:iv.c          ****       DEBUGP("z");
 5072               	.LM618:
 5073 1770 80E0      		ldi r24,lo8(__c.1972)
 5074 1772 90E0      		ldi r25,hi8(__c.1972)
 5075 1774 61E0      		ldi r22,lo8(1)
 5076 1776 0E94 0000 		call ROM_putstring
 383:iv.c          ****       TCCR0B = 0; // no boost
 5078               	.LM619:
 5079 177a 15BC      		out 69-32,__zero_reg__
 384:iv.c          ****       volume = 0; // low power buzzer
 5081               	.LM620:
 5082 177c 1092 0000 		sts volume,__zero_reg__
 385:iv.c          ****       PCICR = 0;  // ignore buttons
 5084               	.LM621:
 5085 1780 1092 6800 		sts 104,__zero_reg__
 387:iv.c          ****       DIMMER_POWER_PORT &= ~_BV(DIMMER_POWER_PIN); // no power to photoresistor
 5087               	.LM622:
 5088 1784 4598      		cbi 40-32,5
 5089 1786 00C0      		rjmp .L313
 5090               	.L308:
 394:iv.c          ****     if (sleepmode) {
 5092               	.LM623:
 5093 1788 8091 0000 		lds r24,sleepmode
 5094 178c 8823      		tst r24
 5095 178e 01F0      		breq .L312
 395:iv.c          ****       if (restored) {
 5097               	.LM624:
 5098 1790 8091 0000 		lds r24,restored
 5099 1794 8823      		tst r24
 5100 1796 01F0      		breq .L311
 396:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_MIN, time_m);
 5102               	.LM625:
 5103 1798 6091 0000 		lds r22,time_m
 5104 179c 85E0      		ldi r24,lo8(5)
 5105 179e 90E0      		ldi r25,hi8(5)
 5106 17a0 0E94 0000 		call __eewr_byte_m168
 397:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_SEC, time_s);
 5108               	.LM626:
 5109 17a4 6091 0000 		lds r22,time_s
 5110 17a8 86E0      		ldi r24,lo8(6)
 5111 17aa 90E0      		ldi r25,hi8(6)
 5112 17ac 0E94 0000 		call __eewr_byte_m168
 5113               	.L311:
 399:iv.c          ****       DEBUGP("WAKERESET"); 
 5115               	.LM627:
 5116 17b0 80E0      		ldi r24,lo8(__c.1974)
 5117 17b2 90E0      		ldi r25,hi8(__c.1974)
 5118 17b4 61E0      		ldi r22,lo8(1)
 5119 17b6 0E94 0000 		call ROM_putstring
 5120               	.L313:
 400:iv.c          ****       app_start();
 5122               	.LM628:
 5123 17ba E091 0000 		lds r30,app_start
 5124 17be F091 0000 		lds r31,(app_start)+1
 5125 17c2 0995      		icall
 5126               	.L312:
 5127               	/* epilogue start */
 403:iv.c          **** }
 5129               	.LM629:
 5130 17c4 FF91      		pop r31
 5131 17c6 EF91      		pop r30
 5132 17c8 BF91      		pop r27
 5133 17ca AF91      		pop r26
 5134 17cc 9F91      		pop r25
 5135 17ce 8F91      		pop r24
 5136 17d0 7F91      		pop r23
 5137 17d2 6F91      		pop r22
 5138 17d4 5F91      		pop r21
 5139 17d6 4F91      		pop r20
 5140 17d8 3F91      		pop r19
 5141 17da 2F91      		pop r18
 5142 17dc 0F90      		pop r0
 5143 17de 0FBE      		out __SREG__,r0
 5144 17e0 0F90      		pop r0
 5145 17e2 1F90      		pop __zero_reg__
 5146 17e4 1895      		reti
 5148               	.Lscope35:
 5150               		.stabd	78,0,0
 5151               		.data
 5152               	.LC22:
 5153 0090 736E 6F6F 		.string	"snoozing"
 5153      7A69 6E67 
 5153      00
 5154               		.text
 5156               	.global	setsnooze
 5158               	setsnooze:
 5159               		.stabd	46,0,0
 125:iv.c          **** void setsnooze(void) {
 5161               	.LM630:
 5162               	.LFBB36:
 5163               	/* prologue: function */
 5164               	/* frame size = 0 */
 128:iv.c          ****   snoozetimer = MAXSNOOZE;
 5166               	.LM631:
 5167 17e6 88E5      		ldi r24,lo8(600)
 5168 17e8 92E0      		ldi r25,hi8(600)
 5169 17ea 9093 0000 		sts (snoozetimer)+1,r25
 5170 17ee 8093 0000 		sts snoozetimer,r24
 129:iv.c          ****   DEBUGP("snooze");
 5172               	.LM632:
 5173 17f2 80E0      		ldi r24,lo8(__c.1783)
 5174 17f4 90E0      		ldi r25,hi8(__c.1783)
 5175 17f6 61E0      		ldi r22,lo8(1)
 5176 17f8 0E94 0000 		call ROM_putstring
 130:iv.c          ****   display_str("snoozing");
 5178               	.LM633:
 5179 17fc 80E0      		ldi r24,lo8(.LC22)
 5180 17fe 90E0      		ldi r25,hi8(.LC22)
 5181 1800 0E94 0000 		call display_str
 131:iv.c          ****   displaymode = SHOW_SNOOZE;
 5183               	.LM634:
 5184 1804 89E0      		ldi r24,lo8(9)
 5185 1806 8093 0000 		sts displaymode,r24
 5186               	.LBB215:
 5187               	.LBB216:
 116:iv.c          ****   sei();
 5189               	.LM635:
 5190               	/* #APP */
 5191               	 ;  116 "iv.c" 1
 5192 180a 7894      		sei
 5193               	 ;  0 "" 2
 118:iv.c          ****   milliseconds = 0;
 5195               	.LM636:
 5196               	/* #NOAPP */
 5197 180c 1092 0000 		sts (milliseconds)+1,__zero_reg__
 5198 1810 1092 0000 		sts milliseconds,__zero_reg__
 5199               	.L315:
 119:iv.c          ****   while (milliseconds < ms);
 5201               	.LM637:
 5202 1814 8091 0000 		lds r24,milliseconds
 5203 1818 9091 0000 		lds r25,(milliseconds)+1
 5204 181c 885E      		subi r24,lo8(1000)
 5205 181e 9340      		sbci r25,hi8(1000)
 5206 1820 00F0      		brlo .L315
 5207               	.LBE216:
 5208               	.LBE215:
 133:iv.c          ****   displaymode = SHOW_TIME;
 5210               	.LM638:
 5211 1822 1092 0000 		sts displaymode,__zero_reg__
 5212               	/* epilogue start */
 134:iv.c          **** }
 5214               	.LM639:
 5215 1826 0895      		ret
 5217               	.Lscope36:
 5219               		.stabd	78,0,0
 5221               	.global	__vector_3
 5223               	__vector_3:
 5224               		.stabd	46,0,0
 274:iv.c          **** SIGNAL(SIG_PIN_CHANGE0) {
 5226               	.LM640:
 5227               	.LFBB37:
 5228 1828 1F92      		push __zero_reg__
 5229 182a 0F92      		push r0
 5230 182c 0FB6      		in r0,__SREG__
 5231 182e 0F92      		push r0
 5232 1830 1124      		clr __zero_reg__
 5233 1832 2F93      		push r18
 5234 1834 3F93      		push r19
 5235 1836 4F93      		push r20
 5236 1838 5F93      		push r21
 5237 183a 6F93      		push r22
 5238 183c 7F93      		push r23
 5239 183e 8F93      		push r24
 5240 1840 9F93      		push r25
 5241 1842 AF93      		push r26
 5242 1844 BF93      		push r27
 5243 1846 EF93      		push r30
 5244 1848 FF93      		push r31
 5245               	/* prologue: Signal */
 5246               	/* frame size = 0 */
 275:iv.c          ****   PCMSK0 = 0;
 5248               	.LM641:
 5249 184a 1092 6B00 		sts 107,__zero_reg__
 276:iv.c          ****   sei();
 5251               	.LM642:
 5252               	/* #APP */
 5253               	 ;  276 "iv.c" 1
 5254 184e 7894      		sei
 5255               	 ;  0 "" 2
 277:iv.c          ****   if (! (PINB & _BV(BUTTON2))) {
 5257               	.LM643:
 5258               	/* #NOAPP */
 5259 1850 1899      		sbic 35-32,0
 5260 1852 00C0      		rjmp .L319
 279:iv.c          ****     if (! (last_buttonstate & 0x2)) { // was not pressed before
 5262               	.LM644:
 5263 1854 8091 0000 		lds r24,last_buttonstate
 5264 1858 81FD      		sbrc r24,1
 5265 185a 00C0      		rjmp .L320
 5266               	.LBB217:
 5267               	.LBB218:
 116:iv.c          ****   sei();
 5269               	.LM645:
 5270               	/* #APP */
 5271               	 ;  116 "iv.c" 1
 5272 185c 7894      		sei
 5273               	 ;  0 "" 2
 118:iv.c          ****   milliseconds = 0;
 5275               	.LM646:
 5276               	/* #NOAPP */
 5277 185e 1092 0000 		sts (milliseconds)+1,__zero_reg__
 5278 1862 1092 0000 		sts milliseconds,__zero_reg__
 5279               	.L321:
 119:iv.c          ****   while (milliseconds < ms);
 5281               	.LM647:
 5282 1866 8091 0000 		lds r24,milliseconds
 5283 186a 9091 0000 		lds r25,(milliseconds)+1
 5284 186e 0A97      		sbiw r24,10
 5285 1870 00F0      		brlo .L321
 5286               	.LBE218:
 5287               	.LBE217:
 281:iv.c          ****       if (PINB & _BV(BUTTON2))        // filter out bounces
 5289               	.LM648:
 5290 1872 1899      		sbic 35-32,0
 5291 1874 00C0      		rjmp .L320
 5292               	.L322:
 286:iv.c          ****       tick();                         // make a noise
 5294               	.LM649:
 5295 1876 0E94 0000 		call tick
 288:iv.c          ****       if (alarming) {
 5297               	.LM650:
 5298 187a 8091 0000 		lds r24,alarming
 5299 187e 8823      		tst r24
 5300 1880 01F0      		breq .L324
 289:iv.c          **** 	setsnooze(); 	// turn on snooze
 5302               	.LM651:
 5303 1882 0E94 0000 		call setsnooze
 5304 1886 00C0      		rjmp .L320
 5305               	.L324:
 293:iv.c          ****       last_buttonstate |= 0x2;
 5307               	.LM652:
 5308 1888 8091 0000 		lds r24,last_buttonstate
 5309 188c 8260      		ori r24,lo8(2)
 5310 188e 8093 0000 		sts last_buttonstate,r24
 294:iv.c          ****       just_pressed |= 0x2;
 5312               	.LM653:
 5313 1892 8091 0000 		lds r24,just_pressed
 5314 1896 8260      		ori r24,lo8(2)
 5315 1898 8093 0000 		sts just_pressed,r24
 295:iv.c          ****       DEBUGP("b2");
 5317               	.LM654:
 5318 189c 80E0      		ldi r24,lo8(__c.1886)
 5319 189e 90E0      		ldi r25,hi8(__c.1886)
 5320 18a0 61E0      		ldi r22,lo8(1)
 5321 18a2 0E94 0000 		call ROM_putstring
 5322 18a6 00C0      		rjmp .L320
 5323               	.L319:
 298:iv.c          ****     last_buttonstate &= ~0x2;
 5325               	.LM655:
 5326 18a8 8091 0000 		lds r24,last_buttonstate
 5327 18ac 8D7F      		andi r24,lo8(-3)
 5328 18ae 8093 0000 		sts last_buttonstate,r24
 5329               	.L320:
 300:iv.c          ****   PCMSK0 = _BV(PCINT0);
 5331               	.LM656:
 5332 18b2 81E0      		ldi r24,lo8(1)
 5333 18b4 8093 6B00 		sts 107,r24
 5334               	/* epilogue start */
 301:iv.c          **** }
 5336               	.LM657:
 5337 18b8 FF91      		pop r31
 5338 18ba EF91      		pop r30
 5339 18bc BF91      		pop r27
 5340 18be AF91      		pop r26
 5341 18c0 9F91      		pop r25
 5342 18c2 8F91      		pop r24
 5343 18c4 7F91      		pop r23
 5344 18c6 6F91      		pop r22
 5345 18c8 5F91      		pop r21
 5346 18ca 4F91      		pop r20
 5347 18cc 3F91      		pop r19
 5348 18ce 2F91      		pop r18
 5349 18d0 0F90      		pop r0
 5350 18d2 0FBE      		out __SREG__,r0
 5351 18d4 0F90      		pop r0
 5352 18d6 1F90      		pop __zero_reg__
 5353 18d8 1895      		reti
 5355               	.Lscope37:
 5357               		.stabd	78,0,0
 5359               	.global	__vector_5
 5361               	__vector_5:
 5362               		.stabd	46,0,0
 204:iv.c          **** SIGNAL(SIG_PIN_CHANGE2) {
 5364               	.LM658:
 5365               	.LFBB38:
 5366 18da 1F92      		push __zero_reg__
 5367 18dc 0F92      		push r0
 5368 18de 0FB6      		in r0,__SREG__
 5369 18e0 0F92      		push r0
 5370 18e2 1124      		clr __zero_reg__
 5371 18e4 2F93      		push r18
 5372 18e6 3F93      		push r19
 5373 18e8 4F93      		push r20
 5374 18ea 5F93      		push r21
 5375 18ec 6F93      		push r22
 5376 18ee 7F93      		push r23
 5377 18f0 8F93      		push r24
 5378 18f2 9F93      		push r25
 5379 18f4 AF93      		push r26
 5380 18f6 BF93      		push r27
 5381 18f8 EF93      		push r30
 5382 18fa FF93      		push r31
 5383               	/* prologue: Signal */
 5384               	/* frame size = 0 */
 206:iv.c          ****   PCMSK2 = 0;
 5386               	.LM659:
 5387 18fc 1092 6D00 		sts 109,__zero_reg__
 207:iv.c          ****   sei();
 5389               	.LM660:
 5390               	/* #APP */
 5391               	 ;  207 "iv.c" 1
 5392 1900 7894      		sei
 5393               	 ;  0 "" 2
 5394               	/* #NOAPP */
 5395               	.LBB219:
 5396               	.LBB220:
 138:iv.c          ****   wdt_reset();
 5398               	.LM661:
 5399               	/* #APP */
 5400               	 ;  138 "iv.c" 1
 5401 1902 A895      		wdr
 5402               	 ;  0 "" 2
 5403               	/* #NOAPP */
 5404               	.LBE220:
 5405               	.LBE219:
 211:iv.c          ****   if (! (PIND & _BV(BUTTON1))) {
 5407               	.LM662:
 5408 1904 4D99      		sbic 41-32,5
 5409 1906 00C0      		rjmp .L328
 213:iv.c          ****     if (! (last_buttonstate & 0x1)) { // was not pressed before
 5411               	.LM663:
 5412 1908 8091 0000 		lds r24,last_buttonstate
 5413 190c 80FD      		sbrc r24,0
 5414 190e 00C0      		rjmp .L329
 5415               	.LBB221:
 5416               	.LBB222:
 116:iv.c          ****   sei();
 5418               	.LM664:
 5419               	/* #APP */
 5420               	 ;  116 "iv.c" 1
 5421 1910 7894      		sei
 5422               	 ;  0 "" 2
 118:iv.c          ****   milliseconds = 0;
 5424               	.LM665:
 5425               	/* #NOAPP */
 5426 1912 1092 0000 		sts (milliseconds)+1,__zero_reg__
 5427 1916 1092 0000 		sts milliseconds,__zero_reg__
 5428               	.L330:
 119:iv.c          ****   while (milliseconds < ms);
 5430               	.LM666:
 5431 191a 8091 0000 		lds r24,milliseconds
 5432 191e 9091 0000 		lds r25,(milliseconds)+1
 5433 1922 0A97      		sbiw r24,10
 5434 1924 00F0      		brlo .L330
 5435               	.LBE222:
 5436               	.LBE221:
 215:iv.c          ****       if (PIND & _BV(BUTTON1))        // filter out bounces
 5438               	.LM667:
 5439 1926 4D99      		sbic 41-32,5
 5440 1928 00C0      		rjmp .L335
 5441               	.L331:
 220:iv.c          ****       tick();                         // make a noise
 5443               	.LM668:
 5444 192a 0E94 0000 		call tick
 222:iv.c          ****       if (alarming) {
 5446               	.LM669:
 5447 192e 8091 0000 		lds r24,alarming
 5448 1932 8823      		tst r24
 5449 1934 01F4      		brne .L345
 5450               	.L333:
 228:iv.c          ****       last_buttonstate |= 0x1;
 5452               	.LM670:
 5453 1936 8091 0000 		lds r24,last_buttonstate
 5454 193a 8160      		ori r24,lo8(1)
 5455 193c 8093 0000 		sts last_buttonstate,r24
 229:iv.c          ****       just_pressed |= 0x1;
 5457               	.LM671:
 5458 1940 8091 0000 		lds r24,just_pressed
 5459 1944 8160      		ori r24,lo8(1)
 5460 1946 8093 0000 		sts just_pressed,r24
 230:iv.c          ****       DEBUGP("b1");
 5462               	.LM672:
 5463 194a 80E0      		ldi r24,lo8(__c.1832)
 5464 194c 90E0      		ldi r25,hi8(__c.1832)
 5465 194e 61E0      		ldi r22,lo8(1)
 5466 1950 0E94 0000 		call ROM_putstring
 5467 1954 00C0      		rjmp .L329
 5468               	.L328:
 233:iv.c          ****     last_buttonstate &= ~0x1;
 5470               	.LM673:
 5471 1956 8091 0000 		lds r24,last_buttonstate
 5472 195a 8E7F      		andi r24,lo8(-2)
 5473 195c 8093 0000 		sts last_buttonstate,r24
 5474               	.L329:
 236:iv.c          ****   if (! (PIND & _BV(BUTTON3))) {
 5476               	.LM674:
 5477 1960 4C99      		sbic 41-32,4
 5478 1962 00C0      		rjmp .L334
 238:iv.c          ****     if (! (last_buttonstate & 0x4)) { // was not pressed before
 5480               	.LM675:
 5481 1964 8091 0000 		lds r24,last_buttonstate
 5482 1968 82FD      		sbrc r24,2
 5483 196a 00C0      		rjmp .L335
 5484               	.LBB223:
 5485               	.LBB224:
 116:iv.c          ****   sei();
 5487               	.LM676:
 5488               	/* #APP */
 5489               	 ;  116 "iv.c" 1
 5490 196c 7894      		sei
 5491               	 ;  0 "" 2
 118:iv.c          ****   milliseconds = 0;
 5493               	.LM677:
 5494               	/* #NOAPP */
 5495 196e 1092 0000 		sts (milliseconds)+1,__zero_reg__
 5496 1972 1092 0000 		sts milliseconds,__zero_reg__
 5497               	.L336:
 119:iv.c          ****   while (milliseconds < ms);
 5499               	.LM678:
 5500 1976 8091 0000 		lds r24,milliseconds
 5501 197a 9091 0000 		lds r25,(milliseconds)+1
 5502 197e 0A97      		sbiw r24,10
 5503 1980 00F0      		brlo .L336
 5504               	.LBE224:
 5505               	.LBE223:
 240:iv.c          ****       if (PIND & _BV(BUTTON3))        // filter out bounces
 5507               	.LM679:
 5508 1982 4C99      		sbic 41-32,4
 5509 1984 00C0      		rjmp .L335
 5510               	.L337:
 245:iv.c          ****       buttonholdcounter = 2;          // see if we're press-and-holding
 5512               	.LM680:
 5513 1986 82E0      		ldi r24,lo8(2)
 5514 1988 8093 0000 		sts buttonholdcounter,r24
 5515 198c 00C0      		rjmp .L338
 5516               	.L340:
 247:iv.c          **** 	if (PIND & _BV(BUTTON3)) {        // released
 5518               	.LM681:
 5519 198e 4C9B      		sbis 41-32,4
 5520 1990 00C0      		rjmp .L338
 248:iv.c          **** 	  tick();                         // make a noise
 5522               	.LM682:
 5523 1992 0E94 0000 		call tick
 249:iv.c          **** 	  last_buttonstate &= ~0x4;
 5525               	.LM683:
 5526 1996 8091 0000 		lds r24,last_buttonstate
 5527 199a 8B7F      		andi r24,lo8(-5)
 5528 199c 8093 0000 		sts last_buttonstate,r24
 251:iv.c          **** 	  if (alarming) {
 5530               	.LM684:
 5531 19a0 8091 0000 		lds r24,alarming
 5532 19a4 8823      		tst r24
 5533 19a6 01F0      		breq .L339
 5534               	.L345:
 253:iv.c          **** 	    setsnooze();
 5536               	.LM685:
 5537 19a8 0E94 0000 		call setsnooze
 5538 19ac 00C0      		rjmp .L335
 5539               	.L339:
 257:iv.c          **** 	  DEBUGP("b3");
 5541               	.LM686:
 5542 19ae 80E0      		ldi r24,lo8(__c.1834)
 5543 19b0 90E0      		ldi r25,hi8(__c.1834)
 5544 19b2 61E0      		ldi r22,lo8(1)
 5545 19b4 0E94 0000 		call ROM_putstring
 258:iv.c          **** 	  just_pressed |= 0x4;
 5547               	.LM687:
 5548 19b8 8091 0000 		lds r24,just_pressed
 5549 19bc 8460      		ori r24,lo8(4)
 5550 19be 8093 0000 		sts just_pressed,r24
 5551 19c2 00C0      		rjmp .L335
 5552               	.L338:
 246:iv.c          ****       while (buttonholdcounter) {
 5554               	.LM688:
 5555 19c4 8091 0000 		lds r24,buttonholdcounter
 5556 19c8 8823      		tst r24
 5557 19ca 01F4      		brne .L340
 263:iv.c          ****       last_buttonstate |= 0x4;
 5559               	.LM689:
 5560 19cc 8091 0000 		lds r24,last_buttonstate
 5561 19d0 8460      		ori r24,lo8(4)
 5562 19d2 8093 0000 		sts last_buttonstate,r24
 264:iv.c          ****       pressed |= 0x4;                 // held down
 5564               	.LM690:
 5565 19d6 8091 0000 		lds r24,pressed
 5566 19da 8460      		ori r24,lo8(4)
 5567 19dc 8093 0000 		sts pressed,r24
 5568 19e0 00C0      		rjmp .L335
 5569               	.L334:
 267:iv.c          ****     pressed = 0;                      // button released
 5571               	.LM691:
 5572 19e2 1092 0000 		sts pressed,__zero_reg__
 268:iv.c          ****     last_buttonstate &= ~0x4;
 5574               	.LM692:
 5575 19e6 8091 0000 		lds r24,last_buttonstate
 5576 19ea 8B7F      		andi r24,lo8(-5)
 5577 19ec 8093 0000 		sts last_buttonstate,r24
 5578               	.L335:
 270:iv.c          ****   PCMSK2 = _BV(PCINT21) | _BV(PCINT20);
 5580               	.LM693:
 5581 19f0 80E3      		ldi r24,lo8(48)
 5582 19f2 8093 6D00 		sts 109,r24
 5583               	/* epilogue start */
 271:iv.c          **** }
 5585               	.LM694:
 5586 19f6 FF91      		pop r31
 5587 19f8 EF91      		pop r30
 5588 19fa BF91      		pop r27
 5589 19fc AF91      		pop r26
 5590 19fe 9F91      		pop r25
 5591 1a00 8F91      		pop r24
 5592 1a02 7F91      		pop r23
 5593 1a04 6F91      		pop r22
 5594 1a06 5F91      		pop r21
 5595 1a08 4F91      		pop r20
 5596 1a0a 3F91      		pop r19
 5597 1a0c 2F91      		pop r18
 5598 1a0e 0F90      		pop r0
 5599 1a10 0FBE      		out __SREG__,r0
 5600 1a12 0F90      		pop r0
 5601 1a14 1F90      		pop __zero_reg__
 5602 1a16 1895      		reti
 5604               	.Lscope38:
 5606               		.stabd	78,0,0
 5607               		.data
 5608               	.LC23:
 5609 0099 2447 5052 		.string	"$GPRMC"
 5609      4D43 00
 5610               	.LC24:
 5611 00a0 0A0D 00   		.string	"\n\r"
 5612               		.text
 5614               	.global	getgpstime
 5616               	getgpstime:
 5617               		.stabd	46,0,0
1767:iv.c          **** void getgpstime(void) {
 5619               	.LM695:
 5620               	.LFBB39:
 5621 1a18 8F92      		push r8
 5622 1a1a 9F92      		push r9
 5623 1a1c BF92      		push r11
 5624 1a1e CF92      		push r12
 5625 1a20 DF92      		push r13
 5626 1a22 EF92      		push r14
 5627 1a24 FF92      		push r15
 5628 1a26 0F93      		push r16
 5629 1a28 1F93      		push r17
 5630 1a2a DF93      		push r29
 5631 1a2c CF93      		push r28
 5632 1a2e CDB7      		in r28,__SP_L__
 5633 1a30 DEB7      		in r29,__SP_H__
 5634 1a32 2F97      		sbiw r28,15
 5635 1a34 0FB6      		in __tmp_reg__,__SREG__
 5636 1a36 F894      		cli
 5637 1a38 DEBF      		out __SP_H__,r29
 5638 1a3a 0FBE      		out __SREG__,__tmp_reg__
 5639 1a3c CDBF      		out __SP_L__,r28
 5640               	/* prologue: function */
 5641               	/* frame size = 15 */
1773:iv.c          ****   char charReceived = UDR0;
 5643               	.LM696:
 5644 1a3e 8091 C600 		lds r24,198
 5645 1a42 8983      		std Y+1,r24
1781:iv.c          ****   if ( ( 0 == intBufferStatus ) && ( '$' == charReceived ) ) {
 5647               	.LM697:
 5648 1a44 9091 0000 		lds r25,intBufferStatus
 5649 1a48 9923      		tst r25
 5650 1a4a 01F4      		brne .L347
 5651 1a4c 8432      		cpi r24,lo8(36)
 5652 1a4e 01F0      		breq .+2
 5653 1a50 00C0      		rjmp .L364
1782:iv.c          ****     intBufferStatus = 1;
 5655               	.LM698:
 5656 1a52 81E0      		ldi r24,lo8(1)
 5657 1a54 8093 0000 		sts intBufferStatus,r24
1783:iv.c          ****     strncat(strBuffer, &charReceived, 1);
 5659               	.LM699:
 5660 1a58 80E0      		ldi r24,lo8(strBuffer)
 5661 1a5a 90E0      		ldi r25,hi8(strBuffer)
 5662 1a5c 00C0      		rjmp .L370
 5663               	.L347:
1790:iv.c          ****     if ( ! ( ( strlen(strBuffer) < BUFFERSIZE ) ) ) {
 5665               	.LM700:
 5666 1a5e 00E0      		ldi r16,lo8(strBuffer)
 5667 1a60 10E0      		ldi r17,hi8(strBuffer)
 5668 1a62 F801      		movw r30,r16
 5669 1a64 0190      		ld __tmp_reg__,Z+
 5670 1a66 0020      		tst __tmp_reg__
 5671 1a68 01F4      		brne .-6
 5672 1a6a 3197      		sbiw r30,1
 5673 1a6c E01B      		sub r30,r16
 5674 1a6e F10B      		sbc r31,r17
 5675 1a70 E038      		cpi r30,128
 5676 1a72 F105      		cpc r31,__zero_reg__
 5677 1a74 00F4      		brsh .L372
 5678               	.L349:
1797:iv.c          ****     else if ( 6 == strlen(strBuffer) ) {
 5680               	.LM701:
 5681 1a76 3697      		sbiw r30,6
 5682 1a78 01F4      		brne .L350
1800:iv.c          ****       if ( 0 == strcmp( strBuffer, "$GPRMC" ) ) {
 5684               	.LM702:
 5685 1a7a C801      		movw r24,r16
 5686 1a7c 60E0      		ldi r22,lo8(.LC23)
 5687 1a7e 70E0      		ldi r23,hi8(.LC23)
 5688 1a80 0E94 0000 		call strcmp
 5689 1a84 0097      		sbiw r24,0
 5690 1a86 01F4      		brne .L351
1802:iv.c          ****         intBufferStatus = 2;
 5692               	.LM703:
 5693 1a88 82E0      		ldi r24,lo8(2)
 5694 1a8a 8093 0000 		sts intBufferStatus,r24
 5695 1a8e 00C0      		rjmp .L352
 5696               	.L351:
1811:iv.c          ****         memset( strBuffer, 0, BUFFERSIZE );
 5698               	.LM704:
 5699 1a90 80E8      		ldi r24,lo8(-128)
 5700 1a92 F801      		movw r30,r16
 5701 1a94 1192      		st Z+,__zero_reg__
 5702 1a96 8A95      	        dec r24
 5703 1a98 01F4      		brne .-6
 5704 1a9a 00C0      		rjmp .L371
 5705               	.L350:
1819:iv.c          ****     else if ( '*' == charReceived ) {
 5707               	.LM705:
 5708 1a9c 8A32      		cpi r24,lo8(42)
 5709 1a9e 01F0      		breq .+2
 5710 1aa0 00C0      		rjmp .L352
1822:iv.c          ****       if ( 2 != intBufferStatus ) {
 5712               	.LM706:
 5713 1aa2 9230      		cpi r25,lo8(2)
 5714 1aa4 01F0      		breq .L353
 5715               	.L372:
1823:iv.c          ****         memset( strBuffer, 0, BUFFERSIZE );
 5717               	.LM707:
 5718 1aa6 80E8      		ldi r24,lo8(-128)
 5719 1aa8 D801      		movw r26,r16
 5720 1aaa 00C0      		rjmp .L369
 5721               	.L353:
1832:iv.c          ****         uart_puts("\n\r");
 5723               	.LM708:
 5724 1aac 80E0      		ldi r24,lo8(.LC24)
 5725 1aae 90E0      		ldi r25,hi8(.LC24)
 5726 1ab0 0E94 0000 		call uart_puts
1833:iv.c          ****         uart_puts(strBuffer);
 5728               	.LM709:
 5729 1ab4 C801      		movw r24,r16
 5730 1ab6 0E94 0000 		call uart_puts
1836:iv.c          ****         strPointer1 = strchr( strBuffer, ',');
 5732               	.LM710:
 5733 1aba C801      		movw r24,r16
 5734 1abc 6CE2      		ldi r22,lo8(44)
 5735 1abe 70E0      		ldi r23,hi8(44)
 5736 1ac0 0E94 0000 		call strchr
1839:iv.c          ****         memcpy( strTime, strPointer1 + 1, 6 );
 5738               	.LM711:
 5739 1ac4 DE01      		movw r26,r28
 5740 1ac6 1296      		adiw r26,2
 5741 1ac8 FC01      		movw r30,r24
 5742 1aca 3196      		adiw r30,1
 5743 1acc 26E0      		ldi r18,lo8(6)
 5744               	.L354:
 5745 1ace 0190      		ld r0,Z+
 5746 1ad0 0D92      		st X+,r0
 5747 1ad2 2150      		subi r18,lo8(-(-1))
 5748 1ad4 01F4      		brne .L354
1841:iv.c          ****         strTime[6] = 0;
 5750               	.LM712:
 5751 1ad6 1886      		std Y+8,__zero_reg__
 5752 1ad8 00E0      		ldi r16,lo8(0)
 5753 1ada 10E0      		ldi r17,hi8(0)
 5754               	.L355:
 5755               	.LBB225:
1847:iv.c          ****           strPointer1 = strchr( strPointer1 + 1, ',');
 5757               	.LM713:
 5758 1adc 0196      		adiw r24,1
 5759 1ade 6CE2      		ldi r22,lo8(44)
 5760 1ae0 70E0      		ldi r23,hi8(44)
 5761 1ae2 0E94 0000 		call strchr
1846:iv.c          ****         for ( int i = 0; i < 8; i++ ) {
 5763               	.LM714:
 5764 1ae6 0F5F      		subi r16,lo8(-(1))
 5765 1ae8 1F4F      		sbci r17,hi8(-(1))
 5766 1aea 0830      		cpi r16,8
 5767 1aec 1105      		cpc r17,__zero_reg__
 5768 1aee 01F4      		brne .L355
 5769               	.LBE225:
1851:iv.c          ****         memcpy( strDate, strPointer1 + 1, 6 );
 5771               	.LM715:
 5772 1af0 DE01      		movw r26,r28
 5773 1af2 1996      		adiw r26,9
 5774 1af4 FC01      		movw r30,r24
 5775 1af6 3196      		adiw r30,1
 5776 1af8 86E0      		ldi r24,lo8(6)
 5777               	.L356:
 5778 1afa 0190      		ld r0,Z+
 5779 1afc 0D92      		st X+,r0
 5780 1afe 8150      		subi r24,lo8(-(-1))
 5781 1b00 01F4      		brne .L356
1853:iv.c          ****         strDate[6] = 0;
 5783               	.LM716:
 5784 1b02 1F86      		std Y+15,__zero_reg__
1858:iv.c          ****         if ( PROGRAMMING_YEAR <= ( ( (strDate[4] - '0') * 10 ) ) + (strDate[5] - '0') ) {
 5786               	.LM717:
 5787 1b04 8E85      		ldd r24,Y+14
 5788 1b06 90E0      		ldi r25,lo8(0)
 5789 1b08 8051      		subi r24,lo8(-(-528))
 5790 1b0a 9240      		sbci r25,hi8(-(-528))
 5791 1b0c 2D85      		ldd r18,Y+13
 5792 1b0e 4AE0      		ldi r20,lo8(10)
 5793 1b10 249F      		mul r18,r20
 5794 1b12 9001      		movw r18,r0
 5795 1b14 1124      		clr r1
 5796 1b16 820F      		add r24,r18
 5797 1b18 931F      		adc r25,r19
 5798 1b1a 0A97      		sbiw r24,10
 5799 1b1c 04F4      		brge .+2
 5800 1b1e 00C0      		rjmp .L357
 5801               	.LBB226:
1860:iv.c          ****           intOldHr = time_h;
 5803               	.LM718:
 5804 1b20 1091 0000 		lds r17,time_h
1861:iv.c          ****           intOldMin = time_m;
 5806               	.LM719:
 5807 1b24 0091 0000 		lds r16,time_m
1862:iv.c          ****           intOldSec = time_s;
 5809               	.LM720:
 5810 1b28 8091 0000 		lds r24,time_s
1865:iv.c          ****           setgpstime(strTime);
 5812               	.LM721:
 5813 1b2c CE01      		movw r24,r28
 5814 1b2e 0296      		adiw r24,2
 5815 1b30 0E94 0000 		call setgpstime
1867:iv.c          ****           setgpsdate(strDate);
 5817               	.LM722:
 5818 1b34 CE01      		movw r24,r28
 5819 1b36 0996      		adiw r24,9
 5820 1b38 0E94 0000 		call setgpsdate
1870:iv.c          ****           fix_time();
 5822               	.LM723:
 5823 1b3c 0E94 0000 		call fix_time
1873:iv.c          ****           uint16_t timeMinutes = ((time_h * 60) + (time_m));
 5825               	.LM724:
 5826 1b40 3091 0000 		lds r19,time_h
 5827 1b44 8091 0000 		lds r24,time_m
 5828 1b48 2CE3      		ldi r18,lo8(60)
 5829 1b4a 3202      		muls r19,r18
 5830 1b4c D001      		movw r26,r0
 5831 1b4e 1124      		clr r1
 5832 1b50 9927      		clr r25
 5833 1b52 87FD      		sbrc r24,7
 5834 1b54 9095      		com r25
 5835 1b56 A80F      		add r26,r24
 5836 1b58 B91F      		adc r27,r25
1874:iv.c          ****           uint16_t oldTimeMinutes = ((intOldHr * 60) + (intOldMin));
 5838               	.LM725:
 5839 1b5a 812E      		mov r8,r17
 5840 1b5c 9924      		clr r9
 5841 1b5e 8CE3      		ldi r24,lo8(60)
 5842 1b60 90E0      		ldi r25,hi8(60)
 5843 1b62 889E      		mul r8,r24
 5844 1b64 F001      		movw r30,r0
 5845 1b66 899E      		mul r8,r25
 5846 1b68 F00D      		add r31,r0
 5847 1b6a 989E      		mul r9,r24
 5848 1b6c F00D      		add r31,r0
 5849 1b6e 1124      		clr r1
 5850 1b70 E00F      		add r30,r16
 5851 1b72 F11D      		adc r31,__zero_reg__
1876:iv.c          ****           int8_t intTempHr = time_h;
 5853               	.LM726:
 5854 1b74 E090 0000 		lds r14,time_h
1877:iv.c          ****           int8_t intTempMin = time_m;
 5856               	.LM727:
 5857 1b78 F090 0000 		lds r15,time_m
1881:iv.c          ****           if ( ( 0 > (int16_t)( timeMinutes - oldTimeMinutes ) )
 5859               	.LM728:
 5860 1b7c AD01      		movw r20,r26
 5861 1b7e 4E1B      		sub r20,r30
 5862 1b80 5F0B      		sbc r21,r31
 5863 1b82 57FF      		sbrs r21,7
 5864 1b84 00C0      		rjmp .L358
 5865 1b86 BD01      		movw r22,r26
 5866 1b88 6056      		subi r22,lo8(-(1440))
 5867 1b8a 7A4F      		sbci r23,hi8(-(1440))
 5868 1b8c 6E17      		cp r22,r30
 5869 1b8e 7F07      		cpc r23,r31
 5870 1b90 00F0      		brlo .L358
 5871 1b92 9A01      		movw r18,r20
 5872 1b94 2056      		subi r18,lo8(-(1440))
 5873 1b96 3A4F      		sbci r19,hi8(-(1440))
 5874 1b98 37FF      		sbrs r19,7
 5875 1b9a 00C0      		rjmp .L359
 5876 1b9c 3095      		com r19
 5877 1b9e 2195      		neg r18
 5878 1ba0 3F4F      		sbci r19,lo8(-1)
 5879               	.L359:
 5880 1ba2 8827      		clr r24
 5881 1ba4 9927      		clr r25
 5882 1ba6 841B      		sub r24,r20
 5883 1ba8 950B      		sbc r25,r21
 5884 1baa 2817      		cp r18,r24
 5885 1bac 3907      		cpc r19,r25
 5886 1bae 04F4      		brge .L358
1885:iv.c          ****             intTempHr += 24;
 5888               	.LM729:
 5889 1bb0 B8E1      		ldi r27,lo8(24)
 5890 1bb2 EB0E      		add r14,r27
 5891 1bb4 00C0      		rjmp .L360
 5892               	.L358:
 5893 1bb6 BD01      		movw r22,r26
 5894               	.L360:
1888:iv.c          ****           if ( timeMinutes > oldTimeMinutes ) {
 5896               	.LM730:
 5897 1bb8 E617      		cp r30,r22
 5898 1bba F707      		cpc r31,r23
 5899 1bbc 00F4      		brsh .L357
 5900 1bbe 00E0      		ldi r16,lo8(0)
 5901 1bc0 10E0      		ldi r17,hi8(0)
1891:iv.c          ****             for ( ; intTempHr >= intOldHr; intTempHr-- ) {
 5903               	.LM731:
 5904 1bc2 CE2C      		mov r12,r14
 5905 1bc4 DD24      		clr r13
 5906 1bc6 C7FC      		sbrc r12,7
 5907 1bc8 D094      		com r13
 5908 1bca 00C0      		rjmp .L361
 5909               	.L362:
1893:iv.c          ****                 check_alarm( (uint8_t)intTempHr, (uint8_t)intTempMin, 0 );
 5911               	.LM732:
 5912 1bcc 8B2D      		mov r24,r11
 5913 1bce 6F2D      		mov r22,r15
 5914 1bd0 40E0      		ldi r20,lo8(0)
 5915 1bd2 0E94 0000 		call check_alarm
1892:iv.c          ****               for ( ; intTempMin >= 0; intTempMin-- ) {
 5917               	.LM733:
 5918 1bd6 FA94      		dec r15
 5919 1bd8 00C0      		rjmp .L368
 5920               	.L363:
1893:iv.c          ****                 check_alarm( (uint8_t)intTempHr, (uint8_t)intTempMin, 0 );
 5922               	.LM734:
 5923 1bda BE2C      		mov r11,r14
 5924 1bdc B01A      		sub r11,r16
 5925               	.L368:
1892:iv.c          ****               for ( ; intTempMin >= 0; intTempMin-- ) {
 5927               	.LM735:
 5928 1bde F7FE      		sbrs r15,7
 5929 1be0 00C0      		rjmp .L362
 5930 1be2 0F5F      		subi r16,lo8(-(1))
 5931 1be4 1F4F      		sbci r17,hi8(-(1))
 5932 1be6 7BE3      		ldi r23,lo8(59)
 5933 1be8 F72E      		mov r15,r23
 5934               	.L361:
1891:iv.c          ****             for ( ; intTempHr >= intOldHr; intTempHr-- ) {
 5936               	.LM736:
 5937 1bea C601      		movw r24,r12
 5938 1bec 801B      		sub r24,r16
 5939 1bee 910B      		sbc r25,r17
 5940 1bf0 8815      		cp r24,r8
 5941 1bf2 9905      		cpc r25,r9
 5942 1bf4 04F4      		brge .L363
 5943               	.L357:
 5944               	.LBE226:
1903:iv.c          ****         memset( strBuffer, 0, BUFFERSIZE );
 5946               	.LM737:
 5947 1bf6 80E8      		ldi r24,lo8(-128)
 5948 1bf8 E0E0      		ldi r30,lo8(strBuffer)
 5949 1bfa F0E0      		ldi r31,hi8(strBuffer)
 5950 1bfc DF01      		movw r26,r30
 5951               	.L369:
 5952 1bfe 1D92      		st X+,__zero_reg__
 5953 1c00 8A95      	        dec r24
 5954 1c02 01F4      		brne .-6
 5955               	.L371:
1904:iv.c          ****         intBufferStatus = 0;
 5957               	.LM738:
 5958 1c04 1092 0000 		sts intBufferStatus,__zero_reg__
 5959 1c08 00C0      		rjmp .L364
 5960               	.L352:
1910:iv.c          ****       strncat(strBuffer, &charReceived, 1);
 5962               	.LM739:
 5963 1c0a C801      		movw r24,r16
 5964               	.L370:
 5965 1c0c BE01      		movw r22,r28
 5966 1c0e 6F5F      		subi r22,lo8(-(1))
 5967 1c10 7F4F      		sbci r23,hi8(-(1))
 5968 1c12 41E0      		ldi r20,lo8(1)
 5969 1c14 50E0      		ldi r21,hi8(1)
 5970 1c16 0E94 0000 		call strncat
 5971               	.L364:
 5972               	/* epilogue start */
1916:iv.c          **** }
 5974               	.LM740:
 5975 1c1a 2F96      		adiw r28,15
 5976 1c1c 0FB6      		in __tmp_reg__,__SREG__
 5977 1c1e F894      		cli
 5978 1c20 DEBF      		out __SP_H__,r29
 5979 1c22 0FBE      		out __SREG__,__tmp_reg__
 5980 1c24 CDBF      		out __SP_L__,r28
 5981 1c26 CF91      		pop r28
 5982 1c28 DF91      		pop r29
 5983 1c2a 1F91      		pop r17
 5984 1c2c 0F91      		pop r16
 5985 1c2e FF90      		pop r15
 5986 1c30 EF90      		pop r14
 5987 1c32 DF90      		pop r13
 5988 1c34 CF90      		pop r12
 5989 1c36 BF90      		pop r11
 5990 1c38 9F90      		pop r9
 5991 1c3a 8F90      		pop r8
 5992 1c3c 0895      		ret
 6009               	.Lscope39:
 6011               		.stabd	78,0,0
 6013               	.global	speaker_init
 6015               	speaker_init:
 6016               		.stabd	46,0,0
1363:iv.c          **** void speaker_init(void) {
 6018               	.LM741:
 6019               	.LFBB40:
 6020               	/* prologue: function */
 6021               	/* frame size = 0 */
1366:iv.c          ****   volume = eeprom_read_byte((uint8_t *)EE_VOLUME);
 6023               	.LM742:
 6024 1c3e 8AE0      		ldi r24,lo8(10)
 6025 1c40 90E0      		ldi r25,hi8(10)
 6026 1c42 0E94 0000 		call __eerd_byte_m168
 6027 1c46 8093 0000 		sts volume,r24
1369:iv.c          ****   PORTB |= _BV(SPK1) | _BV(SPK2); 
 6029               	.LM743:
 6030 1c4a 85B1      		in r24,37-32
 6031 1c4c 8660      		ori r24,lo8(6)
 6032 1c4e 85B9      		out 37-32,r24
1372:iv.c          ****   TCCR1A = _BV(COM1B1) | _BV(COM1B0) | _BV(WGM11);
 6034               	.LM744:
 6035 1c50 82E3      		ldi r24,lo8(50)
 6036 1c52 8093 8000 		sts 128,r24
1373:iv.c          ****   if (volume) {
 6038               	.LM745:
 6039 1c56 8091 0000 		lds r24,volume
 6040 1c5a 8823      		tst r24
 6041 1c5c 01F0      		breq .L374
1374:iv.c          ****     TCCR1A |= _BV(COM1A1);
 6043               	.LM746:
 6044 1c5e 8091 8000 		lds r24,128
 6045 1c62 8068      		ori r24,lo8(-128)
 6046 1c64 8093 8000 		sts 128,r24
 6047               	.L374:
1376:iv.c          ****   TCCR1B = _BV(WGM13) | _BV(WGM12);
 6049               	.LM747:
 6050 1c68 88E1      		ldi r24,lo8(24)
 6051 1c6a 8093 8100 		sts 129,r24
1379:iv.c          ****   ICR1 = 250;
 6053               	.LM748:
 6054 1c6e 8AEF      		ldi r24,lo8(250)
 6055 1c70 90E0      		ldi r25,hi8(250)
 6056 1c72 9093 8700 		sts (134)+1,r25
 6057 1c76 8093 8600 		sts 134,r24
1380:iv.c          ****   OCR1B = OCR1A = ICR1 / 2;
 6059               	.LM749:
 6060 1c7a 8091 8600 		lds r24,134
 6061 1c7e 9091 8700 		lds r25,(134)+1
 6062 1c82 9695      		lsr r25
 6063 1c84 8795      		ror r24
 6064 1c86 9093 8900 		sts (136)+1,r25
 6065 1c8a 8093 8800 		sts 136,r24
 6066 1c8e 8091 8800 		lds r24,136
 6067 1c92 9091 8900 		lds r25,(136)+1
 6068 1c96 9093 8B00 		sts (138)+1,r25
 6069 1c9a 8093 8A00 		sts 138,r24
 6070               	/* epilogue start */
1381:iv.c          **** }
 6072               	.LM750:
 6073 1c9e 0895      		ret
 6075               	.Lscope40:
 6077               		.stabd	78,0,0
 6079               	.global	clock_init
 6081               	clock_init:
 6082               		.stabd	46,0,0
1278:iv.c          **** void clock_init(void) {
 6084               	.LM751:
 6085               	.LFBB41:
 6086               	/* prologue: function */
 6087               	/* frame size = 0 */
1281:iv.c          ****   time_h = eeprom_read_byte((uint8_t *)EE_HOUR) % 24;
 6089               	.LM752:
 6090 1ca0 84E0      		ldi r24,lo8(4)
 6091 1ca2 90E0      		ldi r25,hi8(4)
 6092 1ca4 0E94 0000 		call __eerd_byte_m168
 6093 1ca8 68E1      		ldi r22,lo8(24)
 6094 1caa 0E94 0000 		call __udivmodqi4
 6095 1cae 9093 0000 		sts time_h,r25
1282:iv.c          ****   time_m = eeprom_read_byte((uint8_t *)EE_MIN) % 60;
 6097               	.LM753:
 6098 1cb2 85E0      		ldi r24,lo8(5)
 6099 1cb4 90E0      		ldi r25,hi8(5)
 6100 1cb6 0E94 0000 		call __eerd_byte_m168
 6101 1cba 6CE3      		ldi r22,lo8(60)
 6102 1cbc 0E94 0000 		call __udivmodqi4
 6103 1cc0 9093 0000 		sts time_m,r25
1283:iv.c          ****   time_s = eeprom_read_byte((uint8_t *)EE_SEC) % 60;
 6105               	.LM754:
 6106 1cc4 86E0      		ldi r24,lo8(6)
 6107 1cc6 90E0      		ldi r25,hi8(6)
 6108 1cc8 0E94 0000 		call __eerd_byte_m168
 6109 1ccc 6CE3      		ldi r22,lo8(60)
 6110 1cce 0E94 0000 		call __udivmodqi4
 6111 1cd2 9093 0000 		sts time_s,r25
1294:iv.c          ****   alarm_m = eeprom_read_byte((uint8_t *)EE_ALARM_MIN) % 60;
 6113               	.LM755:
 6114 1cd6 88E0      		ldi r24,lo8(8)
 6115 1cd8 90E0      		ldi r25,hi8(8)
 6116 1cda 0E94 0000 		call __eerd_byte_m168
 6117 1cde 6CE3      		ldi r22,lo8(60)
 6118 1ce0 0E94 0000 		call __udivmodqi4
 6119 1ce4 9093 0000 		sts alarm_m,r25
1295:iv.c          ****   alarm_h = eeprom_read_byte((uint8_t *)EE_ALARM_HOUR) % 24;
 6121               	.LM756:
 6122 1ce8 87E0      		ldi r24,lo8(7)
 6123 1cea 90E0      		ldi r25,hi8(7)
 6124 1cec 0E94 0000 		call __eerd_byte_m168
 6125 1cf0 68E1      		ldi r22,lo8(24)
 6126 1cf2 0E94 0000 		call __udivmodqi4
 6127 1cf6 9093 0000 		sts alarm_h,r25
1297:iv.c          ****   date_y = eeprom_read_byte((uint8_t *)EE_YEAR) % 100;
 6129               	.LM757:
 6130 1cfa 81E0      		ldi r24,lo8(1)
 6131 1cfc 90E0      		ldi r25,hi8(1)
 6132 1cfe 0E94 0000 		call __eerd_byte_m168
 6133 1d02 64E6      		ldi r22,lo8(100)
 6134 1d04 0E94 0000 		call __udivmodqi4
 6135 1d08 9093 0000 		sts date_y,r25
1298:iv.c          ****   date_m = eeprom_read_byte((uint8_t *)EE_MONTH) % 13;
 6137               	.LM758:
 6138 1d0c 82E0      		ldi r24,lo8(2)
 6139 1d0e 90E0      		ldi r25,hi8(2)
 6140 1d10 0E94 0000 		call __eerd_byte_m168
 6141 1d14 6DE0      		ldi r22,lo8(13)
 6142 1d16 0E94 0000 		call __udivmodqi4
 6143 1d1a 9093 0000 		sts date_m,r25
1299:iv.c          ****   date_d = eeprom_read_byte((uint8_t *)EE_DAY) % 32;
 6145               	.LM759:
 6146 1d1e 83E0      		ldi r24,lo8(3)
 6147 1d20 90E0      		ldi r25,hi8(3)
 6148 1d22 0E94 0000 		call __eerd_byte_m168
 6149 1d26 8F71      		andi r24,lo8(31)
 6150 1d28 8093 0000 		sts date_d,r24
1301:iv.c          ****   restored = 1;
 6152               	.LM760:
 6153 1d2c 91E0      		ldi r25,lo8(1)
 6154 1d2e 9093 0000 		sts restored,r25
1305:iv.c          ****   ASSR |= _BV(AS2); // use crystal
 6156               	.LM761:
 6157 1d32 E6EB      		ldi r30,lo8(182)
 6158 1d34 F0E0      		ldi r31,hi8(182)
 6159 1d36 8081      		ld r24,Z
 6160 1d38 8062      		ori r24,lo8(32)
 6161 1d3a 8083      		st Z,r24
1306:iv.c          ****   TCCR2B = _BV(CS22) | _BV(CS20); // div by 128
 6163               	.LM762:
 6164 1d3c 85E0      		ldi r24,lo8(5)
 6165 1d3e 8093 B100 		sts 177,r24
1310:iv.c          ****   TIMSK2 = _BV(TOIE2);
 6167               	.LM763:
 6168 1d42 9093 7000 		sts 112,r25
1313:iv.c          ****   sei();
 6170               	.LM764:
 6171               	/* #APP */
 6172               	 ;  1313 "iv.c" 1
 6173 1d46 7894      		sei
 6174               	 ;  0 "" 2
 6175               	/* epilogue start */
1314:iv.c          **** }
 6177               	.LM765:
 6178               	/* #NOAPP */
 6179 1d48 0895      		ret
 6181               	.Lscope41:
 6183               		.stabd	78,0,0
 6184               		.data
 6185               	.LC25:
 6186 00a3 7573 612D 		.string	"usa-12hr"
 6186      3132 6872 
 6186      00
 6187               	.LC26:
 6188 00ac 6575 722D 		.string	"eur-24hr"
 6188      3234 6872 
 6188      00
 6189               		.text
 6191               	.global	set_region
 6193               	set_region:
 6194               		.stabd	46,0,0
1172:iv.c          **** void set_region(void) {
 6196               	.LM766:
 6197               	.LFBB42:
 6198 1d4a 0F93      		push r16
 6199 1d4c 1F93      		push r17
 6200               	/* prologue: function */
 6201               	/* frame size = 0 */
1175:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;;  
 6203               	.LM767:
 6204 1d4e 8AE0      		ldi r24,lo8(10)
 6205 1d50 8093 0000 		sts timeoutcounter,r24
1176:iv.c          ****   region = eeprom_read_byte((uint8_t *)EE_REGION);
 6207               	.LM768:
 6208 1d54 8BE0      		ldi r24,lo8(11)
 6209 1d56 90E0      		ldi r25,hi8(11)
 6210 1d58 0E94 0000 		call __eerd_byte_m168
 6211 1d5c 8093 0000 		sts region,r24
 6212 1d60 10E0      		ldi r17,lo8(0)
1180:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
 6214               	.LM769:
 6215 1d62 0AE0      		ldi r16,lo8(10)
 6216 1d64 00C0      		rjmp .L394
 6217               	.L387:
1176:iv.c          ****   region = eeprom_read_byte((uint8_t *)EE_REGION);
 6219               	.LM770:
 6220 1d66 10E0      		ldi r17,lo8(0)
 6221               	.L394:
1179:iv.c          ****     if (just_pressed || pressed) {
 6223               	.LM771:
 6224 1d68 8091 0000 		lds r24,just_pressed
 6225 1d6c 8823      		tst r24
 6226 1d6e 01F4      		brne .L380
 6227 1d70 8091 0000 		lds r24,pressed
 6228 1d74 8823      		tst r24
 6229 1d76 01F0      		breq .L381
 6230               	.L380:
1180:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
 6232               	.LM772:
 6233 1d78 0093 0000 		sts timeoutcounter,r16
 6234 1d7c 00C0      		rjmp .L382
 6235               	.L381:
1182:iv.c          ****     } else if (!timeoutcounter) {
 6237               	.LM773:
 6238 1d7e 8091 0000 		lds r24,timeoutcounter
 6239 1d82 8823      		tst r24
 6240 1d84 01F0      		breq .L385
 6241               	.L382:
1187:iv.c          ****     if (just_pressed & 0x1) { // mode change
 6243               	.LM774:
 6244 1d86 8091 0000 		lds r24,just_pressed
 6245 1d8a 80FD      		sbrc r24,0
 6246 1d8c 00C0      		rjmp .L391
1190:iv.c          ****     if (just_pressed & 0x2) {
 6248               	.LM775:
 6249 1d8e 8091 0000 		lds r24,just_pressed
 6250 1d92 81FF      		sbrs r24,1
 6251 1d94 00C0      		rjmp .L384
1191:iv.c          ****       just_pressed = 0;
 6253               	.LM776:
 6254 1d96 1092 0000 		sts just_pressed,__zero_reg__
1192:iv.c          ****       if (mode == SHOW_MENU) {
 6256               	.LM777:
 6257 1d9a 1123      		tst r17
 6258 1d9c 01F4      		brne .L385
1196:iv.c          **** 	if (region == REGION_US) {
 6260               	.LM778:
 6261 1d9e 8091 0000 		lds r24,region
 6262 1da2 8823      		tst r24
 6263 1da4 01F4      		brne .L386
1197:iv.c          **** 	  display_str("usa-12hr");
 6265               	.LM779:
 6266 1da6 80E0      		ldi r24,lo8(.LC25)
 6267 1da8 90E0      		ldi r25,hi8(.LC25)
 6268 1daa 00C0      		rjmp .L395
 6269               	.L386:
1199:iv.c          **** 	  display_str("eur-24hr");
 6271               	.LM780:
 6272 1dac 80E0      		ldi r24,lo8(.LC26)
 6273 1dae 90E0      		ldi r25,hi8(.LC26)
 6274               	.L395:
 6275 1db0 0E94 0000 		call display_str
 6276 1db4 11E0      		ldi r17,lo8(1)
 6277 1db6 00C0      		rjmp .L384
 6278               	.L385:
1202:iv.c          **** 	displaymode = SHOW_TIME;
 6280               	.LM781:
 6281 1db8 1092 0000 		sts displaymode,__zero_reg__
 6282 1dbc 00C0      		rjmp .L391
 6283               	.L384:
1206:iv.c          ****     if (just_pressed & 0x4) {
 6285               	.LM782:
 6286 1dbe 8091 0000 		lds r24,just_pressed
 6287 1dc2 82FF      		sbrs r24,2
 6288 1dc4 00C0      		rjmp .L394
1207:iv.c          ****       just_pressed = 0;
 6290               	.LM783:
 6291 1dc6 1092 0000 		sts just_pressed,__zero_reg__
1208:iv.c          ****       if (mode == SET_REG) {
 6293               	.LM784:
 6294 1dca 1130      		cpi r17,lo8(1)
 6295 1dcc 01F4      		brne .L387
1209:iv.c          **** 	region = !region;
 6297               	.LM785:
 6298 1dce 90E0      		ldi r25,lo8(0)
 6299 1dd0 8091 0000 		lds r24,region
 6300 1dd4 8823      		tst r24
 6301 1dd6 01F4      		brne .L388
 6302 1dd8 91E0      		ldi r25,lo8(1)
 6303               	.L388:
 6304 1dda 9093 0000 		sts region,r25
1210:iv.c          **** 	if (region == REGION_US) {
 6306               	.LM786:
 6307 1dde 9923      		tst r25
 6308 1de0 01F4      		brne .L389
1211:iv.c          **** 	  display_str("usa-12hr");
 6310               	.LM787:
 6311 1de2 80E0      		ldi r24,lo8(.LC25)
 6312 1de4 90E0      		ldi r25,hi8(.LC25)
 6313 1de6 00C0      		rjmp .L396
 6314               	.L389:
1213:iv.c          **** 	  display_str("eur-24hr");
 6316               	.LM788:
 6317 1de8 80E0      		ldi r24,lo8(.LC26)
 6318 1dea 90E0      		ldi r25,hi8(.LC26)
 6319               	.L396:
 6320 1dec 0E94 0000 		call display_str
1215:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_REGION, region);
 6322               	.LM789:
 6323 1df0 8BE0      		ldi r24,lo8(11)
 6324 1df2 90E0      		ldi r25,hi8(11)
 6325 1df4 6091 0000 		lds r22,region
 6326 1df8 0E94 0000 		call __eewr_byte_m168
 6327 1dfc 00C0      		rjmp .L394
 6328               	.L391:
 6329               	/* epilogue start */
1219:iv.c          **** }
 6331               	.LM790:
 6332 1dfe 1F91      		pop r17
 6333 1e00 0F91      		pop r16
 6334 1e02 0895      		ret
 6339               	.Lscope42:
 6341               		.stabd	78,0,0
 6342               		.data
 6343               	.LC27:
 6344 00b5 766F 6C20 		.string	"vol high"
 6344      6869 6768 
 6344      00
 6345               	.LC28:
 6346 00be 766F 6C20 		.string	"vol  low"
 6346      206C 6F77 
 6346      00
 6347               		.text
 6349               	.global	set_volume
 6351               	set_volume:
 6352               		.stabd	46,0,0
1109:iv.c          **** void set_volume(void) {
 6354               	.LM791:
 6355               	.LFBB43:
 6356 1e04 EF92      		push r14
 6357 1e06 FF92      		push r15
 6358 1e08 0F93      		push r16
 6359 1e0a 1F93      		push r17
 6360               	/* prologue: function */
 6361               	/* frame size = 0 */
1113:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;;  
 6363               	.LM792:
 6364 1e0c 8AE0      		ldi r24,lo8(10)
 6365 1e0e 8093 0000 		sts timeoutcounter,r24
1114:iv.c          ****   volume = eeprom_read_byte((uint8_t *)EE_VOLUME);
 6367               	.LM793:
 6368 1e12 8AE0      		ldi r24,lo8(10)
 6369 1e14 90E0      		ldi r25,hi8(10)
 6370 1e16 0E94 0000 		call __eerd_byte_m168
 6371 1e1a F82E      		mov r15,r24
 6372 1e1c 00E0      		ldi r16,lo8(0)
1118:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
 6374               	.LM794:
 6375 1e1e FAE0      		ldi r31,lo8(10)
 6376 1e20 EF2E      		mov r14,r31
 6377 1e22 00C0      		rjmp .L414
 6378               	.L407:
1114:iv.c          ****   volume = eeprom_read_byte((uint8_t *)EE_VOLUME);
 6380               	.LM795:
 6381 1e24 00E0      		ldi r16,lo8(0)
 6382               	.L414:
1117:iv.c          ****     if (just_pressed || pressed) {
 6384               	.LM796:
 6385 1e26 8091 0000 		lds r24,just_pressed
 6386 1e2a 8823      		tst r24
 6387 1e2c 01F4      		brne .L399
 6388 1e2e 8091 0000 		lds r24,pressed
 6389 1e32 8823      		tst r24
 6390 1e34 01F0      		breq .L400
 6391               	.L399:
1118:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
 6393               	.LM797:
 6394 1e36 E092 0000 		sts timeoutcounter,r14
 6395 1e3a 00C0      		rjmp .L401
 6396               	.L400:
1120:iv.c          ****     } else if (!timeoutcounter) {
 6398               	.LM798:
 6399 1e3c 8091 0000 		lds r24,timeoutcounter
 6400 1e40 8823      		tst r24
 6401 1e42 01F0      		breq .L404
 6402               	.L401:
1125:iv.c          ****     if (just_pressed & 0x1) { // mode change
 6404               	.LM799:
 6405 1e44 8091 0000 		lds r24,just_pressed
 6406 1e48 80FD      		sbrc r24,0
 6407 1e4a 00C0      		rjmp .L411
1128:iv.c          ****     if (just_pressed & 0x2) {
 6409               	.LM800:
 6410 1e4c 8091 0000 		lds r24,just_pressed
 6411 1e50 81FF      		sbrs r24,1
 6412 1e52 00C0      		rjmp .L403
1129:iv.c          ****       just_pressed = 0;
 6414               	.LM801:
 6415 1e54 1092 0000 		sts just_pressed,__zero_reg__
1130:iv.c          ****       if (mode == SHOW_MENU) {
 6417               	.LM802:
 6418 1e58 0023      		tst r16
 6419 1e5a 01F4      		brne .L404
1134:iv.c          **** 	if (volume) {
 6421               	.LM803:
 6422 1e5c FF20      		tst r15
 6423 1e5e 01F0      		breq .L405
1135:iv.c          **** 	  display_str("vol high");
 6425               	.LM804:
 6426 1e60 80E0      		ldi r24,lo8(.LC27)
 6427 1e62 90E0      		ldi r25,hi8(.LC27)
 6428 1e64 0E94 0000 		call display_str
1136:iv.c          **** 	  display[5] |= 0x1;
 6430               	.LM805:
 6431 1e68 8091 0000 		lds r24,display+5
 6432 1e6c 8160      		ori r24,lo8(1)
 6433 1e6e 8093 0000 		sts display+5,r24
 6434 1e72 00C0      		rjmp .L406
 6435               	.L405:
1138:iv.c          **** 	  display_str("vol  low");
 6437               	.LM806:
 6438 1e74 80E0      		ldi r24,lo8(.LC28)
 6439 1e76 90E0      		ldi r25,hi8(.LC28)
 6440 1e78 0E94 0000 		call display_str
 6441               	.L406:
1140:iv.c          **** 	display[6] |= 0x1;
 6443               	.LM807:
 6444 1e7c 8091 0000 		lds r24,display+6
 6445 1e80 8160      		ori r24,lo8(1)
 6446 1e82 8093 0000 		sts display+6,r24
1141:iv.c          **** 	display[7] |= 0x1;
 6448               	.LM808:
 6449 1e86 8091 0000 		lds r24,display+7
 6450 1e8a 8160      		ori r24,lo8(1)
 6451 1e8c 8093 0000 		sts display+7,r24
1142:iv.c          **** 	display[8] |= 0x1;
 6453               	.LM809:
 6454 1e90 8091 0000 		lds r24,display+8
 6455 1e94 8160      		ori r24,lo8(1)
 6456 1e96 8093 0000 		sts display+8,r24
 6457 1e9a 01E0      		ldi r16,lo8(1)
 6458 1e9c 00C0      		rjmp .L403
 6459               	.L404:
1144:iv.c          **** 	displaymode = SHOW_TIME;
 6461               	.LM810:
 6462 1e9e 1092 0000 		sts displaymode,__zero_reg__
 6463 1ea2 00C0      		rjmp .L411
 6464               	.L403:
1148:iv.c          ****     if (just_pressed & 0x4) {
 6466               	.LM811:
 6467 1ea4 8091 0000 		lds r24,just_pressed
 6468 1ea8 82FF      		sbrs r24,2
 6469 1eaa 00C0      		rjmp .L414
1149:iv.c          ****       just_pressed = 0;
 6471               	.LM812:
 6472 1eac 1092 0000 		sts just_pressed,__zero_reg__
1150:iv.c          ****       if (mode == SET_VOL) {
 6474               	.LM813:
 6475 1eb0 0130      		cpi r16,lo8(1)
 6476 1eb2 01F0      		breq .+2
 6477 1eb4 00C0      		rjmp .L407
1151:iv.c          **** 	volume = !volume;
 6479               	.LM814:
 6480 1eb6 10E0      		ldi r17,lo8(0)
 6481 1eb8 FF20      		tst r15
 6482 1eba 01F4      		brne .L408
 6483 1ebc 11E0      		ldi r17,lo8(1)
 6484               	.L408:
 6485 1ebe F12E      		mov r15,r17
1152:iv.c          **** 	if (volume) {
 6487               	.LM815:
 6488 1ec0 1123      		tst r17
 6489 1ec2 01F0      		breq .L409
1153:iv.c          **** 	  display_str("vol high");
 6491               	.LM816:
 6492 1ec4 80E0      		ldi r24,lo8(.LC27)
 6493 1ec6 90E0      		ldi r25,hi8(.LC27)
 6494 1ec8 0E94 0000 		call display_str
1154:iv.c          **** 	  display[5] |= 0x1;
 6496               	.LM817:
 6497 1ecc 8091 0000 		lds r24,display+5
 6498 1ed0 8160      		ori r24,lo8(1)
 6499 1ed2 8093 0000 		sts display+5,r24
 6500 1ed6 00C0      		rjmp .L410
 6501               	.L409:
1156:iv.c          **** 	  display_str("vol  low");
 6503               	.LM818:
 6504 1ed8 80E0      		ldi r24,lo8(.LC28)
 6505 1eda 90E0      		ldi r25,hi8(.LC28)
 6506 1edc 0E94 0000 		call display_str
 6507               	.L410:
1158:iv.c          **** 	display[6] |= 0x1;
 6509               	.LM819:
 6510 1ee0 8091 0000 		lds r24,display+6
 6511 1ee4 8160      		ori r24,lo8(1)
 6512 1ee6 8093 0000 		sts display+6,r24
1159:iv.c          **** 	display[7] |= 0x1;
 6514               	.LM820:
 6515 1eea 8091 0000 		lds r24,display+7
 6516 1eee 8160      		ori r24,lo8(1)
 6517 1ef0 8093 0000 		sts display+7,r24
1160:iv.c          **** 	display[8] |= 0x1;
 6519               	.LM821:
 6520 1ef4 8091 0000 		lds r24,display+8
 6521 1ef8 8160      		ori r24,lo8(1)
 6522 1efa 8093 0000 		sts display+8,r24
1161:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_VOLUME, volume);
 6524               	.LM822:
 6525 1efe 8AE0      		ldi r24,lo8(10)
 6526 1f00 90E0      		ldi r25,hi8(10)
 6527 1f02 612F      		mov r22,r17
 6528 1f04 0E94 0000 		call __eewr_byte_m168
1162:iv.c          **** 	speaker_init();
 6530               	.LM823:
 6531 1f08 0E94 0000 		call speaker_init
1163:iv.c          **** 	beep(4000, 1);
 6533               	.LM824:
 6534 1f0c 80EA      		ldi r24,lo8(4000)
 6535 1f0e 9FE0      		ldi r25,hi8(4000)
 6536 1f10 61E0      		ldi r22,lo8(1)
 6537 1f12 0E94 0000 		call beep
 6538 1f16 00C0      		rjmp .L414
 6539               	.L411:
 6540               	/* epilogue start */
1167:iv.c          **** }
 6542               	.LM825:
 6543 1f18 1F91      		pop r17
 6544 1f1a 0F91      		pop r16
 6545 1f1c FF90      		pop r15
 6546 1f1e EF90      		pop r14
 6547 1f20 0895      		ret
 6553               	.Lscope43:
 6555               		.stabd	78,0,0
 6557               	.global	wakeup
 6559               	wakeup:
 6560               		.stabd	46,0,0
 457:iv.c          ****  void wakeup(void) {
 6562               	.LM826:
 6563               	.LFBB44:
 6564               	/* prologue: function */
 6565               	/* frame size = 0 */
 458:iv.c          ****    if (!sleepmode)
 6567               	.LM827:
 6568 1f22 8091 0000 		lds r24,sleepmode
 6569 1f26 8823      		tst r24
 6570 1f28 01F4      		brne .+2
 6571 1f2a 00C0      		rjmp .L417
 460:iv.c          ****    CLKPR = _BV(CLKPCE);
 6573               	.LM828:
 6574 1f2c 80E8      		ldi r24,lo8(-128)
 6575 1f2e 8093 6100 		sts 97,r24
 461:iv.c          ****    CLKPR = 0;
 6577               	.LM829:
 6578 1f32 1092 6100 		sts 97,__zero_reg__
 462:iv.c          ****    DEBUGP("waketime");
 6580               	.LM830:
 6581 1f36 80E0      		ldi r24,lo8(__c.2056)
 6582 1f38 90E0      		ldi r25,hi8(__c.2056)
 6583 1f3a 61E0      		ldi r22,lo8(1)
 6584 1f3c 0E94 0000 		call ROM_putstring
 463:iv.c          ****    sleepmode = 0;
 6586               	.LM831:
 6587 1f40 1092 0000 		sts sleepmode,__zero_reg__
 6588               	.LBB227:
 6589               	.LBB228:
 6590               	.LBB229:
 6591               	.LBB230:
 6593               	.Ltext9:
 6595               	.LM832:
 6596 1f44 80E4      		ldi r24,lo8(-25536)
 6597 1f46 9CE9      		ldi r25,hi8(-25536)
 6598               	/* #APP */
 6599               	 ;  105 "/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h" 1
 6600 1f48 0197      		1: sbiw r24,1
 6601 1f4a 01F4      		brne 1b
 6602               	 ;  0 "" 2
 6603               	/* #NOAPP */
 6604               	.LBE230:
 6605               	.LBE229:
 6606               	.LBE228:
 6607               	.LBE227:
 6609               	.Ltext10:
 467:iv.c          ****    if (ACSR & _BV(ACO)) 
 6611               	.LM833:
 6612 1f4c 00B6      		in __tmp_reg__,80-32
 6613 1f4e 05FC      		sbrc __tmp_reg__,5
 6614 1f50 00C0      		rjmp .L417
 471:iv.c          ****    initbuttons();
 6616               	.LM834:
 6617 1f52 0E94 0000 		call initbuttons
 474:iv.c          ****    dimmer_init();
 6619               	.LM835:
 6620 1f56 0E94 0000 		call dimmer_init
 478:iv.c          ****    brightness_level = eeprom_read_byte((uint8_t *)EE_BRIGHT);
 6622               	.LM836:
 6623 1f5a 89E0      		ldi r24,lo8(9)
 6624 1f5c 90E0      		ldi r25,hi8(9)
 6625 1f5e 0E94 0000 		call __eerd_byte_m168
 6626 1f62 8093 0000 		sts brightness_level,r24
 479:iv.c          ****    boost_init(brightness_level);
 6628               	.LM837:
 6629 1f66 8091 0000 		lds r24,brightness_level
 6630 1f6a 0E94 0000 		call boost_init
 6631               	.LBB231:
 6632               	.LBB232:
1708:iv.c          ****   SPCR  = _BV(SPE) | _BV(MSTR) | _BV(SPR0);
 6634               	.LM838:
 6635 1f6e 81E5      		ldi r24,lo8(81)
 6636 1f70 8CBD      		out 76-32,r24
 6637               	.LBE232:
 6638               	.LBE231:
 485:iv.c          ****    VFDSWITCH_PORT &= ~_BV(VFDSWITCH); 
 6640               	.LM839:
 6641 1f72 5B98      		cbi 43-32,3
 486:iv.c          ****    VFDBLANK_PORT &= ~_BV(VFDBLANK);
 6643               	.LM840:
 6644 1f74 4398      		cbi 40-32,3
 487:iv.c          ****    volume = eeprom_read_byte((uint8_t *)EE_VOLUME); // reset
 6646               	.LM841:
 6647 1f76 8AE0      		ldi r24,lo8(10)
 6648 1f78 90E0      		ldi r25,hi8(10)
 6649 1f7a 0E94 0000 		call __eerd_byte_m168
 6650 1f7e 8093 0000 		sts volume,r24
 489:iv.c          ****    speaker_init();
 6652               	.LM842:
 6653 1f82 0E94 0000 		call speaker_init
 6654               	.LBB233:
 6655               	.LBB234:
 138:iv.c          ****   wdt_reset();
 6657               	.LM843:
 6658               	/* #APP */
 6659               	 ;  138 "iv.c" 1
 6660 1f86 A895      		wdr
 6661               	 ;  0 "" 2
 6662               	/* #NOAPP */
 6663               	.LBE234:
 6664               	.LBE233:
 493:iv.c          ****    setalarmstate();
 6666               	.LM844:
 6667 1f88 0E94 0000 		call setalarmstate
 496:iv.c          ****    beep(880, 1);
 6669               	.LM845:
 6670 1f8c 80E7      		ldi r24,lo8(880)
 6671 1f8e 93E0      		ldi r25,hi8(880)
 6672 1f90 61E0      		ldi r22,lo8(1)
 6673 1f92 0E94 0000 		call beep
 497:iv.c          ****    beep(1760, 1);
 6675               	.LM846:
 6676 1f96 80EE      		ldi r24,lo8(1760)
 6677 1f98 96E0      		ldi r25,hi8(1760)
 6678 1f9a 61E0      		ldi r22,lo8(1)
 6679 1f9c 0E94 0000 		call beep
 498:iv.c          ****    beep(3520, 1);
 6681               	.LM847:
 6682 1fa0 80EC      		ldi r24,lo8(3520)
 6683 1fa2 9DE0      		ldi r25,hi8(3520)
 6684 1fa4 61E0      		ldi r22,lo8(1)
 6685 1fa6 0E94 0000 		call beep
 6686               	.LBB235:
 6687               	.LBB236:
 138:iv.c          ****   wdt_reset();
 6689               	.LM848:
 6690               	/* #APP */
 6691               	 ;  138 "iv.c" 1
 6692 1faa A895      		wdr
 6693               	 ;  0 "" 2
 6694               	/* #NOAPP */
 6695               	.L417:
 6696 1fac 0895      		ret
 6697               	.LBE236:
 6698               	.LBE235:
 6700               	.Lscope44:
 6702               		.stabd	78,0,0
 6703               		.data
 6704               	.LC29:
 6705 00c7 0A0D 5469 		.string	"\n\rTimezone offset hour:\t"
 6705      6D65 7A6F 
 6705      6E65 206F 
 6705      6666 7365 
 6705      7420 686F 
 6706               		.text
 6708               	.global	set_timezone
 6710               	set_timezone:
 6711               		.stabd	46,0,0
 973:iv.c          **** void set_timezone(void) {
 6713               	.LM849:
 6714               	.LFBB45:
 6715 1fae EF92      		push r14
 6716 1fb0 FF92      		push r15
 6717 1fb2 0F93      		push r16
 6718 1fb4 1F93      		push r17
 6719 1fb6 DF93      		push r29
 6720 1fb8 CF93      		push r28
 6721 1fba 00D0      		rcall .
 6722 1fbc CDB7      		in r28,__SP_L__
 6723 1fbe DEB7      		in r29,__SP_H__
 6724               	/* prologue: function */
 6725               	/* frame size = 2 */
 974:iv.c          ****   int8_t hour = intTimeZoneHour;
 6727               	.LM850:
 6728 1fc0 0091 0000 		lds r16,intTimeZoneHour
 975:iv.c          ****   uint8_t min = intTimeZoneMin;
 6730               	.LM851:
 6731 1fc4 F090 0000 		lds r15,intTimeZoneMin
 977:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;
 6733               	.LM852:
 6734 1fc8 8AE0      		ldi r24,lo8(10)
 6735 1fca 8093 0000 		sts timeoutcounter,r24
 6736 1fce 10E0      		ldi r17,lo8(0)
 984:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;  
 6738               	.LM853:
 6739 1fd0 AAE0      		ldi r26,lo8(10)
 6740 1fd2 EA2E      		mov r14,r26
 6741               	.L435:
 980:iv.c          ****     if (just_pressed & 0x1) { // mode change
 6743               	.LM854:
 6744 1fd4 8091 0000 		lds r24,just_pressed
 6745 1fd8 80FD      		sbrc r24,0
 6746 1fda 00C0      		rjmp .L431
 983:iv.c          ****     if (just_pressed || pressed) {
 6748               	.LM855:
 6749 1fdc 8091 0000 		lds r24,just_pressed
 6750 1fe0 8823      		tst r24
 6751 1fe2 01F4      		brne .L420
 6752 1fe4 8091 0000 		lds r24,pressed
 6753 1fe8 8823      		tst r24
 6754 1fea 01F0      		breq .L421
 6755               	.L420:
 984:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;  
 6757               	.LM856:
 6758 1fec E092 0000 		sts timeoutcounter,r14
 6759 1ff0 00C0      		rjmp .L422
 6760               	.L421:
 986:iv.c          ****     } else if (!timeoutcounter) {
 6762               	.LM857:
 6763 1ff2 8091 0000 		lds r24,timeoutcounter
 6764 1ff6 8823      		tst r24
 6765 1ff8 01F0      		breq .L425
 6766               	.L422:
 991:iv.c          ****     if (just_pressed & 0x2) {
 6768               	.LM858:
 6769 1ffa 8091 0000 		lds r24,just_pressed
 6770 1ffe 81FF      		sbrs r24,1
 6771 2000 00C0      		rjmp .L423
 992:iv.c          ****       just_pressed = 0;
 6773               	.LM859:
 6774 2002 1092 0000 		sts just_pressed,__zero_reg__
 993:iv.c          ****       if (mode == SHOW_MENU) {
 6776               	.LM860:
 6777 2006 1123      		tst r17
 6778 2008 01F4      		brne .L424
 996:iv.c          **** 	display_timezone(hour, min);
 6780               	.LM861:
 6781 200a 802F      		mov r24,r16
 6782 200c 9927      		clr r25
 6783 200e 87FD      		sbrc r24,7
 6784 2010 9095      		com r25
 6785 2012 6F2D      		mov r22,r15
 6786 2014 70E0      		ldi r23,lo8(0)
 6787 2016 0E94 0000 		call display_timezone
 997:iv.c          **** 	display[1] |= 0x1;
 6789               	.LM862:
 6790 201a 8091 0000 		lds r24,display+1
 6791 201e 8160      		ori r24,lo8(1)
 6792 2020 8093 0000 		sts display+1,r24
 998:iv.c          **** 	display[2] |= 0x1;	
 6794               	.LM863:
 6795 2024 8091 0000 		lds r24,display+2
 6796 2028 8160      		ori r24,lo8(1)
 6797 202a 8093 0000 		sts display+2,r24
 6798 202e 11E0      		ldi r17,lo8(1)
 6799 2030 00C0      		rjmp .L423
 6800               	.L424:
 999:iv.c          ****       } else if (mode == SET_HOUR) {
 6802               	.LM864:
 6803 2032 1130      		cpi r17,lo8(1)
 6804 2034 01F4      		brne .L425
1001:iv.c          **** 	display_timezone(hour, min);
 6806               	.LM865:
 6807 2036 802F      		mov r24,r16
 6808 2038 9927      		clr r25
 6809 203a 87FD      		sbrc r24,7
 6810 203c 9095      		com r25
 6811 203e 6F2D      		mov r22,r15
 6812 2040 70E0      		ldi r23,lo8(0)
 6813 2042 0E94 0000 		call display_timezone
1002:iv.c          **** 	display[4] |= 0x1;
 6815               	.LM866:
 6816 2046 8091 0000 		lds r24,display+4
 6817 204a 8160      		ori r24,lo8(1)
 6818 204c 8093 0000 		sts display+4,r24
1003:iv.c          **** 	display[5] |= 0x1;
 6820               	.LM867:
 6821 2050 8091 0000 		lds r24,display+5
 6822 2054 8160      		ori r24,lo8(1)
 6823 2056 8093 0000 		sts display+5,r24
 6824 205a 12E0      		ldi r17,lo8(2)
 6825 205c 00C0      		rjmp .L423
 6826               	.L425:
1006:iv.c          **** 	displaymode = SHOW_TIME;
 6828               	.LM868:
 6829 205e 1092 0000 		sts displaymode,__zero_reg__
 6830 2062 00C0      		rjmp .L431
 6831               	.L423:
1010:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
 6833               	.LM869:
 6834 2064 8091 0000 		lds r24,just_pressed
 6835 2068 82FD      		sbrc r24,2
 6836 206a 00C0      		rjmp .L426
 6837 206c 8091 0000 		lds r24,pressed
 6838 2070 82FF      		sbrs r24,2
 6839 2072 00C0      		rjmp .L435
 6840               	.L426:
1011:iv.c          ****       just_pressed = 0;
 6842               	.LM870:
 6843 2074 1092 0000 		sts just_pressed,__zero_reg__
1013:iv.c          ****       if (mode == SET_HOUR) {
 6845               	.LM871:
 6846 2078 1130      		cpi r17,lo8(1)
 6847 207a 01F4      		brne .L428
1014:iv.c          **** 	hour = ( ( hour + 1 + 12 ) % 25 ) - 12;
 6849               	.LM872:
 6850 207c 802F      		mov r24,r16
 6851 207e 9927      		clr r25
 6852 2080 87FD      		sbrc r24,7
 6853 2082 9095      		com r25
 6854 2084 0D96      		adiw r24,13
 6855 2086 69E1      		ldi r22,lo8(25)
 6856 2088 70E0      		ldi r23,hi8(25)
 6857 208a 0E94 0000 		call __divmodhi4
 6858 208e 082F      		mov r16,r24
 6859 2090 0C50      		subi r16,lo8(-(-12))
1015:iv.c          **** 	display_timezone(hour, min);
 6861               	.LM873:
 6862 2092 802F      		mov r24,r16
 6863 2094 9927      		clr r25
 6864 2096 87FD      		sbrc r24,7
 6865 2098 9095      		com r25
 6866 209a 9A83      		std Y+2,r25
 6867 209c 8983      		std Y+1,r24
 6868 209e 6F2D      		mov r22,r15
 6869 20a0 70E0      		ldi r23,lo8(0)
 6870 20a2 0E94 0000 		call display_timezone
1016:iv.c          **** 	display[1] |= 0x1;
 6872               	.LM874:
 6873 20a6 8091 0000 		lds r24,display+1
 6874 20aa 8160      		ori r24,lo8(1)
 6875 20ac 8093 0000 		sts display+1,r24
1017:iv.c          **** 	display[2] |= 0x1;
 6877               	.LM875:
 6878 20b0 8091 0000 		lds r24,display+2
 6879 20b4 8160      		ori r24,lo8(1)
 6880 20b6 8093 0000 		sts display+2,r24
1018:iv.c          ****         intTimeZoneHour = hour;
 6882               	.LM876:
 6883 20ba 0093 0000 		sts intTimeZoneHour,r16
1019:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_ZONE_HOUR, hour);
 6885               	.LM877:
 6886 20be 8DE0      		ldi r24,lo8(13)
 6887 20c0 90E0      		ldi r25,hi8(13)
 6888 20c2 602F      		mov r22,r16
 6889 20c4 0E94 0000 		call __eewr_byte_m168
1021:iv.c          **** 	uart_puts("\n\rTimezone offset hour:\t");
 6891               	.LM878:
 6892 20c8 80E0      		ldi r24,lo8(.LC29)
 6893 20ca 90E0      		ldi r25,hi8(.LC29)
 6894 20cc 0E94 0000 		call uart_puts
1022:iv.c          **** 	uart_putw_dec(hour);
 6896               	.LM879:
 6897 20d0 8981      		ldd r24,Y+1
 6898 20d2 9A81      		ldd r25,Y+2
 6899 20d4 0E94 0000 		call uart_putw_dec
 6900 20d8 00C0      		rjmp .L429
 6901               	.L428:
1024:iv.c          ****       if (mode == SET_MIN) {
 6903               	.LM880:
 6904 20da 1230      		cpi r17,lo8(2)
 6905 20dc 01F4      		brne .L429
1025:iv.c          **** 	min = ( min + 1 ) % 60;
 6907               	.LM881:
 6908 20de 8F2D      		mov r24,r15
 6909 20e0 90E0      		ldi r25,lo8(0)
 6910 20e2 0196      		adiw r24,1
 6911 20e4 6CE3      		ldi r22,lo8(60)
 6912 20e6 70E0      		ldi r23,hi8(60)
 6913 20e8 0E94 0000 		call __divmodhi4
 6914 20ec F82E      		mov r15,r24
1026:iv.c          **** 	display_timezone(hour, min);
 6916               	.LM882:
 6917 20ee 802F      		mov r24,r16
 6918 20f0 9927      		clr r25
 6919 20f2 87FD      		sbrc r24,7
 6920 20f4 9095      		com r25
 6921 20f6 6F2D      		mov r22,r15
 6922 20f8 70E0      		ldi r23,lo8(0)
 6923 20fa 0E94 0000 		call display_timezone
1027:iv.c          **** 	display[4] |= 0x1;
 6925               	.LM883:
 6926 20fe 8091 0000 		lds r24,display+4
 6927 2102 8160      		ori r24,lo8(1)
 6928 2104 8093 0000 		sts display+4,r24
1028:iv.c          **** 	display[5] |= 0x1;
 6930               	.LM884:
 6931 2108 8091 0000 		lds r24,display+5
 6932 210c 8160      		ori r24,lo8(1)
 6933 210e 8093 0000 		sts display+5,r24
1029:iv.c          ****         intTimeZoneMin = min;
 6935               	.LM885:
 6936 2112 F092 0000 		sts intTimeZoneMin,r15
1030:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_ZONE_MIN, min);
 6938               	.LM886:
 6939 2116 8EE0      		ldi r24,lo8(14)
 6940 2118 90E0      		ldi r25,hi8(14)
 6941 211a 6F2D      		mov r22,r15
 6942 211c 0E94 0000 		call __eewr_byte_m168
 6943               	.L429:
1033:iv.c          ****       if (pressed & 0x4)
 6945               	.LM887:
 6946 2120 8091 0000 		lds r24,pressed
 6947 2124 82FF      		sbrs r24,2
 6948 2126 00C0      		rjmp .L435
 6949               	.LBB237:
 6950               	.LBB238:
 116:iv.c          ****   sei();
 6952               	.LM888:
 6953               	/* #APP */
 6954               	 ;  116 "iv.c" 1
 6955 2128 7894      		sei
 6956               	 ;  0 "" 2
 118:iv.c          ****   milliseconds = 0;
 6958               	.LM889:
 6959               	/* #NOAPP */
 6960 212a 1092 0000 		sts (milliseconds)+1,__zero_reg__
 6961 212e 1092 0000 		sts milliseconds,__zero_reg__
 6962               	.L430:
 119:iv.c          ****   while (milliseconds < ms);
 6964               	.LM890:
 6965 2132 8091 0000 		lds r24,milliseconds
 6966 2136 9091 0000 		lds r25,(milliseconds)+1
 6967 213a 8B34      		cpi r24,75
 6968 213c 9105      		cpc r25,__zero_reg__
 6969 213e 00F0      		brlo .L430
 6970 2140 00C0      		rjmp .L435
 6971               	.L431:
 6972               	/* epilogue start */
 6973               	.LBE238:
 6974               	.LBE237:
1037:iv.c          **** }
 6976               	.LM891:
 6977 2142 0F90      		pop __tmp_reg__
 6978 2144 0F90      		pop __tmp_reg__
 6979 2146 CF91      		pop r28
 6980 2148 DF91      		pop r29
 6981 214a 1F91      		pop r17
 6982 214c 0F91      		pop r16
 6983 214e FF90      		pop r15
 6984 2150 EF90      		pop r14
 6985 2152 0895      		ret
 6992               	.Lscope45:
 6994               		.stabd	78,0,0
 6995               		.data
 6996               	.LC30:
 6997 00e0 0A0D 4865 		.string	"\n\rHello World!\n\r"
 6997      6C6C 6F20 
 6997      576F 726C 
 6997      6421 0A0D 
 6997      00
 6998               	.LC31:
 6999 00f1 0A0D 4275 		.string	"\n\rBuffer size is:\t"
 6999      6666 6572 
 6999      2073 697A 
 6999      6520 6973 
 6999      3A09 00
 7000               	.LC32:
 7001 0104 7365 7420 		.string	"set alarm"
 7001      616C 6172 
 7001      6D00 
 7002               	.LC33:
 7003 010e 7365 7420 		.string	"set time"
 7003      7469 6D65 
 7003      00
 7004               	.LC34:
 7005 0117 7365 7420 		.string	"set date"
 7005      6461 7465 
 7005      00
 7006               	.LC35:
 7007 0120 7365 7420 		.string	"set zone"
 7007      7A6F 6E65 
 7007      00
 7008               	.LC36:
 7009 0129 7365 7420 		.string	"set brit"
 7009      6272 6974 
 7009      00
 7010               	.LC37:
 7011 0132 7365 7420 		.string	"set vol "
 7011      766F 6C20 
 7011      00
 7012               	.LC38:
 7013 013b 7365 7420 		.string	"set regn"
 7013      7265 676E 
 7013      00
 7014               		.text
 7016               	.global	main
 7018               	main:
 7019               		.stabd	46,0,0
 518:iv.c          **** int main(void) {
 7021               	.LM892:
 7022               	.LFBB46:
 7023 2154 AF92      		push r10
 7024 2156 BF92      		push r11
 7025 2158 CF92      		push r12
 7026 215a DF92      		push r13
 7027 215c EF92      		push r14
 7028 215e FF92      		push r15
 7029 2160 0F93      		push r16
 7030 2162 1F93      		push r17
 7031               	/* prologue: function */
 7032               	/* frame size = 0 */
 523:iv.c          ****   TCCR0B = 0;
 7034               	.LM893:
 7035 2164 15BC      		out 69-32,__zero_reg__
 524:iv.c          ****   BOOST_DDR |= _BV(BOOST);
 7037               	.LM894:
 7038 2166 569A      		sbi 42-32,6
 525:iv.c          ****   BOOST_PORT &= ~_BV(BOOST); // pull boost fet low
 7040               	.LM895:
 7041 2168 5E98      		cbi 43-32,6
 528:iv.c          ****   mcustate = MCUSR;
 7043               	.LM896:
 7044 216a 84B7      		in r24,84-32
 529:iv.c          ****   MCUSR = 0;
 7046               	.LM897:
 7047 216c 14BE      		out 84-32,__zero_reg__
 531:iv.c          ****   uart_putw_hex(mcustate);
 7049               	.LM898:
 7050 216e 90E0      		ldi r25,lo8(0)
 7051 2170 0E94 0000 		call uart_putw_hex
 533:iv.c          ****   wdt_disable();
 7053               	.LM899:
 7054 2174 88E1      		ldi r24,lo8(24)
 7055               	/* #APP */
 7056               	 ;  533 "iv.c" 1
 7057 2176 0FB6      		in __tmp_reg__, __SREG__
 7058 2178 F894      		cli
 7059 217a 8093 6000 		sts 96, r24
 7060 217e 1092 6000 		sts 96, __zero_reg__
 7061 2182 0FBE      		out __SREG__,__tmp_reg__
 7062               		
 7063               	 ;  0 "" 2
 537:iv.c          ****   wdt_enable(WDTO_2S);
 7065               	.LM900:
 7066               	/* #NOAPP */
 7067 2184 2FE0      		ldi r18,lo8(15)
 7068 2186 88E1      		ldi r24,lo8(24)
 7069 2188 90E0      		ldi r25,hi8(24)
 7070               	/* #APP */
 7071               	 ;  537 "iv.c" 1
 7072 218a 0FB6      		in __tmp_reg__,__SREG__
 7073 218c F894      		cli
 7074 218e A895      		wdr
 7075 2190 8093 6000 		sts 96,r24
 7076 2194 0FBE      		out __SREG__,__tmp_reg__
 7077 2196 2093 6000 		sts 96,r18
 7078               		
 7079               	 ;  0 "" 2
 7080               	/* #NOAPP */
 7081               	.LBB239:
 7082               	.LBB240:
 138:iv.c          ****   wdt_reset();
 7084               	.LM901:
 7085               	/* #APP */
 7086               	 ;  138 "iv.c" 1
 7087 219a A895      		wdr
 7088               	 ;  0 "" 2
 7089               	/* #NOAPP */
 7090               	.LBE240:
 7091               	.LBE239:
 542:iv.c          ****   timeunknown = 1;
 7093               	.LM902:
 7094 219c 11E0      		ldi r17,lo8(1)
 7095 219e 1093 0000 		sts timeunknown,r17
 545:iv.c          ****   restored = 0;
 7097               	.LM903:
 7098 21a2 1092 0000 		sts restored,__zero_reg__
 548:iv.c          ****   uart_init(BRRL_4800);
 7100               	.LM904:
 7101 21a6 87E6      		ldi r24,lo8(103)
 7102 21a8 90E0      		ldi r25,hi8(103)
 7103 21aa 0E94 0000 		call uart_init
 551:iv.c          ****   DEBUGP("!");
 7105               	.LM905:
 7106 21ae 80E0      		ldi r24,lo8(__c.2088)
 7107 21b0 90E0      		ldi r25,hi8(__c.2088)
 7108 21b2 61E0      		ldi r22,lo8(1)
 7109 21b4 0E94 0000 		call ROM_putstring
 552:iv.c          ****   uart_puts("\n\rHello World!\n\r");
 7111               	.LM906:
 7112 21b8 80E0      		ldi r24,lo8(.LC30)
 7113 21ba 90E0      		ldi r25,hi8(.LC30)
 7114 21bc 0E94 0000 		call uart_puts
 553:iv.c          ****   uart_puts("\n\rBuffer size is:\t");
 7116               	.LM907:
 7117 21c0 80E0      		ldi r24,lo8(.LC31)
 7118 21c2 90E0      		ldi r25,hi8(.LC31)
 7119 21c4 0E94 0000 		call uart_puts
 554:iv.c          ****   uart_putw_dec(BUFFERSIZE);
 7121               	.LM908:
 7122 21c8 80E8      		ldi r24,lo8(128)
 7123 21ca 90E0      		ldi r25,hi8(128)
 7124 21cc 0E94 0000 		call uart_putw_dec
 555:iv.c          ****   uart_puts("\n\r");
 7126               	.LM909:
 7127 21d0 80E0      		ldi r24,lo8(.LC24)
 7128 21d2 90E0      		ldi r25,hi8(.LC24)
 7129 21d4 0E94 0000 		call uart_puts
 559:iv.c          ****   ACSR = _BV(ACBG) | _BV(ACIE); // use bandgap, intr. on toggle!
 7131               	.LM910:
 7132 21d8 88E4      		ldi r24,lo8(72)
 7133 21da 80BF      		out 80-32,r24
 7134               	.LBB241:
 7135               	.LBB242:
 7136               	.LBB243:
 7137               	.LBB244:
 7139               	.Ltext11:
 7141               	.LM911:
 7142 21dc 80ED      		ldi r24,lo8(2000)
 7143 21de 97E0      		ldi r25,hi8(2000)
 7144               	/* #APP */
 7145               	 ;  105 "/usr/local/lib/gcc/avr/4.3.4/../../../../avr/include/util/delay_basic.h" 1
 7146 21e0 0197      		1: sbiw r24,1
 7147 21e2 01F4      		brne 1b
 7148               	 ;  0 "" 2
 7149               	/* #NOAPP */
 7150               	.LBE244:
 7151               	.LBE243:
 7152               	.LBE242:
 7153               	.LBE241:
 7155               	.Ltext12:
 562:iv.c          ****   if (ACSR & _BV(ACO)) {
 7157               	.LM912:
 7158 21e4 00B6      		in __tmp_reg__,80-32
 7159 21e6 05FE      		sbrs __tmp_reg__,5
 7160 21e8 00C0      		rjmp .L437
 564:iv.c          ****     ACSR |= _BV(ACI);
 7162               	.LM913:
 7163 21ea 80B7      		in r24,80-32
 7164 21ec 8061      		ori r24,lo8(16)
 7165 21ee 80BF      		out 80-32,r24
 567:iv.c          ****     DEBUGP("clock init");
 7167               	.LM914:
 7168 21f0 80E0      		ldi r24,lo8(__c.2090)
 7169 21f2 90E0      		ldi r25,hi8(__c.2090)
 7170 21f4 61E0      		ldi r22,lo8(1)
 7171 21f6 0E94 0000 		call ROM_putstring
 568:iv.c          ****     clock_init();  
 7173               	.LM915:
 7174 21fa 0E94 0000 		call clock_init
 7175 21fe 00C0      		rjmp .L438
 7176               	.L437:
 574:iv.c          ****     initbuttons();
 7178               	.LM916:
 7179 2200 0E94 0000 		call initbuttons
 576:iv.c          ****     VFDSWITCH_PORT &= ~_BV(VFDSWITCH);
 7181               	.LM917:
 7182 2204 5B98      		cbi 43-32,3
 578:iv.c          ****     DEBUGP("turning on buttons");
 7184               	.LM918:
 7185 2206 80E0      		ldi r24,lo8(__c.2092)
 7186 2208 90E0      		ldi r25,hi8(__c.2092)
 7187 220a 61E0      		ldi r22,lo8(1)
 7188 220c 0E94 0000 		call ROM_putstring
 580:iv.c          ****     DEBUGP("turning on alarmsw");
 7190               	.LM919:
 7191 2210 80E0      		ldi r24,lo8(__c.2094)
 7192 2212 90E0      		ldi r25,hi8(__c.2094)
 7193 2214 61E0      		ldi r22,lo8(1)
 7194 2216 0E94 0000 		call ROM_putstring
 582:iv.c          ****     EICRA = _BV(ISC00);
 7196               	.LM920:
 7197 221a 1093 6900 		sts 105,r17
 583:iv.c          ****     EIMSK = _BV(INT0);
 7199               	.LM921:
 7200 221e 1DBB      		out 61-32,r17
 585:iv.c          ****     displaymode = SHOW_TIME;
 7202               	.LM922:
 7203 2220 1092 0000 		sts displaymode,__zero_reg__
 586:iv.c          ****     DEBUGP("vfd init");
 7205               	.LM923:
 7206 2224 80E0      		ldi r24,lo8(__c.2096)
 7207 2226 90E0      		ldi r25,hi8(__c.2096)
 7208 2228 61E0      		ldi r22,lo8(1)
 7209 222a 0E94 0000 		call ROM_putstring
 7210               	.LBB245:
 7211               	.LBB246:
1708:iv.c          ****   SPCR  = _BV(SPE) | _BV(MSTR) | _BV(SPR0);
 7213               	.LM924:
 7214 222e 81E5      		ldi r24,lo8(81)
 7215 2230 8CBD      		out 76-32,r24
 7216               	.LBE246:
 7217               	.LBE245:
 590:iv.c          ****     dimmer_init();
 7219               	.LM925:
 7220 2232 0E94 0000 		call dimmer_init
 593:iv.c          ****     DEBUGP("boost init");
 7222               	.LM926:
 7223 2236 80E0      		ldi r24,lo8(__c.2098)
 7224 2238 90E0      		ldi r25,hi8(__c.2098)
 7225 223a 61E0      		ldi r22,lo8(1)
 7226 223c 0E94 0000 		call ROM_putstring
 594:iv.c          ****     brightness_level = eeprom_read_byte((uint8_t *)EE_BRIGHT);
 7228               	.LM927:
 7229 2240 89E0      		ldi r24,lo8(9)
 7230 2242 90E0      		ldi r25,hi8(9)
 7231 2244 0E94 0000 		call __eerd_byte_m168
 7232 2248 8093 0000 		sts brightness_level,r24
 595:iv.c          ****     boost_init(brightness_level);
 7234               	.LM928:
 7235 224c 8091 0000 		lds r24,brightness_level
 7236 2250 0E94 0000 		call boost_init
 596:iv.c          ****     sei();
 7238               	.LM929:
 7239               	/* #APP */
 7240               	 ;  596 "iv.c" 1
 7241 2254 7894      		sei
 7242               	 ;  0 "" 2
 599:iv.c          ****     intTimeZoneHour = eeprom_read_byte((uint8_t *)EE_ZONE_HOUR);
 7244               	.LM930:
 7245               	/* #NOAPP */
 7246 2256 8DE0      		ldi r24,lo8(13)
 7247 2258 90E0      		ldi r25,hi8(13)
 7248 225a 0E94 0000 		call __eerd_byte_m168
 7249 225e 8093 0000 		sts intTimeZoneHour,r24
 600:iv.c          ****     if ( ( 12 < intTimeZoneHour ) || ( -12 > intTimeZoneHour ) )
 7251               	.LM931:
 7252 2262 845F      		subi r24,lo8(-(12))
 7253 2264 8931      		cpi r24,lo8(25)
 7254 2266 00F0      		brlo .L439
 601:iv.c          ****       intTimeZoneHour = 0;
 7256               	.LM932:
 7257 2268 1092 0000 		sts intTimeZoneHour,__zero_reg__
 7258               	.L439:
 603:iv.c          ****     intTimeZoneMin = eeprom_read_byte((uint8_t *)EE_ZONE_MIN);
 7260               	.LM933:
 7261 226c 8EE0      		ldi r24,lo8(14)
 7262 226e 90E0      		ldi r25,hi8(14)
 7263 2270 0E94 0000 		call __eerd_byte_m168
 7264 2274 8093 0000 		sts intTimeZoneMin,r24
 604:iv.c          ****     if ( ( 60 < intTimeZoneMin ) || ( 0 > intTimeZoneMin ) )
 7266               	.LM934:
 7267 2278 8D33      		cpi r24,lo8(61)
 7268 227a 00F0      		brlo .L440
 605:iv.c          ****       intTimeZoneMin = 0;
 7270               	.LM935:
 7271 227c 1092 0000 		sts intTimeZoneMin,__zero_reg__
 7272               	.L440:
 607:iv.c          ****     region = eeprom_read_byte((uint8_t *)EE_REGION);
 7274               	.LM936:
 7275 2280 8BE0      		ldi r24,lo8(11)
 7276 2282 90E0      		ldi r25,hi8(11)
 7277 2284 0E94 0000 		call __eerd_byte_m168
 7278 2288 8093 0000 		sts region,r24
 609:iv.c          ****     DEBUGP("speaker init");
 7280               	.LM937:
 7281 228c 80E0      		ldi r24,lo8(__c.2100)
 7282 228e 90E0      		ldi r25,hi8(__c.2100)
 7283 2290 61E0      		ldi r22,lo8(1)
 7284 2292 0E94 0000 		call ROM_putstring
 610:iv.c          ****     speaker_init();
 7286               	.LM938:
 7287 2296 0E94 0000 		call speaker_init
 612:iv.c          ****     beep(4000, 1);
 7289               	.LM939:
 7290 229a 80EA      		ldi r24,lo8(4000)
 7291 229c 9FE0      		ldi r25,hi8(4000)
 7292 229e 61E0      		ldi r22,lo8(1)
 7293 22a0 0E94 0000 		call beep
 614:iv.c          ****     DEBUGP("clock init");
 7295               	.LM940:
 7296 22a4 80E0      		ldi r24,lo8(__c.2102)
 7297 22a6 90E0      		ldi r25,hi8(__c.2102)
 7298 22a8 61E0      		ldi r22,lo8(1)
 7299 22aa 0E94 0000 		call ROM_putstring
 615:iv.c          ****     clock_init();  
 7301               	.LM941:
 7302 22ae 0E94 0000 		call clock_init
 617:iv.c          ****     DEBUGP("alarm init");
 7304               	.LM942:
 7305 22b2 80E0      		ldi r24,lo8(__c.2104)
 7306 22b4 90E0      		ldi r25,hi8(__c.2104)
 7307 22b6 61E0      		ldi r22,lo8(1)
 7308 22b8 0E94 0000 		call ROM_putstring
 618:iv.c          ****     setalarmstate();
 7310               	.LM943:
 7311 22bc 0E94 0000 		call setalarmstate
 7312               	.L438:
 620:iv.c          ****   DEBUGP("done");
 7314               	.LM944:
 7315 22c0 80E0      		ldi r24,lo8(__c.2106)
 7316 22c2 90E0      		ldi r25,hi8(__c.2106)
 7317 22c4 61E0      		ldi r22,lo8(1)
 7318 22c6 0E94 0000 		call ROM_putstring
 685:iv.c          ****       displaymode = NONE;
 7320               	.LM945:
 7321 22ca 23E6      		ldi r18,lo8(99)
 7322 22cc A22E      		mov r10,r18
 654:iv.c          ****         displaymode = SET_ZONE;
 7324               	.LM946:
 7325 22ce 9BE0      		ldi r25,lo8(11)
 7326 22d0 B92E      		mov r11,r25
 669:iv.c          **** 	displaymode = SET_REGION;
 7328               	.LM947:
 7329 22d2 88E0      		ldi r24,lo8(8)
 7330 22d4 C82E      		mov r12,r24
 664:iv.c          **** 	displaymode = SET_VOLUME;
 7332               	.LM948:
 7333 22d6 07E0      		ldi r16,lo8(7)
 7334 22d8 D02E      		mov r13,r16
 659:iv.c          ****         displaymode = SET_BRIGHTNESS;
 7336               	.LM949:
 7337 22da 16E0      		ldi r17,lo8(6)
 7338 22dc E12E      		mov r14,r17
 646:iv.c          **** 	displaymode = SET_DATE;
 7340               	.LM950:
 7341 22de B5E0      		ldi r27,lo8(5)
 7342 22e0 FB2E      		mov r15,r27
 640:iv.c          **** 	displaymode = SET_TIME;
 7344               	.LM951:
 7345 22e2 03E0      		ldi r16,lo8(3)
 635:iv.c          **** 	displaymode = SET_ALARM;
 7347               	.LM952:
 7348 22e4 14E0      		ldi r17,lo8(4)
 7349               	.L460:
 7350               	.LBB247:
 7351               	.LBB248:
 138:iv.c          ****   wdt_reset();
 7353               	.LM953:
 7354               	/* #APP */
 7355               	 ;  138 "iv.c" 1
 7356 22e6 A895      		wdr
 7357               	 ;  0 "" 2
 7358               	/* #NOAPP */
 7359               	.LBE248:
 7360               	.LBE247:
 625:iv.c          ****     if (ACSR & _BV(ACO)) {
 7362               	.LM954:
 7363 22e8 00B6      		in __tmp_reg__,80-32
 7364 22ea 05FE      		sbrs __tmp_reg__,5
 7365 22ec 00C0      		rjmp .L441
 627:iv.c          ****       gotosleep();
 7367               	.LM955:
 7368 22ee 0E94 0000 		call gotosleep
 7369 22f2 00C0      		rjmp .L460
 7370               	.L441:
 631:iv.c          ****     if (just_pressed & 0x1) {
 7372               	.LM956:
 7373 22f4 8091 0000 		lds r24,just_pressed
 7374 22f8 80FF      		sbrs r24,0
 7375 22fa 00C0      		rjmp .L443
 632:iv.c          ****       just_pressed = 0;
 7377               	.LM957:
 7378 22fc 1092 0000 		sts just_pressed,__zero_reg__
 633:iv.c          ****       switch(displaymode) {
 7380               	.LM958:
 7381 2300 8091 0000 		lds r24,displaymode
 7382 2304 8530      		cpi r24,lo8(5)
 7383 2306 01F0      		breq .L448
 7384 2308 8630      		cpi r24,lo8(6)
 7385 230a 00F4      		brsh .L452
 7386 230c 8330      		cpi r24,lo8(3)
 7387 230e 01F0      		breq .L446
 7388 2310 8430      		cpi r24,lo8(4)
 7389 2312 00F4      		brsh .L447
 7390 2314 8823      		tst r24
 7391 2316 01F0      		breq .L445
 7392 2318 00C0      		rjmp .L461
 7393               	.L452:
 7394 231a 8730      		cpi r24,lo8(7)
 7395 231c 01F0      		breq .L450
 7396 231e 8730      		cpi r24,lo8(7)
 7397 2320 00F0      		brlo .L449
 7398 2322 8B30      		cpi r24,lo8(11)
 7399 2324 01F0      		breq .+2
 7400 2326 00C0      		rjmp .L461
 7401 2328 00C0      		rjmp .L462
 7402               	.L445:
 635:iv.c          **** 	displaymode = SET_ALARM;
 7404               	.LM959:
 7405 232a 1093 0000 		sts displaymode,r17
 636:iv.c          **** 	display_str("set alarm");
 7407               	.LM960:
 7408 232e 80E0      		ldi r24,lo8(.LC32)
 7409 2330 90E0      		ldi r25,hi8(.LC32)
 7410 2332 0E94 0000 		call display_str
 637:iv.c          **** 	set_alarm();
 7412               	.LM961:
 7413 2336 0E94 0000 		call set_alarm
 7414 233a 00C0      		rjmp .L453
 7415               	.L447:
 640:iv.c          **** 	displaymode = SET_TIME;
 7417               	.LM962:
 7418 233c 0093 0000 		sts displaymode,r16
 641:iv.c          **** 	display_str("set time");
 7420               	.LM963:
 7421 2340 80E0      		ldi r24,lo8(.LC33)
 7422 2342 90E0      		ldi r25,hi8(.LC33)
 7423 2344 0E94 0000 		call display_str
 642:iv.c          **** 	set_time();
 7425               	.LM964:
 7426 2348 0E94 0000 		call set_time
 643:iv.c          **** 	timeunknown = 0;
 7428               	.LM965:
 7429 234c 1092 0000 		sts timeunknown,__zero_reg__
 7430 2350 00C0      		rjmp .L453
 7431               	.L446:
 646:iv.c          **** 	displaymode = SET_DATE;
 7433               	.LM966:
 7434 2352 F092 0000 		sts displaymode,r15
 647:iv.c          **** 	display_str("set date");
 7436               	.LM967:
 7437 2356 80E0      		ldi r24,lo8(.LC34)
 7438 2358 90E0      		ldi r25,hi8(.LC34)
 7439 235a 0E94 0000 		call display_str
 648:iv.c          **** 	set_date();
 7441               	.LM968:
 7442 235e 0E94 0000 		call set_date
 7443 2362 00C0      		rjmp .L453
 7444               	.L448:
 654:iv.c          ****         displaymode = SET_ZONE;
 7446               	.LM969:
 7447 2364 B092 0000 		sts displaymode,r11
 655:iv.c          ****         display_str("set zone");
 7449               	.LM970:
 7450 2368 80E0      		ldi r24,lo8(.LC35)
 7451 236a 90E0      		ldi r25,hi8(.LC35)
 7452 236c 0E94 0000 		call display_str
 656:iv.c          ****         set_timezone();
 7454               	.LM971:
 7455 2370 0E94 0000 		call set_timezone
 7456 2374 00C0      		rjmp .L453
 7457               	.L462:
 659:iv.c          ****         displaymode = SET_BRIGHTNESS;
 7459               	.LM972:
 7460 2376 E092 0000 		sts displaymode,r14
 660:iv.c          ****         display_str("set brit");
 7462               	.LM973:
 7463 237a 80E0      		ldi r24,lo8(.LC36)
 7464 237c 90E0      		ldi r25,hi8(.LC36)
 7465 237e 0E94 0000 		call display_str
 661:iv.c          ****         set_brightness();
 7467               	.LM974:
 7468 2382 0E94 0000 		call set_brightness
 7469 2386 00C0      		rjmp .L453
 7470               	.L449:
 664:iv.c          **** 	displaymode = SET_VOLUME;
 7472               	.LM975:
 7473 2388 D092 0000 		sts displaymode,r13
 665:iv.c          **** 	display_str("set vol ");
 7475               	.LM976:
 7476 238c 80E0      		ldi r24,lo8(.LC37)
 7477 238e 90E0      		ldi r25,hi8(.LC37)
 7478 2390 0E94 0000 		call display_str
 666:iv.c          **** 	set_volume();
 7480               	.LM977:
 7481 2394 0E94 0000 		call set_volume
 7482 2398 00C0      		rjmp .L453
 7483               	.L450:
 669:iv.c          **** 	displaymode = SET_REGION;
 7485               	.LM978:
 7486 239a C092 0000 		sts displaymode,r12
 670:iv.c          **** 	display_str("set regn");
 7488               	.LM979:
 7489 239e 80E0      		ldi r24,lo8(.LC38)
 7490 23a0 90E0      		ldi r25,hi8(.LC38)
 7491 23a2 0E94 0000 		call display_str
 671:iv.c          **** 	set_region();
 7493               	.LM980:
 7494 23a6 0E94 0000 		call set_region
 7495 23aa 00C0      		rjmp .L453
 7496               	.L443:
 683:iv.c          ****     } else if ((just_pressed & 0x2) || (just_pressed & 0x4)) {
 7498               	.LM981:
 7499 23ac 8091 0000 		lds r24,just_pressed
 7500 23b0 81FD      		sbrc r24,1
 7501 23b2 00C0      		rjmp .L454
 7502 23b4 8091 0000 		lds r24,just_pressed
 7503 23b8 82FF      		sbrs r24,2
 7504 23ba 00C0      		rjmp .L453
 7505               	.L454:
 684:iv.c          ****       just_pressed = 0;
 7507               	.LM982:
 7508 23bc 1092 0000 		sts just_pressed,__zero_reg__
 685:iv.c          ****       displaymode = NONE;
 7510               	.LM983:
 7511 23c0 A092 0000 		sts displaymode,r10
 686:iv.c          ****       display_date(DAY);
 7513               	.LM984:
 7514 23c4 81E0      		ldi r24,lo8(1)
 7515 23c6 0E94 0000 		call display_date
 7516               	.LBB249:
 7517               	.LBB250:
 138:iv.c          ****   wdt_reset();
 7519               	.LM985:
 7520               	/* #APP */
 7521               	 ;  138 "iv.c" 1
 7522 23ca A895      		wdr
 7523               	 ;  0 "" 2
 7524               	/* #NOAPP */
 7525               	.LBE250:
 7526               	.LBE249:
 7527               	.LBB251:
 7528               	.LBB252:
 116:iv.c          ****   sei();
 7530               	.LM986:
 7531               	/* #APP */
 7532               	 ;  116 "iv.c" 1
 7533 23cc 7894      		sei
 7534               	 ;  0 "" 2
 118:iv.c          ****   milliseconds = 0;
 7536               	.LM987:
 7537               	/* #NOAPP */
 7538 23ce 1092 0000 		sts (milliseconds)+1,__zero_reg__
 7539 23d2 1092 0000 		sts milliseconds,__zero_reg__
 7540               	.L455:
 119:iv.c          ****   while (milliseconds < ms);
 7542               	.LM988:
 7543 23d6 8091 0000 		lds r24,milliseconds
 7544 23da 9091 0000 		lds r25,(milliseconds)+1
 7545 23de 8C5D      		subi r24,lo8(1500)
 7546 23e0 9540      		sbci r25,hi8(1500)
 7547 23e2 00F0      		brlo .L455
 7548               	.LBE252:
 7549               	.LBE251:
 7550               	.LBB253:
 7551               	.LBB254:
 138:iv.c          ****   wdt_reset();
 7553               	.LM989:
 7554               	/* #APP */
 7555               	 ;  138 "iv.c" 1
 7556 23e4 A895      		wdr
 7557               	 ;  0 "" 2
 7558               	/* #NOAPP */
 7559               	.L461:
 7560               	.LBE254:
 7561               	.LBE253:
 692:iv.c          ****       displaymode = SHOW_TIME;     
 7563               	.LM990:
 7564 23e6 1092 0000 		sts displaymode,__zero_reg__
 7565               	.L453:
 7566               	.LBB255:
 7567               	.LBB256:
1762:iv.c          ****   return (UCSR0A & _BV(RXC0));
 7569               	.LM991:
 7570 23ea 8091 C000 		lds r24,192
 7571               	.LBE256:
 7572               	.LBE255:
 696:iv.c          ****     if ( gpsdataready() ) {
 7574               	.LM992:
 7575 23ee 87FF      		sbrs r24,7
 7576 23f0 00C0      		rjmp .L460
 697:iv.c          ****        getgpstime();
 7578               	.LM993:
 7579 23f2 0E94 0000 		call getgpstime
 7580 23f6 00C0      		rjmp .L460
 7585               	.Lscope46:
 7587               		.stabd	78,0,0
 7589               	.global	__vector_1
 7591               	__vector_1:
 7592               		.stabd	46,0,0
 352:iv.c          **** SIGNAL(SIG_INTERRUPT0) {
 7594               	.LM994:
 7595               	.LFBB47:
 7596 23f8 1F92      		push __zero_reg__
 7597 23fa 0F92      		push r0
 7598 23fc 0FB6      		in r0,__SREG__
 7599 23fe 0F92      		push r0
 7600 2400 1124      		clr __zero_reg__
 7601 2402 2F93      		push r18
 7602 2404 3F93      		push r19
 7603 2406 4F93      		push r20
 7604 2408 5F93      		push r21
 7605 240a 6F93      		push r22
 7606 240c 7F93      		push r23
 7607 240e 8F93      		push r24
 7608 2410 9F93      		push r25
 7609 2412 AF93      		push r26
 7610 2414 BF93      		push r27
 7611 2416 EF93      		push r30
 7612 2418 FF93      		push r31
 7613               	/* prologue: Signal */
 7614               	/* frame size = 0 */
 353:iv.c          ****   EIMSK = 0;  //Disable this interrupt while we are processing it.
 7616               	.LM995:
 7617 241a 1DBA      		out 61-32,__zero_reg__
 354:iv.c          ****   uart_putchar('i');
 7619               	.LM996:
 7620 241c 89E6      		ldi r24,lo8(105)
 7621 241e 0E94 0000 		call uart_putchar
 355:iv.c          ****   uint8_t x = ALARM_PIN & _BV(ALARM);
 7623               	.LM997:
 7624 2422 29B1      		in r18,41-32
 356:iv.c          ****   sei();
 7626               	.LM998:
 7627               	/* #APP */
 7628               	 ;  356 "iv.c" 1
 7629 2424 7894      		sei
 7630               	 ;  0 "" 2
 7631               	/* #NOAPP */
 7632               	.LBB257:
 7633               	.LBB258:
 116:iv.c          ****   sei();
 7635               	.LM999:
 7636               	/* #APP */
 7637               	 ;  116 "iv.c" 1
 7638 2426 7894      		sei
 7639               	 ;  0 "" 2
 118:iv.c          ****   milliseconds = 0;
 7641               	.LM1000:
 7642               	/* #NOAPP */
 7643 2428 1092 0000 		sts (milliseconds)+1,__zero_reg__
 7644 242c 1092 0000 		sts milliseconds,__zero_reg__
 7645               	.L464:
 119:iv.c          ****   while (milliseconds < ms);
 7647               	.LM1001:
 7648 2430 8091 0000 		lds r24,milliseconds
 7649 2434 9091 0000 		lds r25,(milliseconds)+1
 7650 2438 0A97      		sbiw r24,10
 7651 243a 00F0      		brlo .L464
 7652               	.LBE258:
 7653               	.LBE257:
 358:iv.c          ****   if (x != (ALARM_PIN & _BV(ALARM)))
 7655               	.LM1002:
 7656 243c 89B1      		in r24,41-32
 7657 243e 2470      		andi r18,lo8(4)
 7658 2440 30E0      		ldi r19,lo8(0)
 7659 2442 90E0      		ldi r25,lo8(0)
 7660 2444 8470      		andi r24,lo8(4)
 7661 2446 9070      		andi r25,hi8(4)
 7662 2448 2817      		cp r18,r24
 7663 244a 3907      		cpc r19,r25
 7664 244c 01F4      		brne .L469
 7665               	.L465:
 363:iv.c          ****   setalarmstate();
 7667               	.LM1003:
 7668 244e 0E94 0000 		call setalarmstate
 7669               	.L469:
 364:iv.c          ****   EIMSK = _BV(INT0);  //And reenable it before exiting.
 7671               	.LM1004:
 7672 2452 81E0      		ldi r24,lo8(1)
 7673 2454 8DBB      		out 61-32,r24
 7674               	/* epilogue start */
 365:iv.c          **** }
 7676               	.LM1005:
 7677 2456 FF91      		pop r31
 7678 2458 EF91      		pop r30
 7679 245a BF91      		pop r27
 7680 245c AF91      		pop r26
 7681 245e 9F91      		pop r25
 7682 2460 8F91      		pop r24
 7683 2462 7F91      		pop r23
 7684 2464 6F91      		pop r22
 7685 2466 5F91      		pop r21
 7686 2468 4F91      		pop r20
 7687 246a 3F91      		pop r19
 7688 246c 2F91      		pop r18
 7689 246e 0F90      		pop r0
 7690 2470 0FBE      		out __SREG__,r0
 7691 2472 0F90      		pop r0
 7692 2474 1F90      		pop __zero_reg__
 7693 2476 1895      		reti
 7695               	.Lscope47:
 7697               		.stabd	78,0,0
 7698               	.global	app_start
 7699               	.global	app_start
 7700               		.section .bss
 7703               	app_start:
 7704 0000 0000      		.skip 2,0
 7705               	.global	alphatable
 7706               		.section	.progmem.data,"a",@progbits
 7709               	alphatable:
 7710 0000 FA        		.byte	-6
 7711 0001 3E        		.byte	62
 7712 0002 1A        		.byte	26
 7713 0003 7A        		.byte	122
 7714 0004 DE        		.byte	-34
 7715 0005 8E        		.byte	-114
 7716 0006 F6        		.byte	-10
 7717 0007 2E        		.byte	46
 7718 0008 60        		.byte	96
 7719 0009 78        		.byte	120
 7720 000a AE        		.byte	-82
 7721 000b 1C        		.byte	28
 7722 000c AA        		.byte	-86
 7723 000d 2A        		.byte	42
 7724 000e 3A        		.byte	58
 7725 000f CE        		.byte	-50
 7726 0010 F3        		.byte	-13
 7727 0011 0A        		.byte	10
 7728 0012 B6        		.byte	-74
 7729 0013 1E        		.byte	30
 7730 0014 38        		.byte	56
 7731 0015 38        		.byte	56
 7732 0016 B8        		.byte	-72
 7733 0017 6E        		.byte	110
 7734 0018 76        		.byte	118
 7735 0019 DA        		.byte	-38
 7736               	.global	alphatable_p
 7739               	alphatable_p:
 7740 001a 0000      		.word	alphatable
 7741               	.global	numbertable
 7744               	numbertable:
 7745 001c FC        		.byte	-4
 7746 001d 60        		.byte	96
 7747 001e DA        		.byte	-38
 7748 001f F2        		.byte	-14
 7749 0020 66        		.byte	102
 7750 0021 B6        		.byte	-74
 7751 0022 BE        		.byte	-66
 7752 0023 E0        		.byte	-32
 7753 0024 FE        		.byte	-2
 7754 0025 F6        		.byte	-10
 7755               	.global	numbertable_p
 7758               	numbertable_p:
 7759 0026 0000      		.word	numbertable
 7760               	.global	region
 7761               	.global	region
 7762               		.section .bss
 7765               	region:
 7766 0002 00        		.skip 1,0
 7767               	.global	sleepmode
 7768               	.global	sleepmode
 7771               	sleepmode:
 7772 0003 00        		.skip 1,0
 7773               	.global	timeunknown
 7774               	.global	timeunknown
 7777               	timeunknown:
 7778 0004 00        		.skip 1,0
 7779               	.global	restored
 7780               	.global	restored
 7783               	restored:
 7784 0005 00        		.skip 1,0
 7785               	.global	intBufferStatus
 7786               	.global	intBufferStatus
 7789               	intBufferStatus:
 7790 0006 00        		.skip 1,0
 7791               	.global	intTimeZoneHour
 7792               		.data
 7795               	intTimeZoneHour:
 7796 0144 FA        		.byte	-6
 7797               	.global	intTimeZoneMin
 7798               	.global	intTimeZoneMin
 7799               		.section .bss
 7802               	intTimeZoneMin:
 7803 0007 00        		.skip 1,0
 7804               	.global	currdigit
 7805               	.global	currdigit
 7808               	currdigit:
 7809 0008 00        		.skip 1,0
 7810               	.global	digittable
 7811               		.section	.progmem.data
 7814               	digittable:
 7815 0028 03        		.byte	3
 7816 0029 07        		.byte	7
 7817 002a 08        		.byte	8
 7818 002b 09        		.byte	9
 7819 002c 06        		.byte	6
 7820 002d 0A        		.byte	10
 7821 002e 05        		.byte	5
 7822 002f 0C        		.byte	12
 7823 0030 04        		.byte	4
 7824               	.global	digittable_p
 7827               	digittable_p:
 7828 0031 0000      		.word	digittable
 7829               	.global	segmenttable
 7832               	segmenttable:
 7833 0033 0B        		.byte	11
 7834 0034 10        		.byte	16
 7835 0035 12        		.byte	18
 7836 0036 0F        		.byte	15
 7837 0037 0D        		.byte	13
 7838 0038 0E        		.byte	14
 7839 0039 11        		.byte	17
 7840 003a 13        		.byte	19
 7841               	.global	segmenttable_p
 7844               	segmenttable_p:
 7845 003b 0000      		.word	segmenttable
 7846               	.global	muxdiv
 7847               	.global	muxdiv
 7848               		.section .bss
 7851               	muxdiv:
 7852 0009 0000      		.skip 2,0
 7853               	.global	alarmdiv
 7854               	.global	alarmdiv
 7857               	alarmdiv:
 7858 000b 0000      		.skip 2,0
 7859               	.global	snoozetimer
 7860               	.global	snoozetimer
 7863               	snoozetimer:
 7864 000d 0000      		.skip 2,0
 7865               	.global	milliseconds
 7866               	.global	milliseconds
 7869               	milliseconds:
 7870 000f 0000      		.skip 2,0
 7871               	.global	last_buttonstate
 7872               	.global	last_buttonstate
 7875               	last_buttonstate:
 7876 0011 00        		.skip 1,0
 7877               	.global	just_pressed
 7878               	.global	just_pressed
 7881               	just_pressed:
 7882 0012 00        		.skip 1,0
 7883               	.global	pressed
 7884               	.global	pressed
 7887               	pressed:
 7888 0013 00        		.skip 1,0
 7889               	.global	buttonholdcounter
 7890               	.global	buttonholdcounter
 7893               	buttonholdcounter:
 7894 0014 00        		.skip 1,0
 7895               	.global	timeoutcounter
 7896               	.global	timeoutcounter
 7899               	timeoutcounter:
 7900 0015 00        		.skip 1,0
 7901               		.section	.progmem.data
 7904               	__c.3243:
 7905 003d 616C 6172 		.string	"alarm on!"
 7905      6D20 6F6E 
 7905      2100 
 7908               	__c.2550:
 7909 0047 616C 6172 		.string	"alarm off"
 7909      6D20 6F66 
 7909      6600 
 7912               	__c.2287:
 7913 0051 5365 7420 		.string	"Set day"
 7913      6461 7900 
 7916               	__c.2106:
 7917 0059 646F 6E65 		.string	"done"
 7917      00
 7920               	__c.2104:
 7921 005e 616C 6172 		.string	"alarm init"
 7921      6D20 696E 
 7921      6974 00
 7924               	__c.2102:
 7925 0069 636C 6F63 		.string	"clock init"
 7925      6B20 696E 
 7925      6974 00
 7928               	__c.2100:
 7929 0074 7370 6561 		.string	"speaker init"
 7929      6B65 7220 
 7929      696E 6974 
 7929      00
 7932               	__c.2098:
 7933 0081 626F 6F73 		.string	"boost init"
 7933      7420 696E 
 7933      6974 00
 7936               	__c.2096:
 7937 008c 7666 6420 		.string	"vfd init"
 7937      696E 6974 
 7937      00
 7940               	__c.2094:
 7941 0095 7475 726E 		.string	"turning on alarmsw"
 7941      696E 6720 
 7941      6F6E 2061 
 7941      6C61 726D 
 7941      7377 00
 7944               	__c.2092:
 7945 00a8 7475 726E 		.string	"turning on buttons"
 7945      696E 6720 
 7945      6F6E 2062 
 7945      7574 746F 
 7945      6E73 00
 7948               	__c.2090:
 7949 00bb 636C 6F63 		.string	"clock init"
 7949      6B20 696E 
 7949      6974 00
 7952               	__c.2088:
 7953 00c6 2100      		.string	"!"
 7956               	__c.2056:
 7957 00c8 7761 6B65 		.string	"waketime"
 7957      7469 6D65 
 7957      00
 7960               	__c.1974:
 7961 00d1 5741 4B45 		.string	"WAKERESET"
 7961      5245 5345 
 7961      5400 
 7964               	__c.1972:
 7965 00db 7A00      		.string	"z"
 7968               	__c.1886:
 7969 00dd 6232 00   		.string	"b2"
 7972               	__c.1834:
 7973 00e0 6233 00   		.string	"b3"
 7976               	__c.1832:
 7977 00e3 6231 00   		.string	"b1"
 7980               	__c.1783:
 7981 00e6 736E 6F6F 		.string	"snooze"
 7981      7A65 00
 7982               		.comm time_s,1,1
 7983               		.comm time_m,1,1
 7984               		.comm time_h,1,1
 7985               		.comm date_m,1,1
 7986               		.comm date_d,1,1
 7987               		.comm date_y,1,1
 7988               		.comm volume,1,1
 7989               		.comm brightness_level,1,1
 7990               		.comm alarm_on,1,1
 7991               		.comm alarming,1,1
 7992               		.comm alarm_h,1,1
 7993               		.comm alarm_m,1,1
 7994               		.comm displaymode,1,1
 7995               		.comm strBuffer,128,1
 7996               		.comm display,9,1
 7997               		.comm t,4,1
 8060               		.text
 8062               	.Letext0:
 8063               	.global __do_copy_data
 8064               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 iv.c
/var/tmp//ccS2wAiu.s:2      *ABS*:0000003f __SREG__
/var/tmp//ccS2wAiu.s:3      *ABS*:0000003e __SP_H__
/var/tmp//ccS2wAiu.s:4      *ABS*:0000003d __SP_L__
/var/tmp//ccS2wAiu.s:5      *ABS*:00000034 __CCP__
/var/tmp//ccS2wAiu.s:6      *ABS*:00000000 __tmp_reg__
/var/tmp//ccS2wAiu.s:7      *ABS*:00000001 __zero_reg__
/var/tmp//ccS2wAiu.s:102    .text:00000000 delayms
/var/tmp//ccS2wAiu.s:7869   .bss:0000000f milliseconds
/var/tmp//ccS2wAiu.s:140    .text:0000001c kickthedog
/var/tmp//ccS2wAiu.s:165    .text:00000020 gotosleep
/var/tmp//ccS2wAiu.s:7771   .bss:00000003 sleepmode
                            *COM*:00000001 volume
/var/tmp//ccS2wAiu.s:276    .text:0000007a initbuttons
/var/tmp//ccS2wAiu.s:326    .text:000000a0 leapyear
/var/tmp//ccS2wAiu.s:371    .text:000000d2 tick
/var/tmp//ccS2wAiu.s:466    .text:00000122 beep
/var/tmp//ccS2wAiu.s:637    .text:000001b0 dimmer_init
/var/tmp//ccS2wAiu.s:697    .text:000001e6 dimmer_update
                            *COM*:00000001 brightness_level
/var/tmp//ccS2wAiu.s:724    .text:000001fa set_vfd_brightness
/var/tmp//ccS2wAiu.s:762    .text:00000212 boost_init
/var/tmp//ccS2wAiu.s:810    .text:00000232 __vector_21
/var/tmp//ccS2wAiu.s:931    .text:000002da display_brightness
/var/tmp//ccS2wAiu.s:7709   .progmem.data:00000000 alphatable
                            *COM*:00000009 display
/var/tmp//ccS2wAiu.s:7744   .progmem.data:0000001c numbertable
/var/tmp//ccS2wAiu.s:1051   .text:00000340 display_time
/var/tmp//ccS2wAiu.s:7765   .bss:00000002 region
/var/tmp//ccS2wAiu.s:1282   .text:00000438 display_alarm
/var/tmp//ccS2wAiu.s:1529   .text:00000538 display_timezone
/var/tmp//ccS2wAiu.s:1704   .text:000005da display_str
/var/tmp//ccS2wAiu.s:1842   .text:00000628 display_date
                            *COM*:00000001 date_m
                            *COM*:00000001 date_d
                            *COM*:00000001 date_y
/var/tmp//ccS2wAiu.s:2465   .text:00000944 vfd_init
/var/tmp//ccS2wAiu.s:2488   .text:0000094a vfd_send
/var/tmp//ccS2wAiu.s:2580   .text:0000097e setdisplay
/var/tmp//ccS2wAiu.s:7814   .progmem.data:00000028 digittable
                            *COM*:00000004 t
/var/tmp//ccS2wAiu.s:7832   .progmem.data:00000033 segmenttable
/var/tmp//ccS2wAiu.s:2721   .text:00000a36 __vector_16
/var/tmp//ccS2wAiu.s:7851   .bss:00000009 muxdiv
/var/tmp//ccS2wAiu.s:7808   .bss:00000008 currdigit
                            *COM*:00000001 alarming
/var/tmp//ccS2wAiu.s:7863   .bss:0000000d snoozetimer
/var/tmp//ccS2wAiu.s:7857   .bss:0000000b alarmdiv
/var/tmp//ccS2wAiu.s:2910   .text:00000b6e spi_xfer
/var/tmp//ccS2wAiu.s:2937   .text:00000b78 gpsdataready
/var/tmp//ccS2wAiu.s:2960   .text:00000b80 setgpstime
/var/tmp//ccS2wAiu.s:7795   .data:00000144 intTimeZoneHour
                            *COM*:00000001 time_h
/var/tmp//ccS2wAiu.s:7802   .bss:00000007 intTimeZoneMin
                            *COM*:00000001 time_m
                            *COM*:00000001 time_s
/var/tmp//ccS2wAiu.s:3036   .text:00000bd4 setgpsdate
/var/tmp//ccS2wAiu.s:7777   .bss:00000004 timeunknown
/var/tmp//ccS2wAiu.s:7783   .bss:00000005 restored
/var/tmp//ccS2wAiu.s:3098   .text:00000c18 fix_time
/var/tmp//ccS2wAiu.s:3453   .text:00000e80 set_brightness
/var/tmp//ccS2wAiu.s:7899   .bss:00000015 timeoutcounter
/var/tmp//ccS2wAiu.s:7881   .bss:00000012 just_pressed
/var/tmp//ccS2wAiu.s:7887   .bss:00000013 pressed
                            *COM*:00000001 displaymode
/var/tmp//ccS2wAiu.s:3606   .text:00000f46 set_time
/var/tmp//ccS2wAiu.s:3940   .text:0000112a set_alarm
                            *COM*:00000001 alarm_h
                            *COM*:00000001 alarm_m
/var/tmp//ccS2wAiu.s:4217   .text:000012b6 check_alarm
                            *COM*:00000001 alarm_on
/var/tmp//ccS2wAiu.s:7904   .progmem.data:0000003d __c.3243
/var/tmp//ccS2wAiu.s:4265   .text:000012ee __vector_9
/var/tmp//ccS2wAiu.s:7893   .bss:00000014 buttonholdcounter
/var/tmp//ccS2wAiu.s:4457   .text:00001412 setalarmstate
/var/tmp//ccS2wAiu.s:7908   .progmem.data:00000047 __c.2550
/var/tmp//ccS2wAiu.s:4592   .text:000014ba set_date
/var/tmp//ccS2wAiu.s:7912   .progmem.data:00000051 __c.2287
/var/tmp//ccS2wAiu.s:5002   .text:0000170e __vector_23
/var/tmp//ccS2wAiu.s:7964   .progmem.data:000000db __c.1972
/var/tmp//ccS2wAiu.s:7960   .progmem.data:000000d1 __c.1974
/var/tmp//ccS2wAiu.s:7703   .bss:00000000 app_start
/var/tmp//ccS2wAiu.s:5158   .text:000017e6 setsnooze
/var/tmp//ccS2wAiu.s:7980   .progmem.data:000000e6 __c.1783
/var/tmp//ccS2wAiu.s:5223   .text:00001828 __vector_3
/var/tmp//ccS2wAiu.s:7875   .bss:00000011 last_buttonstate
/var/tmp//ccS2wAiu.s:7968   .progmem.data:000000dd __c.1886
/var/tmp//ccS2wAiu.s:5361   .text:000018da __vector_5
/var/tmp//ccS2wAiu.s:7976   .progmem.data:000000e3 __c.1832
/var/tmp//ccS2wAiu.s:7972   .progmem.data:000000e0 __c.1834
/var/tmp//ccS2wAiu.s:5616   .text:00001a18 getgpstime
/var/tmp//ccS2wAiu.s:7789   .bss:00000006 intBufferStatus
                            *COM*:00000080 strBuffer
/var/tmp//ccS2wAiu.s:6015   .text:00001c3e speaker_init
/var/tmp//ccS2wAiu.s:6081   .text:00001ca0 clock_init
/var/tmp//ccS2wAiu.s:6193   .text:00001d4a set_region
/var/tmp//ccS2wAiu.s:6351   .text:00001e04 set_volume
/var/tmp//ccS2wAiu.s:6559   .text:00001f22 wakeup
/var/tmp//ccS2wAiu.s:7956   .progmem.data:000000c8 __c.2056
/var/tmp//ccS2wAiu.s:6710   .text:00001fae set_timezone
/var/tmp//ccS2wAiu.s:7018   .text:00002154 main
/var/tmp//ccS2wAiu.s:7952   .progmem.data:000000c6 __c.2088
/var/tmp//ccS2wAiu.s:7948   .progmem.data:000000bb __c.2090
/var/tmp//ccS2wAiu.s:7944   .progmem.data:000000a8 __c.2092
/var/tmp//ccS2wAiu.s:7940   .progmem.data:00000095 __c.2094
/var/tmp//ccS2wAiu.s:7936   .progmem.data:0000008c __c.2096
/var/tmp//ccS2wAiu.s:7932   .progmem.data:00000081 __c.2098
/var/tmp//ccS2wAiu.s:7928   .progmem.data:00000074 __c.2100
/var/tmp//ccS2wAiu.s:7924   .progmem.data:00000069 __c.2102
/var/tmp//ccS2wAiu.s:7920   .progmem.data:0000005e __c.2104
/var/tmp//ccS2wAiu.s:7916   .progmem.data:00000059 __c.2106
/var/tmp//ccS2wAiu.s:7591   .text:000023f8 __vector_1
/var/tmp//ccS2wAiu.s:7739   .progmem.data:0000001a alphatable_p
/var/tmp//ccS2wAiu.s:7758   .progmem.data:00000026 numbertable_p
/var/tmp//ccS2wAiu.s:7827   .progmem.data:00000031 digittable_p
/var/tmp//ccS2wAiu.s:7844   .progmem.data:0000003b segmenttable_p

UNDEFINED SYMBOLS
__udivmodhi4
__divmodsi4
__mulsi3
__udivmodsi4
__divmodhi4
__udivmodqi4
__divmodqi4
__eewr_byte_m168
ROM_putstring
strcmp
uart_puts
strchr
strncat
__eerd_byte_m168
uart_putw_dec
uart_putw_hex
uart_init
uart_putchar
__do_copy_data
__do_clear_bss
